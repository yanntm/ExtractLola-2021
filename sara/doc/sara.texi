\input texinfo
@setfilename sara.info
@include version.texi
@afourpaper
@finalout
@settitle Sara User's Manual


@c --------------------------------------------------------------------------


@copying
@b{About this document:}

This manual is for Sara, version @value{VERSION}, a reachability solver, last updated @value{UPDATED}.

Copyright @copyright{} Harro Wimmel

@quotation
Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with no Invariant Sections, with the Front-Cover Texts being ``A GNU Manual,'' and with the Back-Cover Texts as in (a) below.  A copy of the license is included in the section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You are free to copy and modify this GNU Manual. Buying copies from GNU Press supports the FSF in developing GNU and promoting software freedom.''
@end quotation
@end copying

@dircategory service-technology.org
@direntry
* Sara: (sara).       Structures for Automated Reachability Analysis.
@end direntry


@c --------------------------------------------------------------------------


@titlepage

@title Sara

@subtitle Structures for Automated Reachability Analysis
@subtitle @url{http://service-technology.org/sara}
@vskip 0.5em
@subtitle Version @value{VERSION}, @value{UPDATED}

@author Harro Wimmel
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage


@c --------------------------------------------------------------------------


@ifnottex
@node Top
@top Sara
@insertcopying
@end ifnottex


@c --------------------------------------------------------------------------


@menu
* First Steps::How to set up and install Sara.
* Command Line Options::How to run Sara.
* Theory::The theory behind Sara.
* Exit and Error Codes::What the error and exit codes of Sara mean.
* ChangeLog::Version history.
* GNU Free Documentation License::The license of this manual.
@end menu

@c --------------------------------------------------------------------------


@contents
@paragraphindent none


@c --------------------------------------------------------------------------


@node First Steps
@chapter First Steps
@section Setup and Installation

@enumerate
@item Go to @url{http://service-technology.org/files/sara} and download the latest release version of Sara, say @file{sara-@value{VERSION}.tar.gz}. To setup and compile Sara, change into your download directory and type

@cartouche
@smallexample
tar xfz sara-@value{VERSION}.tar.gz
cd sara-@value{VERSION}
./configure
make
@end smallexample
@end cartouche

After compilation, a binary @samp{src/sara} is generated.@footnote{On Microsoft Windows, the file will be called @file{sara.exe}.} If you experience any compiler warnings, don't panic: Sara contains some generated or third party code that we cannot influence.

@item To test whether everything went fine, type

@cartouche
@smallexample
make check
@end smallexample
@end cartouche

to execute the testcases located in @file{tests}. If everything went fine, you should see something like:

@smallexample
## ------------- ##
## Test results. ##
## ------------- ##

All <<-- TESTNUM -->> tests were successful.
@end smallexample

If an error occurs, please send the output to @email{sara@@service-technology.org}.

@item To install the binary, the manpage, and the documentation, type

@cartouche
@smallexample
make install
@end smallexample
@end cartouche

You might need superuser permissions to do so.
@end enumerate

If you need any further information, see file @file{INSTALL} for detailed instructions.


@section Contents of the Distribution

The distribution contains several directories:

@table @file
@item doc
The Texinfo documentation of Sara. The documentation can be created using @samp{make pdf}. Note you need to have Sara properly installed before (see installation description above).

@item libs
The Petri Net @acronym{API} used by Sara to parse and organize a Petri net.
Also, the Integer Programming tool lp_solve used by Sara to solve the marking equation of a Petri net.

@c @item man
@c The manpage of Sara which can be displayed using @samp{man sara} after having Sara installed (see installation description above).

@item src
The source code of Sara.

@item tests
Testcases for Sara which check the generated binary.
@end table


@c --------------------------------------------------------------------------


@section Requirements
@anchor{Requirements}

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
In order to run, compile, and develop Sara, several tools are required.

@c <<-- CHANGE START (tools required, etc.) -->>

@subsection Runtime
@itemize
@item No additional tools are necessary at runtime.
@end itemize

@c <<-- CHANGE END -->>

@subsection Compilation
To compile the source code from a source distribution, the following tools are required.

@itemize
@item GCC (@url{http://gcc.gnu.org/})
@item @acronym{GNU} Make (@url{http://www.gnu.org/software/make/})
@end itemize


@subsection Development
In case you want to make changes to the source code, the following tools are required to reconfigure and compile Hello.

@itemize
@item Autoconf, @url{http://www.gnu.org/software/autoconf/}
@item Automake, @url{http://www.gnu.org/software/automake/}
@item Bison, @url{http://www.gnu.org/software/bison/}
@item flex, @url{http://flex.sourceforge.net/}
@item Gengetopt, @url{http://www.gnu.org/software/gengetopt/}
@item help2man, @url{http://www.gnu.org/software/help2man/}
@item Texinfo, @url{http://www.gnu.org/software/texinfo/}
@end itemize

@sp 3

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
Please check our nightly build server at @url{http://service-technology.org/nightly} for the versions we use during development.


@c --------------------------------------------------------------------------


@node Command Line Options
@chapter Invoking Sara

Sara is a command line tool and does not come with a fancy @acronym{GUI}. However, Sara can be easily scripted and combined with other tools.

@section What Sara can do

Sara is a tool for solving the reachability problem for Petri nets. Given a low-level Petri net, i.e. sets of places and
transitions with weighted arcs between them, and an initial and a final marking, Sara tries to determine whether the final
marking can be reached from the initial marking by firing a sequence of transitions in the Petri net. While the initial
marking must be a map from the places to non-negative integers, that means one single marking, the final marking can be
somewhat generalized. It is possible -- for each place on its own -- to declare that the given number must be reached
exactly (as for the initial marking), covered (a higher value is allowed), or bounded (a lower value is permissible).
In addition, more general constraints may be formulated which the final marking must fulfill. Such a constraint can be
any linear (in)equation built from places and transitions.

As a by-product, also problems of form ``given a Petri net, an initial marking, and a transition multiset, is the
multiset realizable?'' can be solved. Realizable means that there is a firing sequence in the Petri net that
contains each transition exactly as often as the transition multiset dictates.

If Sara can compute the problem given, it should either tell the user that there is a solution and present a firing
sequence proving this, or it should tell that the problem is infeasible. In the latter case, Sara might provide
additional information that gives some insight into why the problem is infeasible. 

@section Command Line Options

For an overview of the command line options, type @samp{sara --detailed-help} to see the following help screen:

@smallexample
@verbatiminclude cmdline.out
@end smallexample

@section Creating a Problem

Before solving problems is possible one must first be able to formulate these problems. Sara offers several
options here. Assume there is a Petri net @file{test2.owfn} in one of the formats supported by the parsers, here the
open net format *.owfn (all example nets should be found in the @file{tests/testfiles} folder). The Petri net
file is expected to contain the net itself and the initial marking. If the initial marking is missing, it is assumed to
be zero on all places. In our example, the initial marking is @samp{i1+i2}, i.e. one token on place @samp{i1}, one token on @samp{i2},
and no other tokens. For the final marking @samp{o1+o2} is chosen. A problem statement can now be generated.

@cartouche
@smallexample
sara -r test2.owfn --owfn -f"o1,o2"
@end smallexample
@end cartouche

The command line option @option{-r} declares @file{test2.owfn} as input for a reachability problem, using the file's net structure
and initial marking. The option @option{--owfn} declares the net to be in the open net format. Other formats would be the LOLA *.llnet-format
(with the option @option{--lola}) or the PNML format (with the option @option{--pnml}). The default format is PNML unless the filename
contains one of the strings @samp{owfn} or @samp{llnet} (upper case is allowed). In our case, the option @option{--owfn} can be omitted.
At last, a final (goal) marking is required and this is taken from the @option{-f} option that should be followed by a comma-separated list
with one entry for each place having more than zero tokens. If there is no number of tokens given, like here, it is
assumed a place should have exactly one token.

The result is a new file @file{test2.owfn.sara} (with just .sara appended to the original filename).
It has the following content, defining the problem statement.

@cartouche
@smallexample
@verbatiminclude test2.sara
@end smallexample
@end cartouche

The problem statement can of course be edited and e.g. the initial or final marking can be changed.
If the line containing the initial marking is omitted or does not contain any place names the
initial marking will instead be taken from the given Petri net description.
In the file @file{test11.sara} there are three problem statements specifying very different final markings.

@cartouche
@smallexample
@verbatiminclude test11.sara
@end smallexample
@end cartouche

In each problem the initial marking contains exactly five tokens on each of the three places of the Petri
net given in @file{test11.owfn}. The first problem specifies the final marking to have exactly four tokens 
on each of the places, in the second problem any marking with at most four tokens on each place is considered
to be fulfilling the goal, and in the last problem any of the infinitely many markings with at least four
tokens on each of the places is a valid final marking.

To obtain a problem statement like the third one, one could invoke Sara like this:

@cartouche
@smallexample
sara -r test11.owfn -f"p1>4,p2>4,p3>4"
@end smallexample
@end cartouche

Note the citation marks that are necessary to ensure the shell will not misinterpret the is-greater-than sign
(actually meaning ``is greater or equal'' here) with its built-in output redirection functionality.

If the user does not specify the number of tokens on some place in the initial or final marking, it is assumed
to be zero. Usually, when a Petri net is large, there are many places with zero tokens in the initial or final
marking. For the final marking, we have the option whether this number zero should be reached exactly (which is
the same as an upper bound of zero) or if the number zero should be covered, meaning that any (non-negative)
number of tokens is allowed. There is a global option selecting all unmentioned places in the final
marking to be either exactly zero or to allow any number of tokens.

@cartouche
@smallexample
sara -r test11.owfn -f"p1>4"
sara -r test11.owfn -f"REACH p1>4"
sara -r test11.owfn -f"p1>4,p2>0,p3>0"
sara -r test11.owfn -f"COVER p1>4"
@end smallexample
@end cartouche

The first two calls are synonymous and specify that the number of tokens on the unmentioned places @samp{p2} and @samp{p3} should
be exactly zero in the final marking. The third and fourth line both do not specify the number of tokens on @samp{p2}
and @samp{p3}, i.e. it may be arbitrarily high.

Either in addition to or as a replacement of the final marking global constraints can be formulated. Two example
problems are given in @file{test15.sara}.

@cartouche
@smallexample
@verbatiminclude test15.sara
@end smallexample
@end cartouche

Here, @samp{c1} and @samp{c2} are places of the Petri net forming a global constraint @samp{c1+c2>=2}. The places represent
the critical sections of two processes connected via a semaphore. Sara will test if it is possible to
reach either both critical sections simultaneously or -- in case autoconcurrency should be possible --
if a process can reach its critical section more than once at the same time. The first problem statement
is generated by the following call:

@cartouche
@smallexample
sara -r test15.owfn -f"COVER" -c"c1+c2>2"
@end smallexample
@end cartouche

The option @option{-f"COVER"} disregards unmentioned places (i.e. every place) in the final marking while the @option{-c} option
generates the linear constraint. The option @option{-c} can be given more than once (all must be fulfilled) and the constraints 
may be more complex, allowing e.g. @option{-c"3p1+5t1-7t3+p2<9"} where each of the places @samp{p1, p2} represent the number of 
tokens that place should have in the final marking and each of the transitions @samp{t1, t3} represent the number of
occurrences of this transition in the firing sequence generated by Sara for the solution. Coefficients
are just weights, the above line translates to: ``Three times the number of tokens on @samp{p1} plus five times
the number of appearances of @samp{t1} in the firing sequence minus seven times of that of @samp{t3} plus the token number
on @samp{p2} must be less than or equal to nine''.

Besides the reachability check there are some more options that will generate other problem instances.
A check if a Petri net contains any dead transitions can be generated for example by

@cartouche
@smallexample
sara -q garavel.llnet
@end smallexample
@end cartouche

Here, we use a Petri net in the LOLA-format that has been posted by H.Garavel in 2003 as a challenge. It contains
776 transitions to be checked for if they can fire at all or if they are dead. Sara generates a problem
file @file{garavel.llnet.sara} with 776 problem instances, one for each transition.

Also, a check whether a transition multiset is realizable can be generated. The file @file{test14.sara} contains four
such problems:

@cartouche
@smallexample
@verbatiminclude test14.sara
@end smallexample
@end cartouche

Each of these problems can be created by invoking Sara like this (each call creating only one of the problems):

@cartouche
@smallexample
sara -R test14.owfn -f"a1:2,a2:2,a3:2,c1,c2,c3,d1,d2,d3,d4:2,e1,e2,e3,e4:2,x1"
sara -R test14.owfn -f"a1:2,a2:2,a3:2,c1,c2,c3,d1,d2,d3,d4:2,e1,e2,e3,e4:2,x1:2"
sara -R test14.owfn -f"a1,a3,c1,c2,c3,d2,d4,e2,e4,x1"
sara -R test14.owfn -f"d1,e1,a2,d3,e3,x1"
@end smallexample
@end cartouche

Again, writing @samp{:1} or omitting it does not make a difference. No greater-than or less-than signs are allowed, though. 
The option @option{-f}
does not represent a final marking here but a transition multiset; @samp{a1,a2,a3,...} are all transitions of the Petri net.
If Sara is fed with these problems, the tool will search for a firing sequence in which every transition appears
exactly as often as mentioned in the multiset.

One additional line may be added after the last line of any problem:

@cartouche
@smallexample
RESULT [OR] [NEGATE] <string>;
@end smallexample
@end cartouche

Sara will handle the <string> as the name of a property which is fulfilled if all problems
in the problem file appended with this same line have a positive result, i.e. each time a
firing sequence is found. The optional parameter NEGATE inverts this: all problems
containing this line must fail for the property to hold. The parameter OR means that one
positive solution will be sufficient to fulfill the property. Sara will output if the property
holds or not after checking all problems in the file (if the decision can be made early,
Sara will take that shortcut, though). Different properties may be checked
by using different strings in the same problem file. The string must not contain any of
the following special symbols: +-<>:,; or blanks.
 
@section Solving a Problem

After creating a problem, Sara can try to solve it. There are three possible sources for problem instances that
Sara can solve. A problem can be solved directly after its creation. An example for this could be:

@cartouche
@smallexample
sara -q garavel.llnet -p
@end smallexample
@end cartouche

Here, Sara creates the 776 problem instances checking Garavel's net for dead transitions and internally
pipes them (with the option @option{-p}) to its solving unit. The problem file @file{garavel.llnet.sara} is still written.

Problems can also come in from the outside, either by a pipe through stdin or in form of a file.
To read from stdin, the pipe option @option{-p} needs to be specified. Piping
will only work if no problems are created by Sara at the same time.

@cartouche
@smallexample
sara -p
@end smallexample
@end cartouche

To read from a file, there is an option @option{-i} available.

@cartouche
@smallexample
sara -i garavel.llnet.sara
@end smallexample
@end cartouche

@section Getting Output and Interpreting the Result

Sara usually prints all information to stdout and stderr. The stream can be redirected to files using
the options @option{-o} and @option{-l}.

@cartouche
@smallexample
sara -i test5.sara -o test5.out -l test5.log
@end smallexample
@end cartouche

The output to stdout will contain the result of the computation.
Normally, that is just the name of the problem (as defined in the problem instance) and either a solution
or the fact that there is no solution.

@cartouche
@smallexample
@verbatiminclude test5a.txt
@end smallexample
@end cartouche

The second line contains the keyword showing the result of the computation, in the positive case @samp{SOLUTION},
followed by the length of the firing sequence Sara has found and the firing sequence itself, consisting of the
names of the transitions to fire in the correct order, separated by blanks. Sara can be persuaded to continue
searching for solutions after the first one has been found by using the option @option{-C}. The option has
different effects depending on the kind of problem. If we try to reach a marking (like now), other solutions, mostly minimal
ones, are sought. If the problem is to realize a transition vector, Sara tries to realize all componentwise smaller 
vectors whose firing leads to the same final marking.

@cartouche
@smallexample
sara -i test5.sara -C
@end smallexample
@end cartouche

In the above example Sara will try to find all minimal solutions. A solution is minimal if there is no other solution
containing a less or equal number of instances of each transition. In our example, the result will look like this:

@cartouche
@smallexample
@verbatiminclude test5b.txt
@end smallexample
@end cartouche

Sara will print the solutions after the computation has terminated. This may take a long time or the program
may not terminate at all, so use this option at your own risk. To obtain all
solutions just when they are found, Sara can be forced to print
every solution immediately using the option @option{-P}. You may terminate Sara yourself after some solutions
have been produced. You might get non-minimal solutions this way as Sara cannot take back the printing of
a non-minimal solution in the (rare) case a smaller one is found later.

@cartouche
@smallexample
sara -i test5.sara -C -P
@end smallexample
@end cartouche

The search space can be limited (and thus made finite) by providing the option @option{-M} followed
by a number. If this number is smaller than the size of a solution of the linear programming solver
integrated in Sara, the solution will be disregarded. Sara will neither try to transform this
solution into a firing sequence nor will Sara extend this solution. So using the command

@cartouche
@smallexample
sara -i test5.sara -C -M14
@end smallexample
@end cartouche

Sara will find firing sequences of at most length 14 that are solutions to the given problem.
If solutions are found at all, all minimal solutions are computed. Some non-minimal solutions
may be omitted if their Parikh-vector is larger than that of another solution. If there is
no solution up to the given length, Sara will state that the problem remains unsolved.

Additional information about the problem(s) and the result(s) can be provided with the verbose option @option{-v}.
First, the input used by Sara is stated: Petri net file, initial marking, final marking, constraints.
Then, Sara tells how many jobs it has done. Each job encompasses solving one system of linear equations and
trying to find a permutation of the transitions elected by some minimal solution vector forming a firing sequence in
the Petri net. Some jobs lead to solutions, some lead to failures where it is known that no solution vector (including
all non-minimal ones) can yield a firing sequence. Failures may constitute portions of a counterexample in case
the problem is unsolvable.

@cartouche
@smallexample
sara -i test5.sara -C -v
@end smallexample
@smallexample
@verbatiminclude test5c.txt
@end smallexample
@end cartouche

After printing the solutions, Sara shows the maximal and average length of the solutions found. This will also
work if there are many problems defined within one problem file. For Garavel's net, e.g., Sara will determine
the longest solution length found in the 776 problem instances and the (rounded) average length over all 776 solutions.

Sometimes one encounters a problem that has no solution. When analysing the structure of the Petri net, there are
in general two possible reasons for such a failure. First, the linear system known as The Marking Equation does
not have a solution. We cannot reach the final marking then even if we allow for negative token numbers and declare
every transition to be firable at any time. E.g. if each transition takes as many tokens from a Petri net as it produces,
the overall number of tokens in the net can never change. If the initial marking has six tokens and the final marking has seven,
the Marking Equation will be unsolvable. This is simple linear algebra.

The second reason for failure may be that we have a solution of the Marking Equation but cannot realize this solution.
In this case some solution vector may state that firing each transition @math{t_i} exactly some number @math{n_i} times would
lead from the initial to the final marking, but in every sequence containing each transition exactly that often there
is a spot where the next transition to fire just cannot -- due to the firing rule of Petri nets, i.e. too few tokens
on some place before the transition.

If the Marking Equation is unsolvable, Sara will print that the problem is @samp{INFEASIBLE}, giving the Marking
Equation as the reason. Besides that, Sara cannot do much but state how the initial and/or the final marking
could be changed to make it solvable. To make Sara suggest initial and final markings with a minimal difference to 
the ones given in the problem statement, use the option @option{-v}.

@cartouche
@smallexample
sara -i test12.sara -v
@end smallexample
@smallexample
@verbatiminclude test12.txt
@end smallexample
@end cartouche

If the Marking Equation has a solution, the solution might not be realizable. In the following Petri net,
we can reach the final marking @samp{p2:2,q2:2} from the initial marking @samp{p1:1,q1:1} according to the
Marking Equation. We just need to fire each transition once.

@center @image{test4}

Of course, each of the two transitions @samp{t1} and @samp{u1} can fire only after the other one has fired, since @samp{t1} puts
a token on @samp{q2} where @samp{u1} needs it, and @samp{u1} puts a token on @samp{p2} where @samp{t1}
needs it. Also, there is no other way one of the places @samp{p2} or @samp{q2} can get or borrow a token.
Such a borrowing could be done via a so-called T-invariant, a sequence of transitions that will
overall not change the marking of the net but in intermediate steps produce and later consume a token
on either @samp{p2} or @samp{q2}. Since such a sequence does not exist here, Sara will claim that
the problem is infeasible due to not being able to borrow tokens via a T-invariant.
 
@cartouche
@smallexample
sara -i test4.sara -v
@end smallexample
@smallexample
@verbatiminclude test4.txt
@end smallexample
@end cartouche

Additionally, if we specify the verbose option @option{-v}, Sara may try to reason why a solution could not be
found. Sara takes all failures found and constitutes a counterexample from them. Failures are those points where
tokens needed to be borrowed but it was impossible to do so. In our example, Sara finds that just at the beginning
(after the firing sequence @samp{<empty>}) the places @samp{p2} and @samp{q2} are both empty (@samp{p2:0,q2:0}),
but at least one (more) token is needed to fire any of the transitions @samp{t1} or @samp{u1} (which would enable the
other one and later @samp{t2} and @samp{u2}). Normally, some transitions can fire at the initial marking, so
the critical moment comes later and even at different opportunities. The correct interpretation of the results
can then become difficult.

In the following example our Petri net (@file{test9.owfn}) contains a transition @samp{a3} that needs four tokens from 
each of the places @samp{y1} and @samp{y3} and five from @samp{y2}. There are exactly twelve tokens that can be put onto 
the three places in any way we wish. Sara finds three transition sequences where each pair of two of the places have enough 
tokens but the third needs one more. For each sequence Sara finds a set of places where an additional token would let the
Petri net go on on its path to the final marking (@samp{o1} circumventing the firing of @samp{a3} and the others
allowing for it). Furthermore, each time a set of transitions that could be enabled by this additional token is
given. Some of the transitions (@samp{b1,c1,d1,l1,l2,l3}) will later allow @samp{a3} to fire, the others
(@samp{b2,c2,d2}) are for the case when @samp{a3} is circumvented. The fourth failure (after the sequence
@samp{a1 a2 a4}) happens as @samp{a4} will disable the whole Petri net and nothing can be done anymore --
especially bringing tokens to @samp{a3}.

@cartouche
@smallexample
sara -i test9.sara -v
@end smallexample
@smallexample
@verbatiminclude test9.txt
@end smallexample
@end cartouche

@section Optimizations including Non-determinism and Multithreading

Sara runs sequentially unless invoked with the option @option{-T} followed by the
number of additional threads Sara should use. It is advised to use not more than
one thread per core in your system. In general, there are three access
points for multithreading in Sara: multiple problem definitions in one file,
the execution of multiple lp_solve jobs, and a parallelized depth-first search
in trees representing valid firing sequences. The latter two have been implemented
in Sara and there are examples (e.g. test8_1 to test8_9 from the testfiles directory)
where parallelisation tests really well. The multithreading for multiple problem
definitions is not supported at this time, though the user might just start more
than one instance of Sara and feed each of them a portion of the problems.

Sara normally tries to compute its results deterministically so reproduction of results with the
same time consumption is possible. There are some algorithms
that need a total ordering of the transitions and the places of the input Petri net for this determinism
(and also for some optimisations).
Sara will compute these orderings from the structure of the Petri net after it has been loaded. Since
only the structure, but not the names of transitions and places are used, it can happen that a unique
ordering cannot be found (due to a total symmetry of the net). If the option @option{-v} is set, Sara 
will prompt a message to stderr in this case:

@cartouche
@smallexample
sara: place or transition ordering is non-deterministic
@end smallexample
@end cartouche

Sara iterates to find this ordering and will stop after some number of loops, even if a unique total
ordering has not been found. If that happens, the same message is printed.

The user can also make the computation non-deterministic. In the partial order reduction there is
a so-called scapegoat that can be chosen freely from some set of places. Theory shows that the best
option for a low runtime is to make the choice non-deterministically. Sara allows for this by using
the option @option{-S}:

@cartouche
@smallexample
./sara -i test7.sara -S
@end smallexample
@end cartouche

The runtime of Sara will now be different at each invocation, even if all input is identical.


Sara also offers some options that deal with the place/time tradeoff. Without any options, Sara
assumes that memory is not an issue. Since the reachability problem is EXPSPACE-hard, there
will be instances where memory is a big problem and we cannot do anything about it. Sara stores
not only information about future jobs but also about past ones. When the past becomes bigger
than the future (difficult to tell if and when this will happen), it is possible to constrain
that part of the memory dedicated to the past.

@cartouche
@smallexample
./sara ... -Dm -Ln
@end smallexample
@end cartouche

The option @option{-D} followed by a number (try 10 or 20 at first) will limit the jobs that are remembered
after Sara is through with them. If a remembered job comes up again later (this can easily happen), Sara
knows that it has already been done. The lower the number, the less jobs are remembered (though the
number does not represent the size of the memory reserved but more something like a distance from
the job Sara works on at the moment).

The option @option{-L} limits the number of solutions of linear systems Sara stores. If a stored
solution is encountered again, Sara does not need to go through any permutations of transition
sequences to check if the solution can be realized. As a starting limit try 100 or 1000. 

Sara will put a message to stderr if the limit for one of the above options is reached.

There are other options that influence what Sara does, like @option{-J}, @option{-W}, or
@option{--treemaxjob}. These are experimental at best, use them at your own risk. The option @option{-J}
induces a different ordering of the jobs which may result in a better or worse performance;
@option{-W} will allow to print the failures even if a solution was found; @option{--treemaxjob}
limits the number of new jobs a single job may generate, effectively chopping off parts
of the computation. At last, two debugging options need to be mentioned. The option @option{-b}
stops the computation after a given number of jobs has been done (@option{-b0} not stopping
the computation) and prints all the job lists from past, present, and future. The option
@option{-d} sets a debugging info level from zero to three where a higher level means more
detailed information is printed to stderr. Zero is the default value and deselects the
additional debugging output. 

@section Additional Utilities

Additional utilities can be found in the utils directory. At this time there are
three of them: owfn2sara, form2sara, and lola2sara. Owfn2sara takes a list of Petri net files from stdin,
computes a final marking for each net (containing each place with an empty postset)
and creates a list of problem instances, at least one for each net, which are written to stdout. 
This list can be piped to the main tool Sara to check if certain properties hold.

The following options/properties are available:

@cartouche
@smallexample
owfn2sara -q ... Quasiliveness: checks if each transition can be enabled.
owfn2sara -p ... Proper Completion: check fails if the final marking can be truly covered.
owfn2sara -l ... Lazy Soundness: checks if the places of the final marking can be marked 
simultaneously.
owfn2sara -r ... Relaxed Soundness: checks if each transition can be fired and in each case
then the final marking is reachable.
@end smallexample
@end cartouche

All options can be combined to check for all properties at once.

The tool form2sara was written for a model checking contest and can create Sara problem
files from a Petri net and a formula specifying the final marking given in the contest's
syntax.

The tool lola2sara translates a LoLA task file (containing a formula) to a Sara problem
file. At the moment, only standard propositional formulae over weighted sums of places
and transitions can be translated. As boolean operators NOT, AND, OR, XOR, ->, and <->
are allowed. The tool has to be called with the name of the Petri net file (which will
not be opened by the tool) and the name of the formula file. The type of the Petri net
can (and should) be declared by one of the options @option{--lola}, @option{--owfn},
or @option{--pnml}.

@cartouche
@smallexample
lola2sara -n <net file> -f <formula file>
@end smallexample
@end cartouche

The tool lola2sara will print its output to stdout from where it can be piped either
to a .sara-file or directly to Sara (using the option @option{-p}).

@section Using Sara as a library

To build a library from Sara, make a copy of the @file{src} directory to where the library
should be created and rename the directory to anything you like.
Then you will need to change the makefile (former @file{src/Makefile.am}) in the standard way
(e.g. replacing @samp{bin_PROGRAMS = sara} by @samp{noinst_LIBRARIES = sara} etc.).
Additionally, you have to call the compiler with the label @samp{SARALIB}
defined (usually done with the @option{-D} option). Also, make sure that @samp{lp_solve}
is linked with your program and its header file @samp{lp_lib.h} is included at the point where
Sara needs to be called. You might just use the @samp{lp_solve} version in the @file{libs} directory
of Sara. Make sure Sara can also access @samp{lp_solve/lp_lib.h} by setting the correct include path.

At the moment, Sara's API only provides the following entries which can be included from the file @file{sara_lib.h}:

@cartouche
@smallexample
vector<Transition*> sara::ReachabilityTest(PetriNet& pn, Marking& m0, Marking& mf, 
                                           map<Place*,int>& cover);
vector<Transition*> sara::RealizabilityTest(PetriNet& pn, Marking& m0, 
                                            map<Transition*,int>& parikh);
void sara::setVerbose();
@end smallexample
@end cartouche

A call to the first function will solve one instance of the reachability problem for a given Petri net @samp{pn},
initial marking @samp{m0}, and final marking @samp{mf}. The additional @samp{cover} contains the information
for which places the token number of the final marking has to be reached exactly, may be covered, or should
be an upper bound. If a place @samp{p} should have at least as many tokens as mentioned in the final marking,
set @samp{cover[p]=GE}, if it should have at most that many tokens, set @samp{cover[p]=LE}, for equality
@samp{cover[p]=EQ} can (but need not) be set. The constants @samp{LE}, @samp{EQ}, and @samp{GE}
are defined within the @samp{lp_solve} library, so if something else than exact equality is desired,
the header file @samp{lp_lib.h} needs to be included.

The second function solves a realizability problem, i.e. checks if there is a firing sequence with the Parikh
image @samp{parikh} firable at the marking @samp{m0} of the Petri net @samp{pn}. The syntax allows for negative
entries in the Parikh vector, but they do not make any sense.

The result of a call to one of the two functions will be a vector of (pointers to) transitions (the @acronym{PNAPI}
is needed for all Petri net related stuff). The vector either represents a firing sequence solving the given
problem, i.e. it leads from @samp{m0} to @samp{mf} or has the Parikh vector @samp{parikh} and is firable at @samp{m0}, 
or it contains a single NULL pointer (when no solution exists), or it contains a sequence of two NULL pointers 
(when Sara could not find a conclusive result). Sara does not guarantee termination (but usually will terminate).

@c --------------------------------------------------------------------------


@node Theory
@chapter Theory

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
Sara implements several algorithms and result published in several scientific articles.
Sara tries to solve the general reachability problem, known to be EXPSPACE-hard, with
an acceptable runtime for as many problem instances as possible.

@section Decidability of Reachability in General

The Reachability problem is known to be decidable since the early 1980's,
which was shown independently by two researchers.

@quotation
E. Mayr. @b{An Algorithm for the General Petri Net Reachability Problem}. @i{SIAM Journal of Computing} @b{13}:3, pp.441--460, 1984.
@end quotation

@quotation
S.R. Kosaraju. @b{Decidability of Reachability in Vector Addition Systems}. @i{Proceedings of the 14th Annual ACM STOC}, pp.267--281, 1982. 
@end quotation

Later, a different (possibly better) presentation of the topic was given.

@quotation
J.L. Lambert. @b{A Structure to Decide Reachability in Petri Nets}. @i{Theoretical Computer Science} @b{99}, pp.79--104, 1992.
@end quotation

For those firm in the German language, a version with additional explanation and a running example can also be found in the book

@quotation
H.Wimmel. @b{Entscheidbarkeit bei Petri Netzen}. Springer, ISBN 978-3-540-85470-8, 2008.
@end quotation


@section Sara's Algorithm

Sara solves the reachability problem by first solving (a possibly extended version of)
the Marking Equation and then trying to transform a solution vector (if found) into
a firing sequence. The following paper describes in more detail how Sara works:

@quotation
H. Wimmel, K. Wolf. @b{Applying CEGAR to the Petri Net State Equation}. @i{Proceedings of TACAS 2010}, Lecture Notes in Computer Science @b{6605}, pp.224--238, Springer, 2011.
@end quotation

There also are publications about the tools and
general methods used by Sara. 

@subsubheading Solving the Marking Equation

Since the Marking Equation is just a linear system of equations over integers with
results in the non-negative integers, a simple integer programming tool can solve it.
General information on linear and integer programming can be found in:

@quotation
A. Schrijver. @b{Theory of Linear and Integer Programming}. Wiley, ISBN 978-0-471-98232-6, 1998.
@end quotation

Sara, in specific, uses the lp_solve library, for which a documentation can be found online.

@quotation
M. Berkelaar, K. Eikland, P. Notebaert. @b{Lp_solve Reference Guide}. http://lpsolve.sourceforge.net/5.5/ (30.6.2010).
@end quotation

@subsubheading Transforming a Solution Vector into a Firing Sequence 

To find an ordering of the transitions given by a solution vector so that a firing sequence is generated
can in principle be done by brute force. This leads to the state space explosion problem that has
been dealt with in- and extensively in the literature. Sara uses methods of partial order reduction
to counter the state space explosion, especially the stubborn set method.

@quotation
D.A. Peled. @b{All from One, One for All: Model Checking Using Representatives}. @i{Proceedings of CAV'93}, Lecture Notes in Computer Science @b{697}, pp.409--423, Springer, 1993.
@end quotation

@quotation
P. Godefroid. @b{Partial-Order Methods for the Verification of Concurrent Systems - An Approach to the State-Explosion Problem}. Lecture Notes in Computer Science @b{1032}, Springer, 1996.
@end quotation

@quotation
L.M. Kristensen, K. Schmidt, A. Valmari. @b{Question-guided Stubborn Set Methods for State Properties}. @i{Formal Methods in System Design} @b{29}:3, pp.215--251, Springer, 2006.
@end quotation

@sp 3

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
See @url{http://service-technology.org/publications} for more information.


@c --------------------------------------------------------------------------


@node Exit and Error Codes
@chapter Exit and Error Codes
@section Exit Codes

Sara will exit with code @samp{0} in case everything went fine. 
That is, the command-line parameters were valid, the input file(s) could be read,
and Sara terminated with some result, but did not abort the computation.
It does not matter if the result was positive (a solution was found) or
negative (the marking equation is infeasible or no transition vector could be
realized).

In case any error occurs, the exit code will be @samp{1} and an error message with an error code (see below) will be printed to the standard error stream.

@section Error Codes

In case any error occurs, Sara aborts with exit code @samp{1} and prints a message with an error code to the standard error stream.

@table @asis

@c <<-- CHANGE START (exit/error codes) -->>

@item #01
The file or pipe containing the information about the problem that Sara should solve could not be read. 
Either the file does not exist or read access was not allowed.

@smallexample
@cartouche
sara: could not read problem information -- aborting [#01]
@end cartouche
@end smallexample

@item #02
The problem information contains the filename of a Petri net that must be loaded to solve the problem.
The file corresponding to this filename either does not exist or read access was not granted.

@smallexample
@cartouche
sara: could not read from Petri net file '[filename]' -- aborting [#02]
@end cartouche
@end smallexample

@item #03
The file system did not allow to create a file and write to it. Typically, the user tried to
make Sara create a problem information file and did not get write access, either to
the directory or the file itself.

@smallexample
@cartouche
sara: could not write to file '[filename]' -- aborting [#03]
@end cartouche
@end smallexample

@item #04
A syntax error occurred while parsing a Petri net file. Either the file itself contains a syntax
error or Sara was directed to the wrong parser. Check if the problem file contains the correct
type (LOLA, OWFN, or PNML) or, when the creation of a problem file goes wrong, if the command line option
for the correct Petri net type was used (@option{--owfn}, @option{--lola}, or @option{--pnml}).

@smallexample
@cartouche
sara: error while reading Petri net from file -- aborting [#04]
@end cartouche
@end smallexample

@item #05
A syntax error occurred while parsing a problem file. Check that file.

@smallexample
@cartouche
sara: error while parsing the sara problem file -- aborting [#05]
@end cartouche
@end smallexample

@item #06
Permission to write a .dot file to disk was denied. Check permissions.

@smallexample
@cartouche
sara: error while writing Petri net to file '[filename]' -- aborting [#06]
@end cartouche
@end smallexample

@item #11
Internal error. A set of places was empty where it should not be. This is a bug and should never occur.

@smallexample
@cartouche
sara: no scapegoat for stubborn set method -- aborting [#11]
@end cartouche
@end smallexample

@item #12
Internal error. The Integer Programming tool lp_solve was unable to create the data structures
for solving the marking equation of a Petri net. This can be a bug or a problem
instance is too large and will not fit into the memory.

@smallexample
@cartouche
sara: could not create LP model -- aborting [#12]
@end cartouche
@end smallexample

@item #13
Internal error of lp_solve. This can be a bug of lp_solve or can happen due to
insufficient memory.

@smallexample
@cartouche
sara: failed to add constraint to LP model -- aborting [#13]
@end cartouche
@end smallexample

@item #14
Internal error. Sara generated solutions to a problem, but for some reason the
solutions were not stored. This is a bug and should never occur.

@smallexample
@cartouche
sara: solved, but no solution found -- aborting [#14]
@end cartouche
@end smallexample

@item #31
One of the utilities form2sara, lola2sara, or owfn2sara could not parse the file containing the formula.

@smallexample
@cartouche
sara: error while parsing the formula file -- aborting [#31]
@end cartouche
@end smallexample

@item #32
One of the utilities form2sara, lola2sara, or owfn2sara could not access the file containing the formula.

@smallexample
@cartouche
sara: could not read formula file -- aborting [#32]
@end cartouche
@end smallexample

@c <<-- CHANGE END -->>

@end table


@c --------------------------------------------------------------------------


@node ChangeLog
@chapter Version History

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
Sara is developed under the ``Release Early, Release Often'' maxime (see @url{http://catb.org/~esr/writings/cathedral-bazaar/cathedral-bazaar/ar01s04.html}): Whenever enough integrated or a non-trivial changes have summed up, a new version is published. Though this releases might now always mark significant changes, they at least allow to quickly fix bugs and avoid infinite procrastination.

@include ChangeLog.texi
@sp 3

@c !!! DO NOT CHANGE THE NEXT LINE -- IT IS USED AS A FILTER IN SCRIPTS !!!
The most recent change log is available at Sara's website at @url{http://service-technology.org/files/hello/ChangeLog}.


@c --------------------------------------------------------------------------

@node GNU Free Documentation License
@appendix The GNU Free Documentation License

@include fdl.texi

@bye
