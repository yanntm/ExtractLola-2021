/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_UNPARSE

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-unpk.h"


namespace kc {
base_uview_class base_uview;
out_class out;
relabelformula_class relabelformula;
checkcons_class checkcons;
checkstableatomic_class checkstableatomic;
foldformula_class foldformula;
createskeleton_class createskeleton;
hlunfold_class hlunfold;
reduction_class reduction;
markvisible_class markvisible;
markslicingef_class markslicingef;
markslicingag_class markslicingag;
structural_class structural;
containstemp_class containstemp;
count_class count;
elem_class elem;
temporal_class temporal;
internal_class internal;
buechi_class buechi;
ctl_class ctl;
ltl_class ltl;
hl_staticanalysis_class hl_staticanalysis;
visible_class visible;
copy_class copy;

impl_uviews uviews[] = {
    {"base_uview",&base_uview},
    {"out",&out},
    {"relabelformula",&relabelformula},
    {"checkcons",&checkcons},
    {"checkstableatomic",&checkstableatomic},
    {"foldformula",&foldformula},
    {"createskeleton",&createskeleton},
    {"hlunfold",&hlunfold},
    {"reduction",&reduction},
    {"markvisible",&markvisible},
    {"markslicingef",&markslicingef},
    {"markslicingag",&markslicingag},
    {"structural",&structural},
    {"containstemp",&containstemp},
    {"count",&count},
    {"elem",&elem},
    {"temporal",&temporal},
    {"internal",&internal},
    {"buechi",&buechi},
    {"ctl",&ctl},
    {"ltl",&ltl},
    {"hl_staticanalysis",&hl_staticanalysis},
    {"visible",&visible},
    {"copy",&copy},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_unparse.k"
// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output on stdout

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to print

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
*/
void myprinter(const char *s, kc::uview)
{
    printf("%s", s);
}
// LCOV_EXCL_STOP

/// result string for stringprinter
std::string unparsed;

// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output to a string object

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to add

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
\post Output is written to string unparsed which can be accessed wherever an
unparser can be used. You need to clear the string after use to avoid keeping
old data.
*/
void stringprinter(const char *s, kc::uview)
{
    unparsed += s;
}
// LCOV_EXCL_STOP


#line  121 "ast-system-unpk.cc"
#line 1828 "Frontend/Parser/formula_unparse.k"
#include <config.h>
#include <Core/Dimensions.h>
#include <Net/Petrinet.h>
#include <Formula/StatePredicate/AtomicStatePredicate.h>
#include <Formula/StatePredicate/AtomicBooleanPredicate.h>
#include <Formula/StatePredicate/FalsePredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/TruePredicate.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<StatePredicate *> > formulas;

// invariant: top is always my parent
std::stack<size_t> id_stack;

// next free id
size_t nextId = 0;

#line  148 "ast-system-unpk.cc"
#line 1996 "Frontend/Parser/formula_unparse.k"
#include<Net/Petrinet.h>
std::map<int, std::vector<std::pair<int,int> > > transitions ;
std::set<int> acceptingset;
std::map<int, StatePredicate*> predicates;
std::map<int, int> states_to_interal;

int get_state_number(int state){
    if (states_to_interal.find(state) == states_to_interal.end()){
	// get a new state number
	int new_state_number = states_to_interal.size();
	states_to_interal[state] = new_state_number;
	return new_state_number;
    }
    return states_to_interal[state];
}

#line  166 "ast-system-unpk.cc"
#line 2101 "Frontend/Parser/formula_unparse.k"

#include <Core/Dimensions.h>
#include <Frontend/Parser/ParserPTNet.h>
#include <Exploration/StatePredicateProperty.h>
#include <Formula/CTL/AUFormula.h>
#include <Formula/CTL/ARFormula.h>
#include <Formula/CTL/AGFormula.h>
#include <Formula/CTL/AFFormula.h>
#include <Formula/CTL/AXFormula.h>
#include <Formula/CTL/AtomicFormula.h>
#include <Formula/CTL/CTLFormula.h>
#include <Formula/CTL/ConjunctionFormula.h>
#include <Formula/CTL/DisjunctionFormula.h>
#include <Formula/CTL/EUFormula.h>
#include <Formula/CTL/ERFormula.h>
#include <Formula/CTL/EFFormula.h>
#include <Formula/CTL/EGFormula.h>
#include <Formula/CTL/EXFormula.h>
#include <Formula/CTL/NotFormula.h>
#include <Net/Petrinet.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> ctl_current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<CTLFormula_p> > ctl_formulas;

// invariant: top is always my parent
std::stack<size_t> ctl_id_stack;

// next free id
size_t ctl_nextId = 0;

// needs dfs-storage;
size_t ctl_dfs_id = 0;

// needs cached results id
size_t ctl_result_cache_id = 0;

// temporal storage to be able to include the LessEqualStatePredicate into an AtomicFormula
StatePredicateProperty* spp;

#line  214 "ast-system-unpk.cc"
#line 2438 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>

extern int current_next_string_index_number;
std::vector<LTLTree_p> ltlstack;

#line  223 "ast-system-unpk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void
impl_abstract_phylum::unparse(printer_function opf, uview uv)
{
    printer_functor_function_wrapper pf(opf);
    do_unparse(pf, uv);
}

// Everything given as a pointer is expected to have an unparse-method (we
// believe it's a phylum), unless there's a specialisation for it

void
unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)
{
    kc_p->unparse(kc_printer, kc_current_view);
}

void
unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view)
{
    // MPi: 20020628 there shouldn't be any left
    assertionFailed("Unparse called for untyped pointer");
    // MPi: cast should be unnecessary, but there are still void*
    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);
}

void
unparse(int kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_integer(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(double kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_real(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(kc_char_t *kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v, kc_current_view);
}

void
unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v.c_str(), kc_current_view);
}

#line  286 "ast-system-unpk.cc"
void
impl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)
{
    register int no_sons = operator_info[prod_sel()].no_sons;
    for (int i=0; i < no_sons; i++)
    subphylum(i)->unparse(kc_printer, kc_current_view);
}

void
impl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_real__Real::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(pointer, kc_printer, kc_current_view);
}


#line  326 "ast-system-unpk.cc"
void
impl_tFormula_CompBound::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3146 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 3146 "Frontend/Parser/formula_unparse.k"
		c -> formula = c -> formula -> copy(NULL);
#line  338 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 974 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 975 "Frontend/Parser/formula_unparse.k"

		f -> type = FORMULA_BOUND; 
		f -> cannotcompute = false;
		f -> cardcompound = 1;

#line  353 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 931 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 889 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 889 "Frontend/Parser/formula_unparse.k"
		fs=c->formula->count(fs);fs->comp--;
#line  372 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 850 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true; containsNext = false;
#line  381 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("MAX(*)"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 732 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 732 "Frontend/Parser/formula_unparse.k"
		((AtomicStatePredicate *)(c->formula))->markslicing(true);
#line  399 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 669 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 669 "Frontend/Parser/formula_unparse.k"
		((AtomicStatePredicate *)(c->formula))->markslicing(false);
#line  410 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 606 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 606 "Frontend/Parser/formula_unparse.k"
		((AtomicStatePredicate *)(c->formula))->markvisible();
#line  421 "ast-system-unpk.cc"
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 529 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 529 "Frontend/Parser/formula_unparse.k"
		containsNext = containsDeadlock = false;
#line  432 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 464 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 464 "Frontend/Parser/formula_unparse.k"
		c -> formula = ((AtomicStatePredicate *)(c->formula))->hlunfold();
#line  443 "ast-system-unpk.cc"
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 389 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 389 "Frontend/Parser/formula_unparse.k"

		((AtomicStatePredicate *)(c->formula))->createskeletonatomic(Create_HL_Net::current);

#line  456 "ast-system-unpk.cc"
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 342 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 342 "Frontend/Parser/formula_unparse.k"
		c->formula = ((AtomicStatePredicate *)(c->formula))->foldformula(Create_HL_Net::current);
#line  467 "ast-system-unpk.cc"
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 277 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 214 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 214 "Frontend/Parser/formula_unparse.k"
		((AtomicStatePredicate *)(c->formula))->checkCons();
#line  486 "ast-system-unpk.cc"
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 151 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
#line 151 "Frontend/Parser/formula_unparse.k"
		((AtomicStatePredicate *)(c->formula))->relabel();
#line  497 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 83 "Frontend/Parser/formula_unparse.k"
		const tFormula c = this/**/;
		{ kc_printer(kc_t("MAX("), kc_current_view); }
#line 83 "Frontend/Parser/formula_unparse.k"
		kc_printer(((AtomicStatePredicate *)(c->formula))->toCompString(),kc_current_view);
#line  509 "ast-system-unpk.cc"
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  515 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  527 "ast-system-unpk.cc"
void
impl_tFormula_StatePredicateFormula::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3145 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2447 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 2447 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2448 "Frontend/Parser/formula_unparse.k"

		ltlstack.clear();
		current_next_string_index_number = 1;

#line  553 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2453 "Frontend/Parser/formula_unparse.k"


		f->ltl_tree = bin_simpler(push_negation(tl_nn(NOT, ltlstack.back(), NULL)));


#line  561 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2185 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 2185 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2185 "Frontend/Parser/formula_unparse.k"

		ctl_current.clear();
		ctl_formulas.clear();
		while(ctl_id_stack.size()) ctl_id_stack.pop();
		ctl_nextId = 0;
		ctl_dfs_id = 0;
		ctl_result_cache_id = 0;

		f->unparse(myprinter, kc::containstemp);

		ctl_id_stack.push(ctl_nextId++);

#line  585 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2198 "Frontend/Parser/formula_unparse.k"

		ctl_nextId = ctl_id_stack.top();
		ctl_id_stack.pop();


		assert(ctl_nextId == 0);
		f->ctl_formula = ctl_formulas[0][0];
		f->ctl_formula->payloadsize = ctl_dfs_id*SIZEOF_STATENUMBER_T + (2*ctl_result_cache_id+7)/8;

#line  597 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1854 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 1854 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1854 "Frontend/Parser/formula_unparse.k"


		current.clear();
		formulas.clear();
		while (not id_stack.empty())
		id_stack.pop();
		nextId = 0;
		id_stack.push(nextId++);

#line  618 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 1864 "Frontend/Parser/formula_unparse.k"

		nextId = id_stack.top();
		id_stack.pop();

		assert(nextId == 0);
		assert(formulas[0].size() == 1);
		f->formula = formulas[0][0];

#line  629 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1011, this))) {
#line 1011 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1012 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AGEFAG;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  650 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((! phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1024, this))) {
#line 1024 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1025 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EFAGEF;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  667 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((! phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1037, this))) {
#line 1037 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1038 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EFAG;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  684 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((! phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1050, this))) {
#line 1050 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1051 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_LIVENESS;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  701 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1089, this))) {
#line 1089 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1090 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AFAG;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  718 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1102, this))) {
#line 1102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1103 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AGAF;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  735 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((! phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1115, this))) {
#line 1115 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1116 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EGEF;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  752 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1128, this))) {
#line 1128 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1129 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EFEG;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  769 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1141, this))) {
#line 1141 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this->tStatePredicate_1;
#line 1141 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate g = phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1;
#line 1141 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1141 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate i = phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1141 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1142 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EXEF;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  794 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((! phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1154, this))) {
#line 1154 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1155 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EXEG;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  811 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1167, this))) {
#line 1167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1168 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EXEU;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  831 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1180, this))) {
#line 1180 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1180 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1181 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EXER;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  851 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1193, this))) {
#line 1193 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1194 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AXAG;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = true;
		cardcompound = 1;

#line  868 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1206, this))) {
#line 1206 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1207 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AXAF;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  885 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1219, this))) {
#line 1219 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1219 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1220 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AXAR;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  905 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1232, this))) {
#line 1232 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1232 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1233 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_AXAU;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  925 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 988 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_DEADLOCK;
		cannotcompute = false;

		containsExistential = true;
		containsDeadlock = true;
		finitepath = true;
		cardcompound = 1;

#line  938 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 1000 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_NODEADLOCK;
		cannotcompute = false;

		containsUniversal = true;
		containsDeadlock = true;
		finitepath = true;
		cardcompound = 1;

#line  951 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1063, this))) {
#line 1063 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1064 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_REACHABLE;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  968 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1076, this))) {
#line 1076 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1077 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_INVARIANT;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable;
		containsUnfireable = y -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  985 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1245, this))) {
#line 1245 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1246 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EG;
		cannotcompute = false;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  1002 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1258, this))) {
#line 1258 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1259 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EVENTUALLY;
		cannotcompute = false;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  1019 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1271, this))) {
#line 1271 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1272 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_FAIRNESS;
		cannotcompute = false;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  1034 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1282, this))) {
#line 1282 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1283 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_STABILIZATION;
		cannotcompute = false;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  1049 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1341, this))) {
#line 1341 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1341 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1342 "Frontend/Parser/formula_unparse.k"

		cannotcompute = false;
		type = FORMULA_EU;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  1069 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1354, this))) {
#line 1354 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1354 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1355 "Frontend/Parser/formula_unparse.k"

		cannotcompute = false;
		type = FORMULA_ER;
		containsExistential = true;
		containsUniversal = false;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  1089 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1367, this))) {
#line 1367 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1367 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1368 "Frontend/Parser/formula_unparse.k"

		cannotcompute = false;
		type = FORMULA_AU;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable || x -> containsUnfireable;
		finitepath = false;
		cardcompound = 1;

#line  1109 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (!phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_unparse.k", 1380, this))) {
#line 1380 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 1380 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1381 "Frontend/Parser/formula_unparse.k"

		cannotcompute = false;
		type = FORMULA_AR;
		containsExistential = false;
		containsUniversal = true;
		containsFireable = y -> containsFireable || x -> containsFireable;
		containsUnfireable = y -> containsUnfireable ||x -> containsUnfireable;
		finitepath = true;
		cardcompound = 1;

#line  1129 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(this->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation)) {
#line 1304 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition y = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(this->tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1305 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_INITIAL;
		cannotcompute=false;
		if(y -> pred)
		{
		    containsFireable = y -> pred -> containsUnfireable() ;
		    containsUnfireable = y ->pred -> containsFireable() ;
		}	
		else
		{
		    containsFireable = false ;
		    containsUnfireable = false ;
		}
		finitepath = true;
		cardcompound = 1;

#line  1152 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((!phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 1293, this))) {
#line 1293 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1294 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_EVENTUALLY;
		cannotcompute = false;
		containsFireable = y -> containsFireable ;
		containsUnfireable = y -> containsUnfireable ;
		finitepath = false;
		cardcompound = 1;

#line  1167 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AtomicProposition)) {
#line 1322 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition y = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(this->tStatePredicate_1)->tAtomicProposition_1;
		kc::unparse(y, kc_printer, kc_current_view);
#line 1323 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_INITIAL;
		cannotcompute=false;
		if(y -> pred)
		{
		    containsFireable = y -> pred -> containsFireable() ;
		    containsUnfireable = y ->pred -> containsUnfireable() ;
		}	
		else
		{
		    containsFireable = false ;
		    containsUnfireable = false ;
		}
		finitepath = true;
		cardcompound = 1;

#line  1190 "ast-system-unpk.cc"
	    } else
		if ((this->tStatePredicate_1->prod_sel() == sel_AllPath)) {
#line 1396 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this->tStatePredicate_1;
#line 1396 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(this->tStatePredicate_1)->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1398 "Frontend/Parser/formula_unparse.k"

		cannotcompute = x -> cannotcompute || ((! x -> validLTLFormula) && (! x -> validCTLPathFormula));
		cardcompound = 1;
		if(x->validLTLFormula)
		{
		    if(x->validCTLPathFormula)
		    {
			type = FORMULA_BOTH;
			f->validLTLFormula = true;
			f->validCTLStateFormula = true;
			f->singlepathex = false;
			f->singlepathall = x -> singlepathall;
		    }
		    else
		    {
			type = FORMULA_LTL;
			f->validLTLFormula = true;
			f->validCTLStateFormula = false;
		    }
		}
		else
		{
		    if(x->validCTLPathFormula)
		    {
			type = FORMULA_CTL;
			f->validLTLFormula = false;
			f->validCTLStateFormula = true;
			f->singlepathex = false;
			f->singlepathall = x -> singlepathall;
			if(f->singlepathall) type = FORMULA_SINGLEPATHALL;
		    }
		    else
		    {
			type = FORMULA_MODELCHECKING;
			f->validLTLFormula = false;
			f->validCTLStateFormula = false;
		    }
		}

		containsUniversal = true;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x -> finitepathall;
		finitepathall = false;
		finitepathex = false;

#line  1246 "ast-system-unpk.cc"
	    } else
	    {
#line 1446 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1448 "Frontend/Parser/formula_unparse.k"

		cannotcompute = x -> cannotcompute;
		cardcompound = 1;
		if(x->validLTLFormula)
		{
		    if(x->validCTLStateFormula)
		    {
			type = FORMULA_BOTH;
		    }
		    else
		    {
			type = FORMULA_LTL;
		    }
		}
		else
		{
		    if(x->validCTLStateFormula)
		    {
			type = FORMULA_CTL;
			if(x->singlepathall) type = FORMULA_SINGLEPATHALL;
			else if(x->singlepathex) type = FORMULA_SINGLEPATHEX;
		    }
		    else
		    {
			type = FORMULA_MODELCHECKING;
		    }
		}
		if(x->type == FORMULA_INITIAL) type = FORMULA_INITIAL;
		if(x->type == FORMULA_CONJUNCTION) type = FORMULA_CONJUNCTION;
		if(x->type == FORMULA_DISJUNCTION && x -> validCTLStateFormula) type = FORMULA_DISJUNCTION;
		containsUniversal = x-> containsUniversal;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x -> finitepath;


#line  1290 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 930 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 888 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 888 "Frontend/Parser/formula_unparse.k"
		x->fs = fs;
#line  1310 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 888 "Frontend/Parser/formula_unparse.k"
		fs = x->fs;
#line  1314 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 844 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 844 "Frontend/Parser/formula_unparse.k"
		x->toplevel = true;
#line  1325 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 844 "Frontend/Parser/formula_unparse.k"
		containsNext = x->containsNext; containsTemporal = x -> containsTemporal;
#line  1329 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 794 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 731 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 668 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 605 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 528 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 528 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock; containsNext = x -> containsNext; 
#line  1377 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 463 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 388 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 341 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 276 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 213 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 150 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 82 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  1445 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1458 "ast-system-unpk.cc"
void
impl_tStatePredicate_DisjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3178 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1931 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 1931 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  1481 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 1935 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		AtomicBooleanPredicate *f = new AtomicBooleanPredicate(Petrinet::InitialNet,false);

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    f->addSub(formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  1499 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 964 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 919 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 919 "Frontend/Parser/formula_unparse.k"
		l->fs=fs;
#line  1519 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 919 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;fs->tdisj++;
#line  1523 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 831 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 765 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 702 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 639 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 574 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 574 "Frontend/Parser/formula_unparse.k"
		containsNext = l->containsNext; containsDeadlock=l->containsDeadlock;
#line  1573 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 497 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 432 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 375 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 311 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 246 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 183 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 119 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1643 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1656 "ast-system-unpk.cc"
void
impl_tStatePredicate_ConjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3174 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1892 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 1892 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  1679 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 1896 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		AtomicBooleanPredicate *f = new AtomicBooleanPredicate(Petrinet::InitialNet,true);

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    f->addSub(formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  1697 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 960 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 915 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 915 "Frontend/Parser/formula_unparse.k"
		l->fs=fs;
#line  1717 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 915 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;fs->tconj++;
#line  1721 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 827 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 761 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 698 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 635 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 569 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
#line 569 "Frontend/Parser/formula_unparse.k"
		containsNext = l->containsNext; containsDeadlock=l->containsDeadlock;
#line  1771 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 493 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 428 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 371 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 307 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 242 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 179 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 115 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1841 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1854 "ast-system-unpk.cc"
void
impl_tStatePredicate_EX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2344 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2344 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  1877 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2348 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EXFormula* exf = new EXFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		exf -> containsNext = true;

		ctl_formulas[ctl_id_stack.top()].push_back(exf);

#line  1891 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 956 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 911 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 911 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  1911 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 911 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->X++;
#line  1915 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 871 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 872 "Frontend/Parser/formula_unparse.k"
		x->toplevel = false;
#line  1926 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 872 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = true;
		onlyNext = x -> onlyNext;
#line  1932 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 823 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 757 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 694 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 565 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 565 "Frontend/Parser/formula_unparse.k"
		containsNext = true; containsDeadlock = x -> containsDeadlock;
#line  1982 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 489 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 424 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 367 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 303 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 175 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 111 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2052 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2065 "ast-system-unpk.cc"
void
impl_tStatePredicate_AX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3169 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2256 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2256 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2088 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2260 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AXFormula* axf = new AXFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		axf -> containsNext = true;

		ctl_formulas[ctl_id_stack.top()].push_back(axf);

#line  2102 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 955 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 910 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 910 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2122 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 910 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->X++;
#line  2126 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 870 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 872 "Frontend/Parser/formula_unparse.k"
		x->toplevel = false;
#line  2137 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 872 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = true;
		onlyNext = x -> onlyNext;
#line  2143 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 822 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 756 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 693 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 630 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 564 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 564 "Frontend/Parser/formula_unparse.k"
		containsNext = true; containsDeadlock = x -> containsDeadlock;
#line  2193 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 488 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 423 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 366 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 302 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 237 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 174 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 110 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2263 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2276 "ast-system-unpk.cc"
void
impl_tStatePredicate_EG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3172 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2360 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2360 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2299 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2364 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EGFormula* egf = new EGFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		egf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(egf);

#line  2313 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 958 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 913 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 913 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2333 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 913 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->G++;
#line  2337 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 865 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  2348 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  2354 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 825 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 759 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 696 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 633 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 567 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 567 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  2404 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 491 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 426 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 369 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 305 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 240 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 177 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 113 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2474 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2487 "ast-system-unpk.cc"
void
impl_tStatePredicate_AG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3168 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2288 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2288 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2510 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2292 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AGFormula* agf = new AGFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		agf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(agf);

#line  2524 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 954 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 909 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 909 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2544 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 909 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->G++;
#line  2548 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 863 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  2559 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  2565 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 821 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 755 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 692 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 629 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 563 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 563 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  2615 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 487 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 422 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 365 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 301 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 236 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 173 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 109 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2685 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2698 "ast-system-unpk.cc"
void
impl_tStatePredicate_EF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3171 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2376 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2721 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2380 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EFFormula* eff = new EFFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		eff -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(eff);

#line  2735 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 957 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 912 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 912 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2755 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 912 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;fs->F++;
#line  2759 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 864 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  2770 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  2776 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 824 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 758 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 695 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 632 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 566 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 566 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  2826 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 490 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 425 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 368 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 304 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 239 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 176 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 112 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2896 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2909 "ast-system-unpk.cc"
void
impl_tStatePredicate_AF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2272 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2272 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2932 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 2276 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AFFormula* aff = new AFFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		aff -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(aff);

#line  2946 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 953 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 908 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 908 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  2966 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 908 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;fs->F++;
#line  2970 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 862 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  2981 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  2987 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 820 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 754 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 691 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 628 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 562 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 562 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  3037 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 486 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 421 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 364 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 300 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 235 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 172 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 108 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3107 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3120 "ast-system-unpk.cc"
void
impl_tStatePredicate_ER::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3165 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3165 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2412 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2412 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2412 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  3150 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2418 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		ERFormula* erf = new ERFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0], ctl_formulas[myId][1]);
		erf->index = 2 * myCacheId;
		erf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;
		erf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(erf);

#line  3167 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 951 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 951 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 906 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 906 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 906 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3192 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 906 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  3196 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 906 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->E++;fs->R++;
#line  3200 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 877 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 877 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  3213 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  3220 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 818 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 818 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 752 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 752 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 689 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 689 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 626 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 626 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 558 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 558 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 558 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  3287 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 484 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 484 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 419 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 419 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 362 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 362 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 298 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 298 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 233 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 233 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 170 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3379 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3392 "ast-system-unpk.cc"
void
impl_tStatePredicate_AR::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3164 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3164 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2324 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2324 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2324 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  3422 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2330 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		ARFormula* arf = new ARFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0], ctl_formulas[myId][1]);
		arf->index = 2 * myCacheId;
		arf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;
		arf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(arf);

#line  3439 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 950 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 950 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 905 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 905 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 905 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3464 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 905 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  3468 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 905 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->A++;fs->R++;
#line  3472 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 876 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 876 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  3485 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  3492 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 817 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 817 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 751 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 751 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 688 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 688 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 625 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 625 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 556 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 556 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 556 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  3559 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 483 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 483 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 418 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 418 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 361 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 361 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 297 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 297 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 232 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 232 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 169 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 169 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3651 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3664 "ast-system-unpk.cc"
void
impl_tStatePredicate_EU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3163 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3163 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2392 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2392 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2392 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  3694 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2398 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		EUFormula* euf = new EUFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0], ctl_formulas[myId][1]);
		euf->index = 2 * myCacheId;
		euf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;
		euf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(euf);

#line  3711 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 949 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 949 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 904 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 904 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 904 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  3736 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 904 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  3740 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 904 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->E++;fs->U++;
#line  3744 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 875 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 875 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  3757 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  3764 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 816 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 816 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 750 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 750 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 687 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 687 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 624 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 624 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 554 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 554 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 554 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  3831 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 482 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 482 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 417 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 417 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 360 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 360 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 296 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 296 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 168 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 168 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  3923 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3936 "ast-system-unpk.cc"
void
impl_tStatePredicate_AU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2304 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2304 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2304 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  3966 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2310 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		AUFormula* auf = new AUFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0], ctl_formulas[myId][1]);
		auf->index = 2 * myCacheId;
		auf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;
		auf -> containsNext = containsNext;

		ctl_formulas[ctl_id_stack.top()].push_back(auf);

#line  3983 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 952 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 952 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 907 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 907 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 907 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  4008 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 907 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  4012 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 907 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->A++;fs->U++;
#line  4016 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 878 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 878 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  4029 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  4036 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 819 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 819 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 753 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 753 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 690 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 690 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 627 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 627 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 560 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 560 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 560 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  4103 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 485 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 485 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 420 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 420 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 363 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 363 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 299 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 299 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 234 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 234 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 171 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 171 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4195 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4208 "ast-system-unpk.cc"
void
impl_tStatePredicate_Release::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3162 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 3162 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2611 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 2611 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 2614 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, b, a)));

#line  4242 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1773 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1773 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1774 "Frontend/Parser/formula_unparse.k"

		RT::rep->status("RELEASE");
		validLTLFormula=x->validLTLFormula && y->validLTLFormula;
		validCTLStateFormula = false;
		validCTLPathFormula=x->validCTLStateFormula && y ->validCTLStateFormula;
		cannotcompute = (x->cannotcompute || y->cannotcompute || !(validLTLFormula || validCTLStateFormula));
		if((not cannotcompute)&& x->validLTLFormula)
		{
		    type = FORMULA_LTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		singlepathex = (x -> singlepathex) && (not y -> containsTemporal);
		singlepathall = (y -> singlepathall) && (not x -> containsTemporal);
		containsUniversal = x -> containsUniversal || y -> containsUniversal;
		containsExistential = x -> containsExistential || y -> containsExistential;
		containsFireable = x -> containsFireable || y -> containsFireable;	
		containsUnfireable = x -> containsUnfireable || y -> containsUnfireable;	
		finitepath = x->finitepath;
		finitepathex = false;
		finitepathall = x -> finitepath && y -> finitepath;

#line  4280 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 948 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 948 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 903 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 903 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 903 "Frontend/Parser/formula_unparse.k"
		phi->fs=fs;
#line  4305 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
#line 903 "Frontend/Parser/formula_unparse.k"
		psi->fs=phi->fs;
#line  4309 "ast-system-unpk.cc"
		kc::unparse(psi, kc_printer, kc_current_view);
#line 903 "Frontend/Parser/formula_unparse.k"
		fs=psi->fs;fs->R++;
#line  4313 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 880 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 880 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  4326 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  4333 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 815 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 815 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 749 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 749 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 686 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 686 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 623 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 623 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 552 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 552 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 552 "Frontend/Parser/formula_unparse.k"
		containsNext=(phi->containsNext || psi->containsNext); 
		containsDeadlock = (phi -> containsDeadlock || psi -> containsDeadlock);
#line  4400 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 481 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 481 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 416 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 416 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 359 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 295 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 295 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 230 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 230 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4492 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4505 "ast-system-unpk.cc"
void
impl_tStatePredicate_Until::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3161 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 3161 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2599 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 2599 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 2602 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, b, a)));

#line  4539 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1799 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1799 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1800 "Frontend/Parser/formula_unparse.k"

		validLTLFormula=x->validLTLFormula && y->validLTLFormula;
		validCTLStateFormula = false;
		validCTLPathFormula=x->validCTLStateFormula && y ->validCTLStateFormula;
		cannotcompute = (x->cannotcompute || y->cannotcompute || !(validLTLFormula || validCTLStateFormula));
		if((not cannotcompute)&& x->validLTLFormula)
		{
		    type = FORMULA_LTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		singlepathall = (x -> singlepathall) && (not y -> containsTemporal);
		singlepathex = (y -> singlepathex) && (not x -> containsTemporal);
		containsUniversal = x -> containsUniversal || y -> containsUniversal;
		containsExistential = x -> containsExistential || y -> containsExistential;
		containsFireable = x -> containsFireable || y -> containsFireable;	
		containsUnfireable = x -> containsUnfireable || y -> containsUnfireable;	
		finitepath = false;
		finitepathex = x -> finitepathex && y -> finitepathex;
		finitepathall = false;

#line  4576 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 947 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 947 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 902 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 902 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 902 "Frontend/Parser/formula_unparse.k"
		phi->fs=fs;
#line  4601 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
#line 902 "Frontend/Parser/formula_unparse.k"
		psi->fs=phi->fs;
#line  4605 "ast-system-unpk.cc"
		kc::unparse(psi, kc_printer, kc_current_view);
#line 902 "Frontend/Parser/formula_unparse.k"
		fs=psi->fs;fs->U++;
#line  4609 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 879 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 879 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
#line 880 "Frontend/Parser/formula_unparse.k"
		phi->toplevel = psi->toplevel = false;
#line  4622 "ast-system-unpk.cc"
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 880 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = phi -> containsNext || psi -> containsNext;
		onlyNext = false;
#line  4629 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 814 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 814 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 748 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 748 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 685 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 685 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 622 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 622 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 550 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 550 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 550 "Frontend/Parser/formula_unparse.k"
		containsNext=(phi->containsNext || psi->containsNext); 
		containsDeadlock = (phi -> containsDeadlock || psi -> containsDeadlock);
#line  4696 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 480 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 480 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 415 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 415 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 358 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 358 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 294 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 294 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 229 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 229 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 166 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  4788 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  4801 "ast-system-unpk.cc"
void
impl_tStatePredicate_NextState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3160 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2591 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2593 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NEXT, a, NULL)));

#line  4827 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1698 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1699 "Frontend/Parser/formula_unparse.k"

		cannotcompute = (x -> cannotcompute || not(x->validLTLFormula || x->validCTLStateFormula));
		if((not cannotcompute)&& x->validLTLFormula)
		{
		    type = FORMULA_LTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = false;
		validCTLPathFormula = x->validCTLStateFormula;
		validLTLFormula = x->validLTLFormula;
		singlepathex = false;
		singlepathall = false;
		containsUniversal = x -> containsUniversal;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x -> finitepath;
		finitepathall = x -> finitepath;
		finitepathex = x -> finitepath;

#line  4861 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 946 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 901 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 901 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  4881 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 901 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->X++;
#line  4885 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 872 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 872 "Frontend/Parser/formula_unparse.k"
		x->toplevel = false;
#line  4896 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 872 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = true;
		onlyNext = x -> onlyNext;
#line  4902 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 813 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("X("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 747 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 684 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 621 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 549 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 549 "Frontend/Parser/formula_unparse.k"
		containsNext = true; containsDeadlock = x -> containsDeadlock;
#line  4952 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 479 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 414 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 357 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 293 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 228 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 165 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("X ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  5022 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5035 "ast-system-unpk.cc"
void
impl_tStatePredicate_Eventually::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3159 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2575 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2577 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, tl_nn(TTRUE, NULL, NULL), a)));

#line  5061 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1723 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1724 "Frontend/Parser/formula_unparse.k"

		cannotcompute = (x -> cannotcompute || not(x->validLTLFormula || x->validCTLStateFormula));
		if((not cannotcompute)&& x->validLTLFormula)
		{
		    type = FORMULA_LTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = false;
		validCTLPathFormula = x->validCTLStateFormula;
		validLTLFormula = x->validLTLFormula;
		singlepathex = x -> singlepathex;
		singlepathall = not x -> containsTemporal;
		containsUniversal = x -> containsUniversal;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = false;
		finitepathex = x -> finitepath;
		finitepathall = false;

#line  5095 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 945 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 900 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 900 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  5115 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 900 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->F++;
#line  5119 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 867 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  5130 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  5136 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 812 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("F("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 746 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 683 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 620 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 548 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 548 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock; 
#line  5186 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 478 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 413 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 356 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 292 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 227 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 164 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("F ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  5256 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5269 "ast-system-unpk.cc"
void
impl_tStatePredicate_Always::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3158 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2583 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2585 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, tl_nn(FFALSE, NULL, NULL), a)));

#line  5295 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1748 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1749 "Frontend/Parser/formula_unparse.k"

		cannotcompute = (x -> cannotcompute || not(x->validLTLFormula || x->validCTLStateFormula));
		if((not cannotcompute)&& x->validLTLFormula)
		{
		    type = FORMULA_LTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = false;
		validCTLPathFormula = x->validCTLStateFormula;
		validLTLFormula = x->validLTLFormula;
		singlepathall = x -> singlepathall;
		singlepathex = not x -> containsTemporal;
		containsUniversal = x -> containsUniversal;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x->finitepath;
		finitepathex = false;
		finitepathall = x -> finitepath;

#line  5329 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 944 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 899 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 899 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  5349 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 899 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->G++;
#line  5353 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 866 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 867 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  5364 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 867 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = false;
#line  5370 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 811 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("G("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 745 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 682 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 619 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 547 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 547 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock; 
#line  5420 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 477 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 412 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 355 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 291 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 226 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 163 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 99 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("G ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  5490 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5503 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3157 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1672 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1673 "Frontend/Parser/formula_unparse.k"

		cannotcompute = (x -> cannotcompute || !(x->validCTLPathFormula));
		if(! cannotcompute)
		{
		    type = FORMULA_CTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = x->validCTLPathFormula;
		validCTLPathFormula = false;
		validLTLFormula = false;
		singlepathall = false;
		singlepathex = x -> singlepathex;
		if(singlepathex) type = FORMULA_SINGLEPATHEX;
		containsUniversal = x -> containsUniversal;
		containsExistential = true;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x -> finitepathex;
		finitepathall = false;
		finitepathex = false;

#line  5548 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 943 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 898 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 898 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  5568 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 898 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->E++;
#line  5572 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 859 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 859 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  5583 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 859 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = x -> onlyNext;
#line  5589 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 810 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 744 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 681 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 618 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 546 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 546 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  5639 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 476 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 411 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 354 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 290 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 225 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 162 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 98 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("E ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  5709 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5722 "ast-system-unpk.cc"
void
impl_tStatePredicate_AllPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3156 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1646 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1647 "Frontend/Parser/formula_unparse.k"

		cannotcompute = (x -> cannotcompute || (!toplevel && !(x->validCTLPathFormula)));
		if(! cannotcompute)
		{
		    type = FORMULA_CTL;
		}
		else
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = x->validCTLPathFormula;
		validCTLPathFormula = false;
		validLTLFormula = false;
		singlepathex = false;
		singlepathall = x -> singlepathall;
		if(singlepathall) type = FORMULA_SINGLEPATHALL;
		containsUniversal = true;
		containsExistential = x -> containsExistential;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepath = x -> finitepathall;
		finitepathall = false;
		finitepathex = false;

#line  5767 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 942 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 897 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 897 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  5787 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 897 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->A++;
#line  5791 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 858 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 859 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = false;
#line  5802 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 859 "Frontend/Parser/formula_unparse.k"
		containsTemporal = true;
		containsNext = x -> containsNext;
		onlyNext = x -> onlyNext;
#line  5808 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 809 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 743 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 680 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 617 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 545 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 545 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  5858 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 475 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 410 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 353 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 289 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 224 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 161 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 97 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("A ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  5928 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  5941 "ast-system-unpk.cc"
void
impl_tStatePredicate_Equivalence::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 941 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 941 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 808 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 808 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <-> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 742 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 742 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 679 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 679 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 616 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 543 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 543 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 543 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock); 
#line  6033 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 474 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 474 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 409 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 409 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 352 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 352 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 288 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 288 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 160 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 160 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <-> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  6125 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6138 "ast-system-unpk.cc"
void
impl_tStatePredicate_Implication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3154 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3154 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 940 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 940 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 807 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 807 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" -> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 741 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 741 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 678 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 678 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 615 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 615 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 541 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 541 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 541 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  6230 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 473 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 473 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 408 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 408 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 351 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 351 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 287 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 287 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 222 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 222 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 159 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 159 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" -> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  6322 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6335 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExclusiveDisjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3153 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3153 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 939 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 939 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 806 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 806 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" XOR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 740 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 740 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 677 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 677 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 614 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 614 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 539 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 539 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 539 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  6427 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 472 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 472 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 407 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 407 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 350 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 350 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 286 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 286 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 221 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 221 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 158 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 158 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" XOR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  6519 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6532 "ast-system-unpk.cc"
void
impl_tStatePredicate_Disjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3152 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3152 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2642 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2642 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2645 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(OR, a, b)));

#line  6566 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2240 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2240 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2240 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2240 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  6583 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2244 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		DisjunctionFormula *df = new DisjunctionFormula(ParserPTNet::relabelnet,ctl_formulas[myId]);
		df -> containsNext = containsNext;
		ctl_formulas[ctl_id_stack.top()].push_back(df);

#line  6596 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1912 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1912 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1912 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  6611 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1916 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t  myId = id_stack.top();
		id_stack.pop();

		AtomicBooleanPredicate *f = new AtomicBooleanPredicate(Petrinet::InitialNet,false);
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    f->addSub(formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  6629 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1615 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1615 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1616 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    type = FORMULA_INITIAL;
		}
		else
		{
		    type = FORMULA_DISJUNCTION;
		}
		cannotcompute= x->cannotcompute || y -> cannotcompute;
		if(cannotcompute)
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		validCTLPathFormula = false;
		validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if(validLTLFormula && type == FORMULA_DISJUNCTION) type = FORMULA_LTL;
		if(!toplevel && !validCTLStateFormula && !validLTLFormula) cannotcompute = true;
		singlepathex = x -> singlepathex && y -> singlepathex;
		singlepathall = (x -> singlepathall && not (y ->containsTemporal)) || (y -> singlepathall && not (x->containsTemporal));
		containsUniversal = x -> containsUniversal || y -> containsUniversal;
		containsExistential = x -> containsExistential || y -> containsExistential;
		containsFireable = x -> containsFireable || y -> containsFireable;	
		containsUnfireable = x -> containsUnfireable || y -> containsUnfireable;	
		finitepath = x -> finitepath && y -> finitepath;
		finitepathex = x -> finitepathex && y -> finitepathex;
		finitepathall = y -> finitepathall && y -> finitepathall;

#line  6672 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 938 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 938 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 896 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 896 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 896 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  6697 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 896 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  6701 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 896 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->tdisj++;
#line  6705 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 846 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 846 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 846 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = y -> toplevel = toplevel;
#line  6718 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 846 "Frontend/Parser/formula_unparse.k"
		containsTemporal = x -> containsTemporal || y -> containsTemporal;
		containsNext = x -> containsNext || y -> containsNext;
		onlyNext = x -> onlyNext || y -> onlyNext;
#line  6725 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 805 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 805 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 739 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 739 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 676 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 676 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 613 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 613 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 537 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 537 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 537 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  6792 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 471 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 471 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 406 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 406 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 349 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 285 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 285 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 220 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 220 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 157 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 157 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  6884 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  6897 "ast-system-unpk.cc"
void
impl_tStatePredicate_Conjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3151 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 3151 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 2631 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 2634 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(AND, a, b)));

#line  6931 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2226 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2226 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2226 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 2226 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  6948 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2230 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		ConjunctionFormula *cf = new ConjunctionFormula(ParserPTNet::relabelnet,ctl_formulas[myId]);
		cf -> containsNext = containsNext;
		ctl_formulas[ctl_id_stack.top()].push_back(cf);

#line  6961 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1873 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 1873 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 1873 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  6976 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 1877 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		AtomicBooleanPredicate *f = new AtomicBooleanPredicate(Petrinet::InitialNet,true);
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    f->addSub(formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  6994 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1585 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 1585 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 1586 "Frontend/Parser/formula_unparse.k"

		if(not (x->containsTemporal || y->containsTemporal))
		{
		    type = FORMULA_INITIAL;
		}
		else
		{
		    type = FORMULA_CONJUNCTION;
		}
		cannotcompute= x->cannotcompute || y -> cannotcompute;
		if(cannotcompute)
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		validCTLPathFormula = false;
		validLTLFormula = (x->validLTLFormula && y->validLTLFormula);
		if(!toplevel && !validCTLStateFormula && !validLTLFormula) cannotcompute = true;
		singlepathall = x -> singlepathall && y -> singlepathall;
		singlepathex = (x -> singlepathex && not (y ->containsTemporal)) || (y -> singlepathex && not (x->containsTemporal));
		containsUniversal = x -> containsUniversal || y -> containsUniversal;
		containsExistential = x -> containsExistential || y -> containsExistential;
		containsFireable = x -> containsFireable || y -> containsFireable;	
		containsUnfireable = x -> containsUnfireable || y -> containsUnfireable;	
		finitepath = x -> finitepath && y -> finitepath;
		finitepathex = x -> finitepathex && y -> finitepathex;
		finitepathall = y -> finitepathall && y -> finitepathall;

#line  7036 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 937 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 937 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 895 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 895 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 895 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  7061 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 895 "Frontend/Parser/formula_unparse.k"
		y->fs=x->fs;
#line  7065 "ast-system-unpk.cc"
		kc::unparse(y, kc_printer, kc_current_view);
#line 895 "Frontend/Parser/formula_unparse.k"
		fs=y->fs;fs->tconj++;
#line  7069 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 845 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 845 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
#line 846 "Frontend/Parser/formula_unparse.k"
		x -> toplevel = y -> toplevel = toplevel;
#line  7082 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 846 "Frontend/Parser/formula_unparse.k"
		containsTemporal = x -> containsTemporal || y -> containsTemporal;
		containsNext = x -> containsNext || y -> containsNext;
		onlyNext = x -> onlyNext || y -> onlyNext;
#line  7089 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 804 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 804 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 738 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 738 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 675 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 612 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 612 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 535 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 535 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 535 "Frontend/Parser/formula_unparse.k"
		containsNext = (x->containsNext || y->containsNext); 
		containsDeadlock = (x -> containsDeadlock || y -> containsDeadlock);
#line  7156 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 470 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 470 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 405 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 405 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 348 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 348 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 284 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 284 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 219 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 219 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 156 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 156 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  7248 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7261 "ast-system-unpk.cc"
void
impl_tStatePredicate_Negation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
#line 3150 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 2623 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 2625 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NOT, a, NULL)));

#line  7287 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 2211 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 2211 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  7300 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 2215 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		NotFormula *nf = new NotFormula(ParserPTNet::relabelnet,ctl_formulas[myId][0]);
		nf -> containsNext = containsNext;
		ctl_formulas[ctl_id_stack.top()].push_back(nf);

#line  7313 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1504 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1505 "Frontend/Parser/formula_unparse.k"

		if(not x->containsTemporal)
		{
		    type = FORMULA_INITIAL;
		    singlepathall = true;
		    singlepathex = true;
		}
		else
		{

		    type = FORMULA_MODELCHECKING;
		    singlepathex = x -> singlepathall;
		    singlepathall = x -> singlepathex;
		}
		cannotcompute=x->cannotcompute;
		if(cannotcompute)
		{
		    type = FORMULA_MODELCHECKING;
		}
		validCTLStateFormula = x->validCTLStateFormula;
		validCTLPathFormula = false;
		validLTLFormula = x->validLTLFormula;
		containsUniversal = x -> containsExistential;
		containsExistential = x -> containsUniversal;
		containsFireable = x -> containsUnfireable;	
		containsUnfireable = x -> containsFireable;	
		finitepath = x -> finitepath;
		finitepathex = x -> finitepathall;
		finitepathall = x -> finitepathex;

#line  7354 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    {
#line 936 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 894 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 894 "Frontend/Parser/formula_unparse.k"
		x->fs=fs;
#line  7374 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 894 "Frontend/Parser/formula_unparse.k"
		fs=x->fs;fs->tneg++;
#line  7378 "ast-system-unpk.cc"
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 855 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 855 "Frontend/Parser/formula_unparse.k"
		x->toplevel = toplevel;
#line  7389 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 855 "Frontend/Parser/formula_unparse.k"
		containsTemporal = x -> containsTemporal;
		containsNext = x -> containsNext;
		onlyNext = x -> onlyNext;
#line  7395 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
#line 803 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("NOT("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 737 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 674 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 611 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 534 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 534 "Frontend/Parser/formula_unparse.k"
		containsNext = x -> containsNext; containsDeadlock = x -> containsDeadlock;
#line  7445 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 469 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 404 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
#line 347 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 283 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 218 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("NOT("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  7515 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  7528 "ast-system-unpk.cc"
void
impl_tStatePredicate_AtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 3149 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 3149 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 3149 "Frontend/Parser/formula_unparse.k"
		x->pred = x->pred->copy(NULL);
#line  7542 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 3148 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 3148 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 3148 "Frontend/Parser/formula_unparse.k"
		x -> pred = x->pred->copy(NULL);
#line  7551 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 2459 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2459 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 2460 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = x->pred -> copy(NULL);
		result = result -> negate();


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7581 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 2479 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2479 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 2480 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = x->pred->copy(NULL);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7605 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
#line 2498 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2499 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new TruePredicate(Petrinet::InitialNet);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7627 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 2517 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2518 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new DeadlockPredicate(Petrinet::InitialNet,true);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7649 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 2536 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2537 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new DeadlockPredicate(Petrinet::InitialNet,false);


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7671 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
#line 2555 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2556 "Frontend/Parser/formula_unparse.k"


		StatePredicate * result = new FalsePredicate(Petrinet::InitialNet);



		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  7694 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 2155 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2155 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 2155 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,x->pred->copy(NULL)->negate());
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7712 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 2150 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2150 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 2150 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,x->pred->copy(NULL));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7725 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
#line 2161 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2161 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,new TruePredicate(ParserPTNet::relabelnet));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7736 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
#line 2167 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2167 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,new FalsePredicate(ParserPTNet::relabelnet));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7747 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 2173 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2173 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,new DeadlockPredicate(ParserPTNet::relabelnet,1));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7758 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 2179 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 2179 "Frontend/Parser/formula_unparse.k"

		AtomicFormula* af = new AtomicFormula(ParserPTNet::relabelnet);
		af->inner = new StatePredicateProperty(ParserPTNet::relabelnet,new DeadlockPredicate(ParserPTNet::relabelnet,0));
		ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  7769 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1951 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 1951 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 1952 "Frontend/Parser/formula_unparse.k"

		formula = x->pred -> copy(NULL);
		formula = formula -> negate();

		formulas[id_stack.top()].push_back(formula);    

#line  7788 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 1959 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 1959 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 1960 "Frontend/Parser/formula_unparse.k"

		formulas[id_stack.top()].push_back(x->pred->copy(NULL));    

#line  7799 "ast-system-unpk.cc"
	    } else
	    {
#line 1964 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1486 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1487 "Frontend/Parser/formula_unparse.k"

		type = FORMULA_INITIAL;
		cannotcompute=false;
		validLTLFormula=true;	
		validCTLStateFormula=true;
		validCTLPathFormula=false;
		singlepathall = true;
		singlepathex = true;
		containsUniversal = false;
		containsExistential = false;
		containsFireable = x -> containsFireable;	
		containsUnfireable = x -> containsUnfireable;	
		finitepathex = true;
		finitepathall = true;
		finitepath = true;

#line  7831 "ast-system-unpk.cc"
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 934 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 934 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 934 "Frontend/Parser/formula_unparse.k"
		x->pred=a->formula;
#line  7844 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 933 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 933 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 933 "Frontend/Parser/formula_unparse.k"
		x->pred = a -> formula;
#line  7853 "ast-system-unpk.cc"
			} else
	    {
#line 935 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 935 "Frontend/Parser/formula_unparse.k"
		x -> pred = NULL;
#line  7860 "ast-system-unpk.cc"
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 892 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 892 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 892 "Frontend/Parser/formula_unparse.k"
		fs=x->pred->count(fs);fs->aneg++;
#line  7873 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 891 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 891 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 891 "Frontend/Parser/formula_unparse.k"
		fs=x->pred->count(fs);
#line  7882 "ast-system-unpk.cc"
			} else
	    {
#line 893 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case containstemp_enum: {
	    containstemp_class& kc_current_view=static_cast<containstemp_class&>(kc_current_view_base);
	    {
#line 852 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 852 "Frontend/Parser/formula_unparse.k"
		containsTemporal = false; 
		containsNext = false;
		onlyNext = true;
#line  7899 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
		{ kc_printer(kc_t("NODEADLOCK"), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
		{ kc_printer(kc_t("**"), kc_current_view); }
	    } else
	    {
		{ kc_printer(kc_t("*"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 735 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 735 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 735 "Frontend/Parser/formula_unparse.k"
		x->pred->markslicing(false);
#line  7934 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 734 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 734 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 734 "Frontend/Parser/formula_unparse.k"
		x->pred->markslicing(true);
#line  7943 "ast-system-unpk.cc"
			} else
	    {
#line 736 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 672 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 672 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 672 "Frontend/Parser/formula_unparse.k"
		x->pred->markslicing(true);
#line  7960 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 671 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 671 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 671 "Frontend/Parser/formula_unparse.k"
		x->pred->markslicing(false);
#line  7969 "ast-system-unpk.cc"
			} else
	    {
#line 673 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 609 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 609 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 609 "Frontend/Parser/formula_unparse.k"
		x->pred->markvisible();
#line  7986 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 608 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 608 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 608 "Frontend/Parser/formula_unparse.k"
		x->pred->markvisible();
#line  7995 "ast-system-unpk.cc"
			} else
	    {
#line 610 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 531 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 531 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 531 "Frontend/Parser/formula_unparse.k"
		containsNext = false; containsDeadlock = x -> pred -> countDeadlock(); 
#line  8012 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation)) {
#line 532 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 532 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 532 "Frontend/Parser/formula_unparse.k"
		;containsDeadlock = x -> containsDeadlock; containsNext = false;
#line  8022 "ast-system-unpk.cc"
			} else
	    {
#line 533 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 533 "Frontend/Parser/formula_unparse.k"
		containsDeadlock = x -> containsDeadlock; containsNext = false;
#line  8030 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 467 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 467 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 467 "Frontend/Parser/formula_unparse.k"
		x -> pred = x->pred->hlunfold();
#line  8043 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 466 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 466 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 466 "Frontend/Parser/formula_unparse.k"
		x -> pred = x->pred->hlunfold();
#line  8052 "ast-system-unpk.cc"
			} else
	    {
#line 468 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 398 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 398 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 398 "Frontend/Parser/formula_unparse.k"

		x->pred->createskeletonatomic(Create_HL_Net::current);
		x->pred->createskeletonfireable(Create_HL_Net::current,true,false);
		x->pred->createskeletonunfireable(Create_HL_Net::current,true,false);

#line  8073 "ast-system-unpk.cc"
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 393 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 393 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 393 "Frontend/Parser/formula_unparse.k"

		x->pred->createskeletonatomic(Create_HL_Net::current);
		x->pred->createskeletonfireable(Create_HL_Net::current,true,false);
		x->pred->createskeletonunfireable(Create_HL_Net::current,true,false);

#line  8086 "ast-system-unpk.cc"
	    } else
	    {
#line 403 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 345 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 345 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 345 "Frontend/Parser/formula_unparse.k"
		x->pred=x->pred->foldformula(Create_HL_Net::current);
#line  8103 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 344 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 344 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 344 "Frontend/Parser/formula_unparse.k"
		x->pred=x->pred->foldformula(Create_HL_Net::current); 
#line  8112 "ast-system-unpk.cc"
			} else
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 281 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 281 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 281 "Frontend/Parser/formula_unparse.k"
		x->pred->checkstable(true,NULL);
		x->pred->checkstable(false,NULL);
#line  8128 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 279 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 279 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 279 "Frontend/Parser/formula_unparse.k"
		x->pred->checkstable(true,NULL);
		x -> pred->checkstable(false,NULL);
#line  8138 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 217 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 217 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 217 "Frontend/Parser/formula_unparse.k"
		x->pred->checkCons();
#line  8152 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 216 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 216 "Frontend/Parser/formula_unparse.k"
		x->pred->checkCons();
#line  8161 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 154 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 154 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 154 "Frontend/Parser/formula_unparse.k"
		x->pred->relabel();
#line  8175 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 153 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 153 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 153 "Frontend/Parser/formula_unparse.k"
		x->pred->relabel();
#line  8184 "ast-system-unpk.cc"
			} else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 86 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 86 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(this->tAtomicProposition_1)->tAtomicProposition_1;
#line 86 "Frontend/Parser/formula_unparse.k"
		StatePredicate * t=x->pred->copy(NULL)->negate();kc_printer(t->toString(),kc_current_view);delete t;
#line  8198 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Elementary)) {
#line 85 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this/**/;
#line 85 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 85 "Frontend/Parser/formula_unparse.k"
		kc_printer(x->pred->toString(),kc_current_view);
#line  8207 "ast-system-unpk.cc"
			} else
		if ((this->tAtomicProposition_1->prod_sel() == sel_True)) {
		{ kc_printer(kc_t(" TRUE "), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_False)) {
		{ kc_printer(kc_t(" FALSE "), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
		{ kc_printer(kc_t(" DEADLOCK "), kc_current_view); }
	    } else
		if ((this->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
		{ kc_printer(kc_t(" (NOT DEADLOCK) "), kc_current_view); }
	    } else
		    goto kc_unparsing_default;
	    break;
	}

#line  8225 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 3175 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 3176 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 3176 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 961 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 962 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 962 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 916 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 916 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  8286 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 916 "Frontend/Parser/formula_unparse.k"
		fs=h->fs;
#line  8290 "ast-system-unpk.cc"
			} else
	    {
#line 917 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 917 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 917 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  8299 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 917 "Frontend/Parser/formula_unparse.k"
		l->fs=h->fs;
#line  8303 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 917 "Frontend/Parser/formula_unparse.k"
		fs =l->fs;
#line  8307 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 828 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 829 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 829 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 762 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 763 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 763 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 699 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 700 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 700 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 636 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 637 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 637 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 570 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
#line 570 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext; containsDeadlock = h -> containsDeadlock;
#line  8388 "ast-system-unpk.cc"
			} else
	    {
#line 571 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 571 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 571 "Frontend/Parser/formula_unparse.k"
		containsNext = (l -> containsNext||h -> containsNext);
		containsDeadlock = (l ->containsDeadlock || h -> containsDeadlock);
#line  8400 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 494 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 495 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 495 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 429 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 430 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 430 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 372 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 373 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 373 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 308 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 309 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 309 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 243 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 244 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 244 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 180 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 181 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 181 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 116 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 117 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 117 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  8525 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tConjunction_list iterator_ = this; iterator_->tConjunction_list_1 != 0; iterator_ = iterator_->tConjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8544 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 3179 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 3180 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 3180 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case elem_enum: {
	    elem_class& kc_current_view=static_cast<elem_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 965 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 966 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 966 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 920 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 920 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  8604 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 920 "Frontend/Parser/formula_unparse.k"
		fs=h->fs;
#line  8608 "ast-system-unpk.cc"
			} else
	    {
#line 921 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 921 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 921 "Frontend/Parser/formula_unparse.k"
		h->fs=fs;
#line  8617 "ast-system-unpk.cc"
		kc::unparse(h, kc_printer, kc_current_view);
#line 921 "Frontend/Parser/formula_unparse.k"
		l->fs=h->fs;
#line  8621 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 921 "Frontend/Parser/formula_unparse.k"
		fs=l->fs;
#line  8625 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 832 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 833 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 833 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 766 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 767 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 767 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 703 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 704 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 704 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 640 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 641 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 641 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 575 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
#line 575 "Frontend/Parser/formula_unparse.k"
		containsNext = h -> containsNext; containsDeadlock = h -> containsDeadlock;
#line  8706 "ast-system-unpk.cc"
			} else
	    {
#line 576 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 576 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
#line 576 "Frontend/Parser/formula_unparse.k"
		containsNext = (l -> containsNext||h -> containsNext);
		containsDeadlock = (l ->containsDeadlock || h -> containsDeadlock);
#line  8718 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 498 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 499 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 499 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 433 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 434 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 434 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 376 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 377 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 377 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 312 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 313 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 313 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 248 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 248 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 184 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 185 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 185 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 120 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 121 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 121 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  8843 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tDisjunction_list iterator_ = this; iterator_->tDisjunction_list_1 != 0; iterator_ = iterator_->tDisjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  8862 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  8875 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Deadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1979 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(Petrinet::InitialNet,true);

		formulas[id_stack.top()].push_back(f);    

#line  8895 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1561 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = false;
		containsUnfireable = false;

#line  8909 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 582 "Frontend/Parser/formula_unparse.k"
		containsNext = false; containsDeadlock = true;
#line  8943 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  8991 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9003 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NoDeadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1985 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(Petrinet::InitialNet,false);

		formulas[id_stack.top()].push_back(f);    

#line  9023 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1569 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = false;
		containsUnfireable = false;

#line  9037 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("NODEADLOCK"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 583 "Frontend/Parser/formula_unparse.k"
		containsNext = false; containsDeadlock = true;
#line  9071 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("NOT DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  9119 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9131 "ast-system-unpk.cc"
void
impl_tAtomicProposition_False::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1973 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FalsePredicate(Petrinet::InitialNet);

		formulas[id_stack.top()].push_back(f);    

#line  9151 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1553 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = false;
		containsUnfireable = false;

#line  9165 "ast-system-unpk.cc"
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 925 "Frontend/Parser/formula_unparse.k"
		fs->cont++;
#line  9174 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 581 "Frontend/Parser/formula_unparse.k"
		containsNext = containsDeadlock = false;
#line  9208 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    }
	    break;
	}

#line  9256 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9268 "ast-system-unpk.cc"
void
impl_tAtomicProposition_True::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case copy_enum: {
	    copy_class& kc_current_view=static_cast<copy_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 1967 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new TruePredicate(Petrinet::InitialNet);

		formulas[id_stack.top()].push_back(f);    

#line  9288 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1545 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = false;
		containsUnfireable = false;

#line  9302 "ast-system-unpk.cc"
	    }
	    break;
	}
	case count_enum: {
	    count_class& kc_current_view=static_cast<count_class&>(kc_current_view_base);
	    {
#line 924 "Frontend/Parser/formula_unparse.k"
		fs->taut++;
#line  9311 "ast-system-unpk.cc"
	    }
	    break;
	}
	case structural_enum: {
	    structural_class& kc_current_view=static_cast<structural_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case reduction_enum: {
	    reduction_class& kc_current_view=static_cast<reduction_class&>(kc_current_view_base);
	    {
#line 580 "Frontend/Parser/formula_unparse.k"
		containsNext = containsDeadlock = false;
#line  9345 "ast-system-unpk.cc"
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case foldformula_enum: {
	    foldformula_class& kc_current_view=static_cast<foldformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    }
	    break;
	}

#line  9393 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9405 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NNegation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1536 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 1537 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = x -> containsUnfireable;	
		containsUnfireable = x -> containsFireable;	

#line  9423 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  9428 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9441 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Elementary::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 1577 "Frontend/Parser/formula_unparse.k"

		containsUniversal = false;
		containsExistential = false;
		containsFireable = pred -> containsFireable();
		containsUnfireable = pred -> containsUnfireable();

#line  9456 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  9461 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9473 "ast-system-unpk.cc"
void
impl_tTerm_Complex::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  9479 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9491 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiNull::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2014 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 2014 "Frontend/Parser/formula_unparse.k"
		RT::rep->message("NULL BUECHI"); b->automata = 0; 
#line  9503 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  9562 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  9574 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiAutomaton::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2015 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 2015 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 2015 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
#line 2018 "Frontend/Parser/formula_unparse.k"




		int number_of_states = states_to_interal.size();


		b->automata = new BuechiAutomata(Petrinet::InitialNet);
		b->automata->cardStates = number_of_states;






		b->automata->cardTransitions = new int[number_of_states]();
		b->automata->nextstate = new int*[number_of_states]();
		b->automata->guard = new StatePredicate**[number_of_states]();
		for (int i = 0; i < number_of_states; i++){
		    b->automata->cardTransitions[i] = transitions[i].size();
		    b->automata->nextstate[i] = new int[transitions[i].size()]();
		    b->automata->guard[i] = new StatePredicate*[transitions[i].size()]();
		    for (int j = 0; j < transitions[i].size(); j++){
			b->automata->guard[i][j] = predicates[transitions[i][j].first];
			b->automata->nextstate[i][j] = transitions[i][j].second;
		    }
		}



		b->automata->isStateAccepting = new bool[number_of_states]();
		for (__typeof__(acceptingset.begin()) i = acceptingset.begin(); i != acceptingset.end(); i++)
		b->automata->isStateAccepting[*i] = true;

#line  9625 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 775 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 775 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 712 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 712 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 649 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 649 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 507 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 507 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 442 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 442 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 321 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 321 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 256 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 256 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 193 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 193 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 129 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 129 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  9739 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9752 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2078 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules lrules = this->tBuechiRules_1;
#line 2078 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules rrules = this->tBuechiRules_2;
		kc::unparse(lrules, kc_printer, kc_current_view);
		kc::unparse(rrules, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 781 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 781 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 718 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 718 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 655 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 655 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 513 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 513 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 448 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 448 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 327 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 327 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 262 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 262 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 199 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 199 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 135 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 135 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  9879 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  9892 "ast-system-unpk.cc"
void
impl_tBuechiRules_ExpandedBuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2055 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 2055 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 2055 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
#line 2056 "Frontend/Parser/formula_unparse.k"


		formula->unparse(myprinter, kc::internal);
		StatePredicate* result = formula->formula;






		int formula_number = (int)(predicates.size());
		predicates[formula_number] = result;

		int from_number = get_state_number(from->value);
		int to_number = get_state_number(to->value);

		transitions[from_number].push_back(std::make_pair(formula_number, to_number));

#line  9925 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 780 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 780 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 780 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(formula, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 717 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 717 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 717 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(formula, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 654 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 654 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 654 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(formula, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 512 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 512 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 512 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		kc::unparse(formula, kc_printer, kc_current_view);
		kc::unparse(to, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 447 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 447 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 447 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		kc::unparse(formula, kc_printer, kc_current_view);
		kc::unparse(to, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 326 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 326 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 326 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		kc::unparse(formula, kc_printer, kc_current_view);
		kc::unparse(to, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 261 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 261 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 261 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		kc::unparse(formula, kc_printer, kc_current_view);
		kc::unparse(to, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 198 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 198 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 198 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		kc::unparse(formula, kc_printer, kc_current_view);
		kc::unparse(to, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 134 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(formula, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") -> "), kc_current_view); }
		kc::unparse(to, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

#line  10062 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10075 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 779 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 779 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 716 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 716 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 653 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 653 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 511 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 511 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 446 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 446 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 325 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 325 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 260 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 260 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 197 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 197 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 133 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 133 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		{ kc_printer(kc_t("STATE"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  10190 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10203 "ast-system-unpk.cc"
void
impl_tBuechiRules_EmptyBuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10269 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  10281 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 785 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 785 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 722 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 722 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 659 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 659 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 517 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 517 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 452 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 452 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 331 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 331 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 266 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 266 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 203 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 203 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  10396 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10409 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
#line 784 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 784 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
#line 721 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 721 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
#line 658 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 658 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
#line 516 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 516 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
#line 451 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 451 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
#line 330 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 330 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
#line 265 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 265 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
#line 202 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 202 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 138 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 138 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  10524 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10537 "ast-system-unpk.cc"
void
impl_tTransitionRules_EmptyTransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10597 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  10609 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2089 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set1 = this->tAcceptingSet_1;
#line 2089 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set2 = this->tAcceptingSet_2;
		kc::unparse(set1, kc_printer, kc_current_view);
		kc::unparse(set2, kc_printer, kc_current_view);
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10681 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10694 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 2083 "Frontend/Parser/formula_unparse.k"
		const integer state = this->integer_1;
#line 2084 "Frontend/Parser/formula_unparse.k"

		acceptingset.insert(get_state_number(state->value));

#line  10708 "ast-system-unpk.cc"
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10767 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10780 "ast-system-unpk.cc"
void
impl_tAcceptingSet_EmptyAcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingag_enum: {
	    markslicingag_class& kc_current_view=static_cast<markslicingag_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markslicingef_enum: {
	    markslicingef_class& kc_current_view=static_cast<markslicingef_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case markvisible_enum: {
	    markvisible_class& kc_current_view=static_cast<markvisible_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case hlunfold_enum: {
	    hlunfold_class& kc_current_view=static_cast<hlunfold_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case createskeleton_enum: {
	    createskeleton_class& kc_current_view=static_cast<createskeleton_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkstableatomic_enum: {
	    checkstableatomic_class& kc_current_view=static_cast<checkstableatomic_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case checkcons_enum: {
	    checkcons_class& kc_current_view=static_cast<checkcons_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case relabelformula_enum: {
	    relabelformula_class& kc_current_view=static_cast<relabelformula_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10846 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  10858 "ast-system-unpk.cc"
void
impl_net_Net::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2661 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2661 "Frontend/Parser/formula_unparse.k"
		const definitionsList d = this->definitionsList_1;
#line 2661 "Frontend/Parser/formula_unparse.k"
		const placeblocklist p = this->placeblocklist_1;
#line 2661 "Frontend/Parser/formula_unparse.k"
		const marking m = this->marking_1;
#line 2661 "Frontend/Parser/formula_unparse.k"
		const transition t = this->transition_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
		kc::unparse(p, kc_printer, kc_current_view);
		kc::unparse(m, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  10885 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10898 "ast-system-unpk.cc"
void
impl_definitionsList_DefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2664 "Frontend/Parser/formula_unparse.k"
		const definitionsList l = this->definitionsList_1;
#line 2664 "Frontend/Parser/formula_unparse.k"
		const definitions d = this->definitions_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  10916 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  10929 "ast-system-unpk.cc"
void
impl_definitionsList_EmptyDefinitionsList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  10941 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  10953 "ast-system-unpk.cc"
void
impl_definitions_Function::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2689 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2689 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2689 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2689 "Frontend/Parser/formula_unparse.k"
		const functionParametersList f = this->functionParametersList_1;
#line 2689 "Frontend/Parser/formula_unparse.k"
		const block b = this->block_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2690 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  10977 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 2694 "Frontend/Parser/formula_unparse.k"





#line  10987 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  10992 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11005 "ast-system-unpk.cc"
void
impl_definitions_Sort::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2680 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2680 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2680 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2681 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  11025 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 2685 "Frontend/Parser/formula_unparse.k"



#line  11031 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11036 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11049 "ast-system-unpk.cc"
void
impl_definitions_Constant::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2666 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2666 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2666 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2666 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 2667 "Frontend/Parser/formula_unparse.k"


		if(! (e->is_constant))
		{

		}






#line  11082 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11087 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11100 "ast-system-unpk.cc"
void
impl_type_TypeBlack::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2777 "Frontend/Parser/formula_unparse.k"

		is_finite = true;
		is_scalar = true;
		size = 1;

#line  11114 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11119 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11131 "ast-system-unpk.cc"
void
impl_type_TypeArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11137 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11150 "ast-system-unpk.cc"
void
impl_type_TypeMultiset::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2765 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
		kc::unparse(t, kc_printer, kc_current_view);
#line 2766 "Frontend/Parser/formula_unparse.k"

		if(! (t->is_finite))
		{

		}
		is_finite = false;
		is_scalar = false;
		size = 0; 

#line  11171 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11176 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11189 "ast-system-unpk.cc"
void
impl_type_TypeInt::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2759 "Frontend/Parser/formula_unparse.k"

		is_finite = false;
		is_scalar = true;
		size = 0; 

#line  11203 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11208 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11220 "ast-system-unpk.cc"
void
impl_type_TypeStruct::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2751 "Frontend/Parser/formula_unparse.k"
		const structTypeList s = this->structTypeList_1;
		kc::unparse(s, kc_printer, kc_current_view);
#line 2752 "Frontend/Parser/formula_unparse.k"

		size = s -> size;
		is_finite = s -> is_finite;
		is_scalar = false;

#line  11237 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11242 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11255 "ast-system-unpk.cc"
void
impl_type_TypeIntInterval::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2730 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 2730 "Frontend/Parser/formula_unparse.k"
		const expression f = this->expression_2;
		kc::unparse(e, kc_printer, kc_current_view);
		kc::unparse(f, kc_printer, kc_current_view);
#line 2731 "Frontend/Parser/formula_unparse.k"

		if(!(e->is_constant && f->is_constant))
		{

		}
		if(!(e -> is_scalar && f -> is_scalar))
		{

		}
		arrayindex_t left = *(reinterpret_cast<arrayindex_t *>(e->value));
		arrayindex_t right = *(reinterpret_cast<arrayindex_t *>(f->value));
		if(right < left)
		{

		}
		is_finite = true;
		is_scalar = true;
		size = right - left +1;

#line  11289 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11294 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11307 "ast-system-unpk.cc"
void
impl_type_TypeIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2723 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2724 "Frontend/Parser/formula_unparse.k"




#line  11322 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11327 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11340 "ast-system-unpk.cc"
void
impl_type_TypeEnum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2710 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
		kc::unparse(i, kc_printer, kc_current_view);
#line 2711 "Frontend/Parser/formula_unparse.k"

		size = i -> nrvalues;
		if(size == 0)
		{

		}
		is_finite = true;
		is_scalar = true;


#line  11362 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11367 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11380 "ast-system-unpk.cc"
void
impl_type_TypeBool::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2702 "Frontend/Parser/formula_unparse.k"

		size = 2;
		is_finite = true;
		is_scalar = true;


#line  11395 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11400 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11412 "ast-system-unpk.cc"
void
impl_optionalNumber_OptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2791 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 2792 "Frontend/Parser/formula_unparse.k"

		value = i-> value;
		set = true;

#line  11427 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11432 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11445 "ast-system-unpk.cc"
void
impl_optionalNumber_EmptyOptNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2785 "Frontend/Parser/formula_unparse.k"

		value = ARRAYINDEX_T_MAX;
		set = false;

#line  11458 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11463 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11475 "ast-system-unpk.cc"
void
impl_identList_IdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2805 "Frontend/Parser/formula_unparse.k"
		const identList i = this->identList_1;
#line 2805 "Frontend/Parser/formula_unparse.k"
		const idents d = this->idents_1;
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(d, kc_printer, kc_current_view);
#line 2806 "Frontend/Parser/formula_unparse.k"

		nrvalues = i -> nrvalues + 1;
		if(d -> value <= i -> maxvalue)
		{

		}
		if(!(d -> set))
		{
		    d -> value = i -> maxvalue + 1;
		}

		maxvalue = d -> value;


#line  11504 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11509 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11522 "ast-system-unpk.cc"
void
impl_identList_EmptyIdentList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2799 "Frontend/Parser/formula_unparse.k"

		maxvalue = 0;
		nrvalues = 0;

#line  11535 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11540 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11552 "ast-system-unpk.cc"
void
impl_idents_Idents::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2822 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2822 "Frontend/Parser/formula_unparse.k"
		const optionalNumber o = this->optionalNumber_1;
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(o, kc_printer, kc_current_view);
#line 2823 "Frontend/Parser/formula_unparse.k"

		value = o -> value;
		set = o -> set;

#line  11571 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11576 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11589 "ast-system-unpk.cc"
void
impl_structTypeList_StructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2836 "Frontend/Parser/formula_unparse.k"
		const structTypeList l = this->structTypeList_1;
#line 2836 "Frontend/Parser/formula_unparse.k"
		const structType s = this->structType_1;
		kc::unparse(l, kc_printer, kc_current_view);
		kc::unparse(s, kc_printer, kc_current_view);
#line 2837 "Frontend/Parser/formula_unparse.k"

		size = l -> size * s -> size;
		nrcomponents = l -> nrcomponents + 1;
		is_finite = (l -> is_finite) && (s -> is_finite);

#line  11609 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11614 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11627 "ast-system-unpk.cc"
void
impl_structTypeList_EmptyStructTypeList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2830 "Frontend/Parser/formula_unparse.k"

		size = 0;
		nrcomponents = 0;
		is_finite = true;

#line  11641 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11646 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11658 "ast-system-unpk.cc"
void
impl_structType_StructType::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2844 "Frontend/Parser/formula_unparse.k"
		const type t = this->type_1;
#line 2844 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2844 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
		kc::unparse(t, kc_printer, kc_current_view);
		kc::unparse(c, kc_printer, kc_current_view);
#line 2845 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = t;

#line  11678 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 2849 "Frontend/Parser/formula_unparse.k"

		size = t -> size * a -> nrelements;
		is_finite = t -> is_finite;
		is_scalar = false;

#line  11686 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11691 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11704 "ast-system-unpk.cc"
void
impl_varOrArray_VarOrArray::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2856 "Frontend/Parser/formula_unparse.k"
		const casestring c = this->casestring_1;
#line 2856 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2857 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  11720 "ast-system-unpk.cc"
		kc::unparse(c, kc_printer, kc_current_view);
		kc::unparse(a, kc_printer, kc_current_view);
#line 2861 "Frontend/Parser/formula_unparse.k"

		type = a -> type;

#line  11727 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11732 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11745 "ast-system-unpk.cc"
void
impl_arrayList_ArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2874 "Frontend/Parser/formula_unparse.k"
		const arrayList a = this->arrayList_1;
#line 2874 "Frontend/Parser/formula_unparse.k"
		const expression e = this->expression_1;
#line 2875 "Frontend/Parser/formula_unparse.k"

		a -> inherited_type = inherited_type;

#line  11761 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(e, kc_printer, kc_current_view);
#line 2879 "Frontend/Parser/formula_unparse.k"

		if(!(e -> is_constant))
		{

		}
		if(e -> value == 0)
		{

		}
		nrdimensions = a -> nrdimensions + 1;


		type -> size = nrelements * a -> type -> size;
		type -> is_finite = a -> type -> is_finite;
		type -> is_scalar = false;


#line  11782 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11787 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11800 "ast-system-unpk.cc"
void
impl_arrayList_EmptyArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case hl_staticanalysis_enum: {
	    hl_staticanalysis_class& kc_current_view=static_cast<hl_staticanalysis_class&>(kc_current_view_base);
	    {
#line 2868 "Frontend/Parser/formula_unparse.k"

		nrdimensions = 0;
		nrelements = 1;
		type = inherited_type;

#line  11814 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  11819 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11831 "ast-system-unpk.cc"
void
impl_functionParametersList_FunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11837 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11850 "ast-system-unpk.cc"
void
impl_functionParametersList_EmptyFunctionParametersList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11856 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  11868 "ast-system-unpk.cc"
void
impl_functionParameters_FunctionParameters::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11874 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11887 "ast-system-unpk.cc"
void
impl_expression_ExprAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11893 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11906 "ast-system-unpk.cc"
void
impl_expression_ExprOtherIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11912 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11925 "ast-system-unpk.cc"
void
impl_expression_ExprCommaSeparated::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11931 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11944 "ast-system-unpk.cc"
void
impl_expression_FunctionCall::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11950 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11963 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11969 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  11982 "ast-system-unpk.cc"
void
impl_expression_ExprLessOrEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  11988 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12001 "ast-system-unpk.cc"
void
impl_expression_ExprGreaterThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12007 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12020 "ast-system-unpk.cc"
void
impl_expression_ExprLessThan::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12026 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12039 "ast-system-unpk.cc"
void
impl_expression_ExprNotEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12045 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12058 "ast-system-unpk.cc"
void
impl_expression_ExprEquivalent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12064 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12077 "ast-system-unpk.cc"
void
impl_expression_ExprFalse::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12083 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12095 "ast-system-unpk.cc"
void
impl_expression_ExprTrue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12101 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12113 "ast-system-unpk.cc"
void
impl_expression_ExprOr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12119 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12132 "ast-system-unpk.cc"
void
impl_expression_ExprAnd::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12138 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12151 "ast-system-unpk.cc"
void
impl_expression_NotExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12157 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12170 "ast-system-unpk.cc"
void
impl_expression_ExprNumber::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12176 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12189 "ast-system-unpk.cc"
void
impl_expression_ExprModulo::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12195 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12208 "ast-system-unpk.cc"
void
impl_expression_ExprDivision::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12214 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12227 "ast-system-unpk.cc"
void
impl_expression_ExprMultiplication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12233 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12246 "ast-system-unpk.cc"
void
impl_expression_ExprSubtraction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12252 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12265 "ast-system-unpk.cc"
void
impl_expression_ExprAddition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12271 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12284 "ast-system-unpk.cc"
void
impl_expression_NegativeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12290 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12303 "ast-system-unpk.cc"
void
impl_expression_PositiveExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12309 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12322 "ast-system-unpk.cc"
void
impl_expression_ValDecrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12328 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12341 "ast-system-unpk.cc"
void
impl_expression_ValIncrement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12347 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12360 "ast-system-unpk.cc"
void
impl_expression_DecrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12366 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12379 "ast-system-unpk.cc"
void
impl_expression_IncrementVal::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12385 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12398 "ast-system-unpk.cc"
void
impl_expression_AssignMod::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12404 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12417 "ast-system-unpk.cc"
void
impl_expression_AssignDivide::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12423 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12436 "ast-system-unpk.cc"
void
impl_expression_AssignTimes::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12442 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12455 "ast-system-unpk.cc"
void
impl_expression_AssignMinus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12461 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12474 "ast-system-unpk.cc"
void
impl_expression_AssignPlus::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12480 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12493 "ast-system-unpk.cc"
void
impl_expression_AssignEqual::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12499 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12512 "ast-system-unpk.cc"
void
impl_expression_ExprInitializerList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12518 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12531 "ast-system-unpk.cc"
void
impl_expression_ExprLeftvalue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12537 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12550 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValDot::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12556 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12569 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValBrackets::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12575 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12588 "ast-system-unpk.cc"
void
impl_leftvalue_LeftValIdent::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12594 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12607 "ast-system-unpk.cc"
void
impl_expressionlist_ExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12613 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12626 "ast-system-unpk.cc"
void
impl_expressionlist_EmptyExpressionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12632 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12644 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBracesColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12650 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12663 "ast-system-unpk.cc"
void
impl_initializerList_ExprInBraces::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12669 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12682 "ast-system-unpk.cc"
void
impl_expressionListColon_ExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12688 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12701 "ast-system-unpk.cc"
void
impl_expressionListColon_EmptyExpressionListColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12707 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12719 "ast-system-unpk.cc"
void
impl_placeblocklist_PlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12725 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12738 "ast-system-unpk.cc"
void
impl_placeblocklist_EmptyPlaceBlockList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12744 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12756 "ast-system-unpk.cc"
void
impl_optSafe_Safe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12762 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12775 "ast-system-unpk.cc"
void
impl_optSafe_EmptySafe::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12781 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12793 "ast-system-unpk.cc"
void
impl_place_Place::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12799 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12812 "ast-system-unpk.cc"
void
impl_placelist_PlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12818 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12831 "ast-system-unpk.cc"
void
impl_placelist_EmptyPlaceList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12837 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12849 "ast-system-unpk.cc"
void
impl_placeblock_PlaceBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12855 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12868 "ast-system-unpk.cc"
void
impl_marking_Marking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12874 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12887 "ast-system-unpk.cc"
void
impl_marking_EmptyMarking::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12893 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12905 "ast-system-unpk.cc"
void
impl_transition_Transition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12911 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  12924 "ast-system-unpk.cc"
void
impl_transition_EmptyTransition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12930 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12942 "ast-system-unpk.cc"
void
impl_fairness_StrongFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12948 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12960 "ast-system-unpk.cc"
void
impl_fairness_WeakFair::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12966 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12978 "ast-system-unpk.cc"
void
impl_fairness_EmptyFairness::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  12984 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  12996 "ast-system-unpk.cc"
void
impl_variable_Variable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13002 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13015 "ast-system-unpk.cc"
void
impl_variable_EmptyVariable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13021 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13033 "ast-system-unpk.cc"
void
impl_varOrArrayList_VarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13039 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13052 "ast-system-unpk.cc"
void
impl_varOrArrayList_EmptyVarOrArrayList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13058 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13070 "ast-system-unpk.cc"
void
impl_guard_Guard::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13076 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13089 "ast-system-unpk.cc"
void
impl_identExprList_IdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13095 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13108 "ast-system-unpk.cc"
void
impl_identExprList_EmptyIdentExprList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13114 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13126 "ast-system-unpk.cc"
void
impl_block_Block::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13132 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13145 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13151 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13164 "ast-system-unpk.cc"
void
impl_declarationOrStatement_DeclOrStatemDeclaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13170 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13183 "ast-system-unpk.cc"
void
impl_declarationOrStatement_EmptyDeclarationOrStatement::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13189 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13201 "ast-system-unpk.cc"
void
impl_declaration_Declaration::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13207 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13220 "ast-system-unpk.cc"
void
impl_statement_StatementSkip::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13226 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13238 "ast-system-unpk.cc"
void
impl_statement_StatementReturn::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13244 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13257 "ast-system-unpk.cc"
void
impl_statement_StatementContinue::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13263 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13275 "ast-system-unpk.cc"
void
impl_statement_StatementBreak::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13281 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  13293 "ast-system-unpk.cc"
void
impl_statement_StatementSwitch::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13299 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13312 "ast-system-unpk.cc"
void
impl_statement_StatementForAll::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13318 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13331 "ast-system-unpk.cc"
void
impl_statement_StatementForIdentColon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13337 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13350 "ast-system-unpk.cc"
void
impl_statement_StatementForTypeExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13356 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13369 "ast-system-unpk.cc"
void
impl_statement_StatementForExpr::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13375 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13388 "ast-system-unpk.cc"
void
impl_statement_StatementDoWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13394 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13407 "ast-system-unpk.cc"
void
impl_statement_StatementWhile::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13413 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13426 "ast-system-unpk.cc"
void
impl_statement_StatementIf::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13432 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13445 "ast-system-unpk.cc"
void
impl_statement_StatementExprSemicolon::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13451 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13464 "ast-system-unpk.cc"
void
impl_statement_StatementBlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13470 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13483 "ast-system-unpk.cc"
void
impl_switchCase_SwitchDefault::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13489 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13502 "ast-system-unpk.cc"
void
impl_switchCase_SwitchCase::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13508 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13521 "ast-system-unpk.cc"
void
impl_switchCaseList_SwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13527 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  13540 "ast-system-unpk.cc"
void
impl_switchCaseList_EmptySwitchCaseList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  13546 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


} // namespace kc
