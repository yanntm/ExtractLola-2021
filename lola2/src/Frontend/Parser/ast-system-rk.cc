/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_REWRITE

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-rk.h"


namespace kc {
base_rview_class base_rview;
goodbye_doublearrows_class goodbye_doublearrows;
goodbye_singlearrows_class goodbye_singlearrows;
goodbye_xor_class goodbye_xor;
tautology_class tautology;
emptyquantifiers_class emptyquantifiers;
er_to_ag_class er_to_ag;
eg_to_ag_class eg_to_ag;
efagef_to_ag_class efagef_to_ag;
egef_to_ag_class egef_to_ag;
efeg_to_ag_class efeg_to_ag;
agef_to_ag_class agef_to_ag;
efagef_to_ef_class efagef_to_ef;
agef_to_ef_class agef_to_ef;
eu_to_ef_class eu_to_ef;
exef_to_ef_class exef_to_ef;
egef_to_ef_class egef_to_ef;
efeg_to_ef_class efeg_to_ef;
onlynegation_class onlynegation;
removepathquantifiers_class removepathquantifiers;
singletemporal1_class singletemporal1;
singletemporal_class singletemporal;
simpleneg_class simpleneg;
booleanlists_class booleanlists;
ctloperators_class ctloperators;
rbuechi_class rbuechi;

impl_rviews rviews[] = {
    {"base_rview",&base_rview},
    {"goodbye_doublearrows",&goodbye_doublearrows},
    {"goodbye_singlearrows",&goodbye_singlearrows},
    {"goodbye_xor",&goodbye_xor},
    {"tautology",&tautology},
    {"emptyquantifiers",&emptyquantifiers},
    {"er_to_ag",&er_to_ag},
    {"eg_to_ag",&eg_to_ag},
    {"efagef_to_ag",&efagef_to_ag},
    {"egef_to_ag",&egef_to_ag},
    {"efeg_to_ag",&efeg_to_ag},
    {"agef_to_ag",&agef_to_ag},
    {"efagef_to_ef",&efagef_to_ef},
    {"agef_to_ef",&agef_to_ef},
    {"eu_to_ef",&eu_to_ef},
    {"exef_to_ef",&exef_to_ef},
    {"egef_to_ef",&egef_to_ef},
    {"efeg_to_ef",&efeg_to_ef},
    {"onlynegation",&onlynegation},
    {"removepathquantifiers",&removepathquantifiers},
    {"singletemporal1",&singletemporal1},
    {"singletemporal",&singletemporal},
    {"simpleneg",&simpleneg},
    {"booleanlists",&booleanlists},
    {"ctloperators",&ctloperators},
    {"rbuechi",&rbuechi},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 24 "Frontend/Parser/formula_rewrite.k"
#include <Frontend/Parser/ast-system-rk.h>
#include <CoverGraph/CoverGraph.h>
#include <Formula/StatePredicate/DeadlockPredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/MagicNumber.h>
#include <Core/Runtime.h>

/*
Uncomment the next line to define a debug function that traces all matches in
the rewriting process.
*/
#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE) { RT::rep->status("rewrite %s:%d", FILE, LINE); }

/*!
Count the rule applications
*/
size_t rule_applications = 0;
//#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE) { ++rule_applications; }


#line  102 "ast-system-rk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif
#ifndef KC_TRACE_REWRITE_MATCH
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE)
#endif
#ifndef KC_TRACE_REWRITE_RESULT
#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE)
#endif

tFormula impl_tFormula_CompBound::rewrite(rview kc_current_view_base)
{
    return this;

}

tFormula impl_tFormula_StatePredicateFormula::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 742 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 742, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 742, this);
#line 742 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 742 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  138 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",742,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 746 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 746, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 746, this);
#line 746 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 746 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  150 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",746,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 703 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 703, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 703, this);
#line 703 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 703 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  162 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",703,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 714 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 714, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 714, this);
#line 714 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 714 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  174 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",714,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 715 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 715, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 715, this);
#line 715 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 715 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  186 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",715,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 716 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 716, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 716, this);
#line 716 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 716 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 716 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(x);

#line  200 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",716,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 717 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 717, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 717, this);
#line 717 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 717 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 717 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(x);

#line  214 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",717,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 726 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 726, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 726, this);
#line 726 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 726 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  226 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",726,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 730 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 730, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 730, this);
#line 730 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 730 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  238 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",730,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 731 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 731, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 731, this);
#line 731 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 731 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  250 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",731,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 734 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 734, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 734, this);
#line 734 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 734 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  262 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",734,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 753 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 753, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 753, this);
#line 753 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 753 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  274 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",753,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 754 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 754, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 754, this);
#line 754 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 754 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  286 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",754,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 755 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 755, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 755, this);
#line 755 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 755 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 755 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(x));

#line  300 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",755,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 756 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 756, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 756, this);
#line 756 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 756 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 756 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(x));

#line  314 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",756,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 758 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 758, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 758, this);
#line 758 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 758 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  326 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",758,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 711 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 711, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 711, this);
#line 711 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 711 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  338 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",711,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 721 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 721, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 721, this);
#line 721 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 721 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  350 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",721,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 735 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 735, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 735, this);
#line 735 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 735 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 735 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(x));

#line  364 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",735,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 736 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 736, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 736, this);
#line 736 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 736 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 736 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(x);

#line  378 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",736,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 737 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 737, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 737, this);
#line 737 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 737 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 737 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(x));

#line  392 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",737,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 738 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 738, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 738, this);
#line 738 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 738 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 738 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(x);

#line  406 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",738,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 749 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 749, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 749, this);
#line 749 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 749 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  418 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",749,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 750 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 750, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 750, this);
#line 750 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 750 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  430 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",750,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case singletemporal1_enum: {
	    singletemporal1_class& kc_current_view=static_cast<singletemporal1_class&>(kc_current_view_base);
#line 688 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 688, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 688, this);
#line 688 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 688 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 688 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  448 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",688,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 689 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 689, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 689, this);
#line 689 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 689 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 689 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  462 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",689,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 690 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 690, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 690, this);
#line 690 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 690 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 690 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  476 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",690,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 691 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 691, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 691, this);
#line 691 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 691 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 691 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  490 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",691,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 693 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 693, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 693, this);
#line 693 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 693 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 693 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  504 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",693,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 694 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 694, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 694, this);
#line 694 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 694 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 694 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  518 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",694,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 695 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 695, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 695, this);
#line 695 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 695 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 695 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  532 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",695,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 696 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release) && (KC_TRACE_PROVIDED(((not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal) && (not phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2->containsTemporal)), "Frontend/Parser/formula_rewrite.k", 696, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 696, this);
#line 696 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 696 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 696 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  546 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",696,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tFormula_StatePredicateFormula* kc_result= StatePredicateFormula(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_DisjunctionList::rewrite(rview kc_current_view_base)
{
    tDisjunction_list l_tDisjunction_list_1 =
	tDisjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tDisjunction_list_1 == tDisjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_DisjunctionList* kc_result= DisjunctionList(l_tDisjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ConjunctionList::rewrite(rview kc_current_view_base)
{
    tConjunction_list l_tConjunction_list_1 =
	tConjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tConjunction_list_1 == tConjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_ConjunctionList* kc_result= ConjunctionList(l_tConjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EX* kc_result= EX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AX* kc_result= AX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EG* kc_result= EG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AG* kc_result= AG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EF* kc_result= EF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AF* kc_result= AF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ER::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ER* kc_result= ER(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AR::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AR* kc_result= AR(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_EU* kc_result= EU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AU* kc_result= AU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Release::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 176 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 176, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 176, this);
#line 176 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 176 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  745 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",176,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 210 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 210, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 210, this);
#line 210 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 210 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  757 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",210,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 187 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 187, this);
#line 187 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 187 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  769 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",187,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 215 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 215, this);
#line 215 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 215 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  781 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",215,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 171 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 171, this);
#line 171 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 171 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  793 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",171,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 190 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 190, this);
#line 190 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 190 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  805 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",190,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Release* kc_result= Release(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Until::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 484 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 484, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 484, this);
#line 484 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 484 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1;
#line 484 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 484 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 484 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  846 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",484,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 415 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber==phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 415, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 415, this);
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition y = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 415 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  862 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",415,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 418 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber== - phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 418, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 418, this);
#line 418 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 418 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 418 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition y = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 418 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(a);

#line  878 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",418,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 487 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 487, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 487, this);
#line 487 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 487 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 487 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 487 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_2)->tAtomicProposition_1;
#line 487 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  896 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",487,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 184 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 184, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 184, this);
#line 184 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 184 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  908 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",184,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 204 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 204, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 204, this);
#line 204 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 204 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  920 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",204,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 168 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 168, this);
#line 168 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 168 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  932 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",168,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 207 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 207, this);
#line 207 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 207 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  944 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",207,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 427 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 427, this);
#line 427 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_1;
#line 427 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 427 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 427 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(y, Conjunction(Eventually(y), z));

#line  960 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",427,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 481 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1 -> pred -> magicnumber), "Frontend/Parser/formula_rewrite.k", 481, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 481, this);
#line 481 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 481 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 481 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tAtomicProposition_1;
#line 481 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1;
#line 481 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(y, a);

#line  978 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",481,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 409 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 409, this);
#line 409 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 409 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 409 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Until(x, y));

#line  992 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",409,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 430 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 430, this);
#line 430 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_1;
#line 430 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 430 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 430 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(y, Conjunction(z, Eventually(y)));

#line  1008 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",430,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 165 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 165, this);
#line 165 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 165 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1020 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",165,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 179 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 179, this);
#line 179 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 179 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1032 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",179,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 424 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 424, this);
#line 424 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 424 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 424 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 424 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1048 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",424,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 421 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 421, this);
#line 421 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 421 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 421 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 421 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  1064 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",421,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Until* kc_result= Until(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_NextState::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 141 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 141, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 141, this);
#line 141 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 141 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1097 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",141,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 144 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ltl), "Frontend/Parser/formula_rewrite.k", 144, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 144, this);
#line 144 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 144 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1109 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",144,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 376 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 376, this);
#line 376 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 376 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1121 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",376,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 379 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 379, this);
#line 379 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 379 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1133 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",379,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_NextState* kc_result= NextState(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Eventually::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 153 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 153, this);
#line 153 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 153 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1166 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",153,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 156 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 156, this);
#line 156 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 156 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1178 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",156,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 196 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 196, this);
#line 196 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 196 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1190 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",196,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 370 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 370, this);
#line 370 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 370 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1202 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",370,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 385 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 385, this);
#line 385 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Always(x));

#line  1216 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",385,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 346 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 346, this);
#line 346 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 346 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1228 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",346,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 355 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 355, this);
#line 355 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 355 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Eventually(x));

#line  1240 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",355,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 433 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 433, this);
#line 433 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 433 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 433 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(y);

#line  1254 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",433,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Eventually* kc_result= Eventually(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Always::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 442 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 442, this);
#line 442 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 442 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 442 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(Always(ExPath(Eventually(y)))), AllPath(Always(Disjunction(x, y))));

#line  1289 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",442,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 159 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 159, this);
#line 159 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 159 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1301 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",159,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 162 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 162, this);
#line 162 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 162 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1313 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",162,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 199 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 199, this);
#line 199 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 199 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1325 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",199,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 373 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 373, this);
#line 373 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 373 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1337 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",373,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 382 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 382, this);
#line 382 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 382 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Eventually(x));

#line  1349 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",382,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 349 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 349, this);
#line 349 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 349 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1361 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",349,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 352 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 352, this);
#line 352 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 352 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Always(x));

#line  1373 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",352,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 436 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 436, this);
#line 436 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 436 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 436 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Always(Eventually(y)), Always(Disjunction(x, y)));

#line  1387 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",436,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Always* kc_result= Always(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 806 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 806, this);
#line 806 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 806 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EF(x);

#line  1420 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",806,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 807 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 807, this);
#line 807 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 807 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EX(x);

#line  1432 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",807,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 808 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 808, this);
#line 808 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 808 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EG(x);

#line  1444 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",808,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 809 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 809, this);
#line 809 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 809 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 809 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(x, y);

#line  1458 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",809,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 810 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 810, this);
#line 810 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 810 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 810 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ER(x, y);

#line  1472 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",810,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case removepathquantifiers_enum: {
	    removepathquantifiers_class& kc_current_view=static_cast<removepathquantifiers_class&>(kc_current_view_base);
#line 678 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 678, this);
#line 678 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 679 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1488 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",679,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case efeg_to_ef_enum: {
	    efeg_to_ef_class& kc_current_view=static_cast<efeg_to_ef_class&>(kc_current_view_base);
#line 634 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 634, this);
#line 634 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 634 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1503 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",634,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case egef_to_ef_enum: {
	    egef_to_ef_class& kc_current_view=static_cast<egef_to_ef_class&>(kc_current_view_base);
#line 629 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 629, this);
#line 629 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 629 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1519 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",629,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case exef_to_ef_enum: {
	    exef_to_ef_class& kc_current_view=static_cast<exef_to_ef_class&>(kc_current_view_base);
#line 624 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 624, this);
#line 624 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 624 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1535 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",624,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case eu_to_ef_enum: {
	    eu_to_ef_class& kc_current_view=static_cast<eu_to_ef_class&>(kc_current_view_base);
#line 617 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 617, this);
#line 617 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 617 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 617 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1553 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",617,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 619 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 619, this);
#line 619 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 619 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 619 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1567 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",619,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case agef_to_ef_enum: {
	    agef_to_ef_class& kc_current_view=static_cast<agef_to_ef_class&>(kc_current_view_base);
#line 613 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 613, this);
#line 613 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 613 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  1583 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",613,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efagef_to_ef_enum: {
	    efagef_to_ef_class& kc_current_view=static_cast<efagef_to_ef_class&>(kc_current_view_base);
#line 607 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 607, this);
#line 607 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 607 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1599 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",607,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case agef_to_ag_enum: {
	    agef_to_ag_class& kc_current_view=static_cast<agef_to_ag_class&>(kc_current_view_base);
#line 603 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 603, this);
#line 603 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 603 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  1615 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",603,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efeg_to_ag_enum: {
	    efeg_to_ag_class& kc_current_view=static_cast<efeg_to_ag_class&>(kc_current_view_base);
#line 597 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 597, this);
#line 597 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 597 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1631 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",597,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case egef_to_ag_enum: {
	    egef_to_ag_class& kc_current_view=static_cast<egef_to_ag_class&>(kc_current_view_base);
#line 592 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 592, this);
#line 592 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 592 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1647 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",592,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efagef_to_ag_enum: {
	    efagef_to_ag_class& kc_current_view=static_cast<efagef_to_ag_class&>(kc_current_view_base);
#line 587 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 587, this);
#line 587 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 587 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1663 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",587,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case eg_to_ag_enum: {
	    eg_to_ag_class& kc_current_view=static_cast<eg_to_ag_class&>(kc_current_view_base);
#line 580 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 580, this);
#line 580 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 580 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1679 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",580,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 582 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 582, this);
#line 582 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 582 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1691 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",582,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case er_to_ag_enum: {
	    er_to_ag_class& kc_current_view=static_cast<er_to_ag_class&>(kc_current_view_base);
#line 573 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 573, this);
#line 573 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 573 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 573 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(y));

#line  1709 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",573,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 575 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 575, this);
#line 575 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 575 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 575 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(y));

#line  1723 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",575,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 563 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 563, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 563, this);
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 563 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1739 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",563,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 406 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 406, this);
#line 406 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 406 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1755 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",406,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 466 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 466, this);
#line 466 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 466 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(AllPath(Always(Conjunction(x, AtomicProposition(NoDeadlock()))))));

#line  1767 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",466,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 129 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 129, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 129, this);
#line 129 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  1777 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",129,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 132 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 132, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 132, this);
#line 132 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1787 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",132,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 175 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release) && (phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 175, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 175, this);
#line 175 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 175 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1799 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",175,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 182 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 182, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 182, this);
#line 182 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 182 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1811 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",182,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 202 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 202, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 202, this);
#line 202 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 202 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1823 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",202,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 211 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release) && (phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 211, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 211, this);
#line 211 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 211 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1835 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",211,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 394 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 394, this);
#line 394 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 394 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(NextState(ExPath(Eventually(x))));

#line  1847 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",394,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 400 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 400, this);
#line 400 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 400 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1859 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",400,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 445 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 445, this);
#line 445 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 445 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 445 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  1873 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",445,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 454 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 454, this);
#line 454 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 454 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(x));

#line  1885 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",454,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 460 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 460, this);
#line 460 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 460 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 460 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1899 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",460,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 475 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 475, this);
#line 475 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 475 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 475 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  1913 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",475,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 547 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 547, this);
#line 547 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 547 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 547 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(Eventually(a)), ExPath(Eventually(b)));

#line  1927 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",547,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 553 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 553, this);
#line 553 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 553 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Disjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 553 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(NextState(a)), ExPath(NextState(b)));

#line  1941 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",553,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 472 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 472, this);
#line 472 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 472 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 472 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 472 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1957 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",472,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 147 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 147, this);
#line 147 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 147 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1969 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",147,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 364 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 364, this);
#line 364 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 364 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1981 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",364,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 367 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 367, this);
#line 367 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 367 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1993 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",367,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 532 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 532, this);
#line 532 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 532 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 532 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(x), ExPath(y));

#line  2007 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",532,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_ExPath* kc_result= ExPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AllPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 811 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 811, this);
#line 811 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 811 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AF(x);

#line  2040 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",811,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 812 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 812, this);
#line 812 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 812 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AX(x);

#line  2052 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",812,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 813 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 813, this);
#line 813 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 813 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AG(x);

#line  2064 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",813,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 814 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 814, this);
#line 814 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 814 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 814 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(x, y);

#line  2078 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",814,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 815 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 815, this);
#line 815 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 815 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 815 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AR(x, y);

#line  2092 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",815,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case removepathquantifiers_enum: {
	    removepathquantifiers_class& kc_current_view=static_cast<removepathquantifiers_class&>(kc_current_view_base);
#line 679 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 679, this);
#line 679 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 679 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2108 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",679,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case efeg_to_ef_enum: {
	    efeg_to_ef_class& kc_current_view=static_cast<efeg_to_ef_class&>(kc_current_view_base);
#line 635 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 635, this);
#line 635 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 635 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2123 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",635,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case egef_to_ef_enum: {
	    egef_to_ef_class& kc_current_view=static_cast<egef_to_ef_class&>(kc_current_view_base);
#line 630 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 630, this);
#line 630 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 630 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2139 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",630,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case exef_to_ef_enum: {
	    exef_to_ef_class& kc_current_view=static_cast<exef_to_ef_class&>(kc_current_view_base);
#line 625 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 625, this);
#line 625 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 625 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2155 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",625,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case eu_to_ef_enum: {
	    eu_to_ef_class& kc_current_view=static_cast<eu_to_ef_class&>(kc_current_view_base);
#line 618 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 618, this);
#line 618 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 618 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 618 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2173 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",618,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 620 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 620, this);
#line 620 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 620 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 620 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2187 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",620,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case agef_to_ef_enum: {
	    agef_to_ef_class& kc_current_view=static_cast<agef_to_ef_class&>(kc_current_view_base);
#line 612 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 612, this);
#line 612 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 612 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(y));

#line  2203 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",612,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efagef_to_ef_enum: {
	    efagef_to_ef_class& kc_current_view=static_cast<efagef_to_ef_class&>(kc_current_view_base);
#line 608 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 608, this);
#line 608 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 608 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Negation(y)));

#line  2219 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",608,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case agef_to_ag_enum: {
	    agef_to_ag_class& kc_current_view=static_cast<agef_to_ag_class&>(kc_current_view_base);
#line 602 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 602, this);
#line 602 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 602 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  2235 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",602,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efeg_to_ag_enum: {
	    efeg_to_ag_class& kc_current_view=static_cast<efeg_to_ag_class&>(kc_current_view_base);
#line 598 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 598, this);
#line 598 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 598 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2251 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",598,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case egef_to_ag_enum: {
	    egef_to_ag_class& kc_current_view=static_cast<egef_to_ag_class&>(kc_current_view_base);
#line 593 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 593, this);
#line 593 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 593 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2267 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",593,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case efagef_to_ag_enum: {
	    efagef_to_ag_class& kc_current_view=static_cast<efagef_to_ag_class&>(kc_current_view_base);
#line 588 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 588, this);
#line 588 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 588 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2283 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",588,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case eg_to_ag_enum: {
	    eg_to_ag_class& kc_current_view=static_cast<eg_to_ag_class&>(kc_current_view_base);
#line 581 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 581, this);
#line 581 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 581 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2299 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",581,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 583 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 583, this);
#line 583 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 583 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2311 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",583,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case er_to_ag_enum: {
	    er_to_ag_class& kc_current_view=static_cast<er_to_ag_class&>(kc_current_view_base);
#line 574 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 574, this);
#line 574 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 574 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 574 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(x)));

#line  2329 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",574,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 576 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 576, this);
#line 576 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 576 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 576 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Negation(y)));

#line  2343 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",576,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case emptyquantifiers_enum: {
	    emptyquantifiers_class& kc_current_view=static_cast<emptyquantifiers_class&>(kc_current_view_base);
#line 564 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((not l_tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_rewrite.k", 564, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 564, this);
#line 564 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 564 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2359 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",564,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 403 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 403, this);
#line 403 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 403 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2375 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",403,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 463 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 463, this);
#line 463 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 463 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 463 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2389 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",463,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 135 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 135, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 135, this);
#line 135 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2399 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",135,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 138 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg==preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 138, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 138, this);
#line 138 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2409 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",138,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 174 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release) && (phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 174, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 174, this);
#line 174 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 174 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2421 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",174,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 183 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 183, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 183, this);
#line 183 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 183 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2433 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",183,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 203 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 203, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 203, this);
#line 203 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 203 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2445 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",203,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 212 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release) && (phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (KC_TRACE_PROVIDED((RT::args.preference_arg == preference_arg_force_ctl), "Frontend/Parser/formula_rewrite.k", 212, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 212, this);
#line 212 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 212 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2457 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",212,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 388 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 388, this);
#line 388 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 388 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2469 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",388,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 391 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 391, this);
#line 391 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 391 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2481 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",391,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 397 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 397, this);
#line 397 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 397 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(NextState(AllPath(Always(x))));

#line  2493 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",397,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 439 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 439, this);
#line 439 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 439 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 439 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Eventually(y));

#line  2507 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",439,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 448 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 448, this);
#line 448 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 448 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 448 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2521 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",448,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 457 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 457, this);
#line 457 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 457 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(x));

#line  2533 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",457,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 478 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 478, this);
#line 478 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 478 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 478 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(y, Conjunction(AllPath(Always(x)), AllPath(Eventually(y))));

#line  2547 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",478,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 544 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 544, this);
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 544 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(Always(a)), AllPath(Always(b)));

#line  2561 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",544,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 550 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 550, this);
#line 550 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 550 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Conjunction*>(phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_2;
#line 550 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(NextState(a)), AllPath(NextState(b)));

#line  2575 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",550,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 451 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 451, this);
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 451 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 451 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2591 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",451,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 469 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 469, this);
#line 469 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 469 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 469 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 469 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  2607 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",469,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 150 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 150, this);
#line 150 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 150 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2619 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",150,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 358 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 358, this);
#line 358 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 358 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2631 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",358,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 361 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 361, this);
#line 361 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 361 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2643 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",361,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 535 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 535, this);
#line 535 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 535 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 535 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(x), AllPath(y));

#line  2657 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",535,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AllPath* kc_result= AllPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Equivalence::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_doublearrows_enum: {
	    goodbye_doublearrows_class& kc_current_view=static_cast<goodbye_doublearrows_class&>(kc_current_view_base);
#line 62 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 62, this);
#line 62 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 62 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 63 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Disjunction(x, Negation(y)), Disjunction(Negation(x), y));

#line  2694 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",63,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Equivalence* kc_result= Equivalence(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Implication::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_singlearrows_enum: {
	    goodbye_singlearrows_class& kc_current_view=static_cast<goodbye_singlearrows_class&>(kc_current_view_base);
#line 68 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 68, this);
#line 68 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 68 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 68 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), y);

#line  2729 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",68,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Implication* kc_result= Implication(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExclusiveDisjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_xor_enum: {
	    goodbye_xor_class& kc_current_view=static_cast<goodbye_xor_class&>(kc_current_view_base);
#line 73 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 73, this);
#line 73 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 73 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 73 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(x, Negation(y)), Conjunction(Negation(x), y));

#line  2764 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",73,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ExclusiveDisjunction* kc_result= ExclusiveDisjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Disjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 797 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 797, this);
#line 797 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 797 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 797 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = DisjunctionList(ConstDisjunction_list(x, ConstDisjunction_list(y, NiltDisjunction_list())));

#line  2799 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",797,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 493 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 493, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 493, this);
#line 493 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_1;
#line 493 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 493 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 493 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  2818 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",493,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 499 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 499, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 499, this);
#line 499 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 499 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 499 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 499 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  2834 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",499,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 236 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 236, this);
#line 236 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2844 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",236,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 237 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 237, this);
#line 237 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2854 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",237,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 238 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 238, this);
#line 238 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 238 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2866 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",238,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 239 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 239, this);
#line 239 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 239 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2878 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",239,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 226 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 226, this);
#line 226 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2888 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",226,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 227 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 227, this);
#line 227 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2898 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",227,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 228 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 228, this);
#line 228 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 228 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2910 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",228,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 229 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 229, this);
#line 229 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 229 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2922 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",229,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 121 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 121, this);
#line 121 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 121 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  2934 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",121,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 123 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 123, this);
#line 123 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_1;
#line 123 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  2946 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",123,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 518 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 518, this);
#line 518 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 518 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 518 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Disjunction(x, y));

#line  2960 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",518,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 527 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 527, this);
#line 527 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 527 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 527 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Disjunction(x, y));

#line  2974 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",527,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 253 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 253, this);
#line 253 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 253 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 253 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 253 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(x, Disjunction(y, z));

#line  2990 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",253,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 120 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 120, this);
#line 120 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 120 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  3002 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",120,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 122 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 122, this);
#line 122 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_2;
#line 122 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  3014 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",122,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Disjunction* kc_result= Disjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Conjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 793 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 793, this);
#line 793 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 793 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 793 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ConjunctionList(ConstConjunction_list(x, ConstConjunction_list(y, NiltConjunction_list())));

#line  3051 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",793,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 490 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 490, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 490, this);
#line 490 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 490 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 490 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 490 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  3070 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",490,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 496 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (l_tStatePredicate_2->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->pred->magicnumber == phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1 -> pred->magicnumber), "Frontend/Parser/formula_rewrite.k", 496, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 496, this);
#line 496 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_1;
#line 496 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 496 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition z = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1;
#line 496 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  3086 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",496,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 241 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 241, this);
#line 241 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3096 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",241,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 242 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 242, this);
#line 242 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3106 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",242,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 243 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 243, this);
#line 243 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 243 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3118 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",243,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 244 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 244, this);
#line 244 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 244 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3130 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",244,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 231 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 231, this);
#line 231 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3140 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",231,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 232 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 232, this);
#line 232 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3150 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",232,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 233 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 233, this);
#line 233 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 233 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3162 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",233,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 234 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 234, this);
#line 234 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 234 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3174 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",234,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 115 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 115, this);
#line 115 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 115 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  3186 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",115,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 117 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 117, this);
#line 117 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_1;
#line 117 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  3198 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",117,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 521 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 521, this);
#line 521 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 521 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 521 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Conjunction(x, y));

#line  3212 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",521,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 524 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 524, this);
#line 524 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 524 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 524 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Conjunction(x, y));

#line  3226 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",524,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 250 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 250, this);
#line 250 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 250 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 250 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 250 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(x, Conjunction(y, z));

#line  3242 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",250,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 114 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 114, this);
#line 114 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 114 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  3254 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",114,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 116 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 116, this);
#line 116 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_2;
#line 116 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  3266 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",116,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Conjunction* kc_result= Conjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Negation::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpleneg_enum: {
	    simpleneg_class& kc_current_view=static_cast<simpleneg_class&>(kc_current_view_base);
#line 788 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 788, this);
#line 788 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
#line 788 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(x);

#line  3299 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",788,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 770 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 770, this);
#line 770 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3309 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",770,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 773 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 773, this);
#line 773 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3319 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",773,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 776 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 776, this);
#line 776 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  3329 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",776,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 779 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 779, this);
#line 779 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  3339 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",779,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 787 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 787, this);
#line 787 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 787 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NNegation(x));

#line  3351 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",787,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 762 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 762, this);
#line 762 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 762 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3363 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",762,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 764 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 764, this);
#line 764 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 764 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 764 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  3377 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",764,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 767 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 767, this);
#line 767 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 767 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 767 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  3391 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",767,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 700 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 700, this);
#line 700 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 700 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  3407 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",700,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case onlynegation_enum: {
	    onlynegation_class& kc_current_view=static_cast<onlynegation_class&>(kc_current_view_base);
#line 674 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 674, this);
#line 674 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
#line 674 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(x);

#line  3423 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",674,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 668 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 668, this);
#line 668 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 668 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NNegation(x));

#line  3435 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",668,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 659 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 659, this);
#line 659 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 659 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Negation(x));

#line  3447 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",659,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 660 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 660, this);
#line 660 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 660 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Negation(x));

#line  3459 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",660,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 661 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 661, this);
#line 661 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 661 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Negation(x));

#line  3471 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",661,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 662 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 662, this);
#line 662 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 662 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Negation(x));

#line  3483 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",662,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 663 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 663, this);
#line 663 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 663 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 663 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Release(Negation(x), Negation(y));

#line  3497 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",663,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 664 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 664, this);
#line 664 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 664 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 664 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(Negation(x), Negation(y));

#line  3511 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",664,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 665 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 665, this);
#line 665 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 665 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 665 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  3525 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",665,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 666 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 666, this);
#line 666 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 666 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 666 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  3539 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",666,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 667 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 667, this);
#line 667 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 667 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3551 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",667,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 299 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 299, this);
#line 299 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tAtomicProposition_1;
#line 299 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(x);

#line  3567 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",299,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 278 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 278, this);
#line 278 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3577 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",278,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 281 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 281, this);
#line 281 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3587 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",281,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 284 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 284, this);
#line 284 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  3597 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",284,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 287 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 287, this);
#line 287 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  3607 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",287,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 296 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Elementary)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 296, this);
#line 296 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1;
#line 296 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NNegation(x));

#line  3619 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",296,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 311 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 311, this);
#line 311 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  3631 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",311,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 314 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 314, this);
#line 314 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 314 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 314 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  3645 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",314,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 317 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 317, this);
#line 317 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 317 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 317 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  3659 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",317,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 322 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 322, this);
#line 322 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 322 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Negation(x));

#line  3671 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",322,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 325 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 325, this);
#line 325 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 325 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Negation(x));

#line  3683 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",325,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 328 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 328, this);
#line 328 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 328 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Negation(x));

#line  3695 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",328,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 331 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 331, this);
#line 331 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 331 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Negation(x));

#line  3707 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",331,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 334 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 334, this);
#line 334 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 334 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Negation(x));

#line  3719 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",334,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 337 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 337, this);
#line 337 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 337 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 337 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Release(Negation(x), Negation(y));

#line  3733 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",337,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 340 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 340, this);
#line 340 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 340 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 340 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(Negation(x), Negation(y));

#line  3747 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",340,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Negation* kc_result= Negation(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AtomicProposition::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 100 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_FALSE), "Frontend/Parser/formula_rewrite.k", 100, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 100, this);
#line 100 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 100 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 100 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3782 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",100,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 102 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation) && (phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_TRUE), "Frontend/Parser/formula_rewrite.k", 102, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 102, this);
#line 102 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 102 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 102 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3796 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",102,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 92 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED(((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_TRUE), "Frontend/Parser/formula_rewrite.k", 92, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 92, this);
#line 92 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 92 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3808 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",92,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 94 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED(((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_FALSE), "Frontend/Parser/formula_rewrite.k", 94, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 94, this);
#line 94 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 94 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3820 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",94,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 96 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((l_tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_FALSE), "Frontend/Parser/formula_rewrite.k", 96, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 96, this);
#line 96 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 96 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = l_tAtomicProposition_1;
#line 96 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3834 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",96,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 98 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((l_tAtomicProposition_1->pred->magicnumber == MAGIC_NUMBER_TRUE), "Frontend/Parser/formula_rewrite.k", 98, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 98, this);
#line 98 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 98 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = l_tAtomicProposition_1;
#line 98 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3848 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",98,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 107 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED(((l_tAtomicProposition_1->shape == AT_DL) && !(((DeadlockPredicate*)(l_tAtomicProposition_1->pred))->sign)), "Frontend/Parser/formula_rewrite.k", 107, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 107, this);
#line 107 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 107 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = l_tAtomicProposition_1;
#line 107 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  3862 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",107,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 109 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_COMP) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->cardPos == 0) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->threshold >= 0)), "Frontend/Parser/formula_rewrite.k", 109, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 109, this);
#line 109 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 109 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  3874 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",109,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 111 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_Elementary) && (KC_TRACE_PROVIDED((((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->shape == AT_COMP) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->cardNeg == 0) && (((AtomicStatePredicate*)((((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1))->formula))->threshold < 0)), "Frontend/Parser/formula_rewrite.k", 111, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 111, this);
#line 111 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = (((l_tAtomicProposition_1 == tAtomicProposition_1)) ? this : AtomicProposition(l_tAtomicProposition_1));
#line 111 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  3886 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",111,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tStatePredicate_AtomicProposition* kc_result= AtomicProposition(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tConjunction_list impl_tConjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tConjunction_list l_tConjunction_list_1 =
	    tConjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 794 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ConjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 794, this);
#line 794 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list x = phylum_cast<const impl_tStatePredicate_ConjunctionList*>(l_tStatePredicate_1)->tConjunction_list_1;
#line 794 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list y = l_tConjunction_list_1;
#line 794 "Frontend/Parser/formula_rewrite.k"
		    tConjunction_list kc_result = concat(x, y);

#line  3926 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",794,kc_result);
		    return (const_cast<const impl_tConjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tConjunction_list_1 == tConjunction_list_1))
	    return this;
	else {
	    impl_tConjunction_list* kc_result= ConstConjunction_list(l_tStatePredicate_1, l_tConjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tDisjunction_list impl_tDisjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tDisjunction_list l_tDisjunction_list_1 =
	    tDisjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 798 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_DisjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 798, this);
#line 798 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list x = phylum_cast<const impl_tStatePredicate_DisjunctionList*>(l_tStatePredicate_1)->tDisjunction_list_1;
#line 798 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list y = l_tDisjunction_list_1;
#line 798 "Frontend/Parser/formula_rewrite.k"
		    tDisjunction_list kc_result = concat(x, y);

#line  3966 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",798,kc_result);
		    return (const_cast<const impl_tDisjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tDisjunction_list_1 == tDisjunction_list_1))
	    return this;
	else {
	    impl_tDisjunction_list* kc_result= ConstDisjunction_list(l_tStatePredicate_1, l_tDisjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tAtomicProposition impl_tAtomicProposition_Deadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NoDeadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_False::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_True::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NNegation::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case onlynegation_enum: {
	    onlynegation_class& kc_current_view=static_cast<onlynegation_class&>(kc_current_view_base);
#line 669 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 669, this);
#line 669 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NoDeadlock();

#line  4021 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",669,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 670 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 670, this);
#line 670 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = Deadlock();

#line  4031 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",670,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 671 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 671, this);
#line 671 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  4041 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",671,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 672 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 672, this);
#line 672 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  4051 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",672,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 673 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 673, this);
#line 673 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 673 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = x;

#line  4063 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",673,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 303 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 303, this);
#line 303 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NoDeadlock();

#line  4077 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",303,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 304 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 304, this);
#line 304 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = Deadlock();

#line  4087 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",304,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 305 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 305, this);
#line 305 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  4097 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",305,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 306 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 306, this);
#line 306 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  4107 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",306,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 307 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NNegation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 307, this);
#line 307 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = phylum_cast<const impl_tAtomicProposition_NNegation*>(l_tAtomicProposition_1)->tAtomicProposition_1;
#line 307 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = x;

#line  4119 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",307,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tAtomicProposition_NNegation* kc_result= NNegation(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_Elementary::rewrite(rview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 105 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED(((this->shape == AT_DL) && ((DeadlockPredicate*)(this->pred))->sign), "Frontend/Parser/formula_rewrite.k", 105, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 105, this);
#line 105 "Frontend/Parser/formula_rewrite.k"
		const tAtomicProposition x = this;
#line 105 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = Deadlock();

#line  4150 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",105,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    return this;

}

tTerm impl_tTerm_Complex::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiNull::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiAutomaton::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tAcceptingSet_1 == tAcceptingSet_1))
	return this;
    else {
	impl_tBuechiAutomata_BuechiAutomaton* kc_result= BuechiAutomaton(l_tBuechiRules_1, l_tAcceptingSet_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRules::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tBuechiRules l_tBuechiRules_2 =
	tBuechiRules_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 825 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tBuechiRules_1->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 825, this);
#line 825 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_2;
#line 825 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  4207 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",825,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 824 "Frontend/Parser/formula_rewrite.k"
		if ((l_tBuechiRules_2->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 824, this);
#line 824 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_1;
#line 824 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  4219 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",824,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tBuechiRules_2 == tBuechiRules_2))
	return this;
    else {
	impl_tBuechiRules_BuechiRules* kc_result= BuechiRules(l_tBuechiRules_1, l_tBuechiRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_ExpandedBuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_2 =
	integer_2->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1) &&  (l_tFormula_1 == tFormula_1) &&  (l_integer_2 == integer_2))
	return this;
    else {
	impl_tBuechiRules_ExpandedBuechiRule* kc_result= ExpandedBuechiRule(l_integer_1, l_tFormula_1, l_integer_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 821 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 821, this);
#line 821 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 821 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules lrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_1;
#line 821 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules rrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_2;
#line 821 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = BuechiRules(BuechiRule(from, lrules), BuechiRule(from, rrules));

#line  4275 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",821,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 822 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRule)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 822, this);
#line 822 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 822 "Frontend/Parser/formula_rewrite.k"
		const tFormula formula = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->tFormula_1;
#line 822 "Frontend/Parser/formula_rewrite.k"
		const integer to = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->integer_1;
#line 822 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = ExpandedBuechiRule(from, formula, to);

#line  4291 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",822,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 823 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_EmptyTransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 823, this);
#line 823 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = EmptyBuechiRules();

#line  4301 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",823,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTransitionRules_1 == tTransitionRules_1))
	return this;
    else {
	impl_tBuechiRules_BuechiRule* kc_result= BuechiRule(l_integer_1, l_tTransitionRules_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_EmptyBuechiRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tTransitionRules impl_tTransitionRules_TransitionRules::rewrite(rview kc_current_view_base)
{
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_2 =
	tTransitionRules_2->rewrite(kc_current_view_base);
    if ((l_tTransitionRules_1 == tTransitionRules_1) &&  (l_tTransitionRules_2 == tTransitionRules_2))
	return this;
    else {
	impl_tTransitionRules_TransitionRules* kc_result= TransitionRules(l_tTransitionRules_1, l_tTransitionRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_TransitionRule::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_tTransitionRules_TransitionRule* kc_result= TransitionRule(l_tFormula_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_EmptyTransitionRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tAcceptingSet impl_tAcceptingSet_AcceptingSet::rewrite(rview kc_current_view_base)
{
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_2 =
	tAcceptingSet_2->rewrite(kc_current_view_base);
    if ((l_tAcceptingSet_1 == tAcceptingSet_1) &&  (l_tAcceptingSet_2 == tAcceptingSet_2))
	return this;
    else {
	impl_tAcceptingSet_AcceptingSet* kc_result= AcceptingSet(l_tAcceptingSet_1, l_tAcceptingSet_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_AcceptingState::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAcceptingSet_AcceptingState* kc_result= AcceptingState(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet::rewrite(rview kc_current_view_base)
{
    return this;

}

net impl_net_Net::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_definitionsList_1 == definitionsList_1) &&  (l_placeblocklist_1 == placeblocklist_1) &&  (l_marking_1 == marking_1) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_net_Net* kc_result= Net(l_casestring_1, l_definitionsList_1, l_placeblocklist_1, l_marking_1, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_DefinitionsList::rewrite(rview kc_current_view_base)
{
    definitionsList l_definitionsList_1 =
	definitionsList_1->rewrite(kc_current_view_base);
    definitions l_definitions_1 =
	definitions_1->rewrite(kc_current_view_base);
    if ((l_definitionsList_1 == definitionsList_1) &&  (l_definitions_1 == definitions_1))
	return this;
    else {
	impl_definitionsList_DefinitionsList* kc_result= DefinitionsList(l_definitionsList_1, l_definitions_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitionsList impl_definitionsList_EmptyDefinitionsList::rewrite(rview kc_current_view_base)
{
    return this;

}

definitions impl_definitions_Function::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_functionParametersList_1 == functionParametersList_1) &&  (l_block_1 == block_1))
	return this;
    else {
	impl_definitions_Function* kc_result= Function(l_type_1, l_casestring_1, l_arrayList_1, l_functionParametersList_1, l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Sort::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_definitions_Sort* kc_result= Sort(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

definitions impl_definitions_Constant::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_definitions_Constant* kc_result= Constant(l_type_1, l_casestring_1, l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBlack::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeArray::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_type_TypeArray* kc_result= TypeArray(l_type_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeMultiset::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_type_TypeMultiset* kc_result= TypeMultiset(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeInt::rewrite(rview kc_current_view_base)
{
    return this;

}

type impl_type_TypeStruct::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1))
	return this;
    else {
	impl_type_TypeStruct* kc_result= TypeStruct(l_structTypeList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIntInterval::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_type_TypeIntInterval* kc_result= TypeIntInterval(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_type_TypeIdent* kc_result= TypeIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeEnum::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1))
	return this;
    else {
	impl_type_TypeEnum* kc_result= TypeEnum(l_identList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

type impl_type_TypeBool::rewrite(rview kc_current_view_base)
{
    return this;

}

optionalNumber impl_optionalNumber_OptNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optionalNumber_OptNumber* kc_result= OptNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optionalNumber impl_optionalNumber_EmptyOptNumber::rewrite(rview kc_current_view_base)
{
    return this;

}

identList impl_identList_IdentList::rewrite(rview kc_current_view_base)
{
    identList l_identList_1 =
	identList_1->rewrite(kc_current_view_base);
    idents l_idents_1 =
	idents_1->rewrite(kc_current_view_base);
    if ((l_identList_1 == identList_1) &&  (l_idents_1 == idents_1))
	return this;
    else {
	impl_identList_IdentList* kc_result= IdentList(l_identList_1, l_idents_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identList impl_identList_EmptyIdentList::rewrite(rview kc_current_view_base)
{
    return this;

}

idents impl_idents_Idents::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    optionalNumber l_optionalNumber_1 =
	optionalNumber_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_optionalNumber_1 == optionalNumber_1))
	return this;
    else {
	impl_idents_Idents* kc_result= Idents(l_casestring_1, l_optionalNumber_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_StructTypeList::rewrite(rview kc_current_view_base)
{
    structTypeList l_structTypeList_1 =
	structTypeList_1->rewrite(kc_current_view_base);
    structType l_structType_1 =
	structType_1->rewrite(kc_current_view_base);
    if ((l_structTypeList_1 == structTypeList_1) &&  (l_structType_1 == structType_1))
	return this;
    else {
	impl_structTypeList_StructTypeList* kc_result= StructTypeList(l_structTypeList_1, l_structType_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

structTypeList impl_structTypeList_EmptyStructTypeList::rewrite(rview kc_current_view_base)
{
    return this;

}

structType impl_structType_StructType::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_structType_StructType* kc_result= StructType(l_type_1, l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArray impl_varOrArray_VarOrArray::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_arrayList_1 == arrayList_1))
	return this;
    else {
	impl_varOrArray_VarOrArray* kc_result= VarOrArray(l_casestring_1, l_arrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_ArrayList::rewrite(rview kc_current_view_base)
{
    arrayList l_arrayList_1 =
	arrayList_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_arrayList_1 == arrayList_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_arrayList_ArrayList* kc_result= ArrayList(l_arrayList_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

arrayList impl_arrayList_EmptyArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParametersList impl_functionParametersList_FunctionParametersList::rewrite(rview kc_current_view_base)
{
    functionParameters l_functionParameters_1 =
	functionParameters_1->rewrite(kc_current_view_base);
    functionParametersList l_functionParametersList_1 =
	functionParametersList_1->rewrite(kc_current_view_base);
    if ((l_functionParameters_1 == functionParameters_1) &&  (l_functionParametersList_1 == functionParametersList_1))
	return this;
    else {
	impl_functionParametersList_FunctionParametersList* kc_result= FunctionParametersList(l_functionParameters_1, l_functionParametersList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

functionParametersList impl_functionParametersList_EmptyFunctionParametersList::rewrite(rview kc_current_view_base)
{
    return this;

}

functionParameters impl_functionParameters_FunctionParameters::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArray_1 == varOrArray_1))
	return this;
    else {
	impl_functionParameters_FunctionParameters* kc_result= FunctionParameters(l_type_1, l_varOrArray_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1))
	return this;
    else {
	impl_expression_ExprAll* kc_result= ExprAll(l_type_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprOtherIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3))
	return this;
    else {
	impl_expression_ExprOtherIf* kc_result= ExprOtherIf(l_expression_1, l_expression_2, l_expression_3);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprCommaSeparated::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_ExprCommaSeparated* kc_result= ExprCommaSeparated(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_FunctionCall::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expression_FunctionCall* kc_result= FunctionCall(l_casestring_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterOrEqual* kc_result= ExprGreaterOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessOrEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessOrEqual* kc_result= ExprLessOrEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprGreaterThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprGreaterThan* kc_result= ExprGreaterThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLessThan::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprLessThan* kc_result= ExprLessThan(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNotEqual::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprNotEqual* kc_result= ExprNotEqual(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprEquivalent::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprEquivalent* kc_result= ExprEquivalent(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprFalse::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprTrue::rewrite(rview kc_current_view_base)
{
    return this;

}

expression impl_expression_ExprOr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprOr* kc_result= ExprOr(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAnd::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAnd* kc_result= ExprAnd(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NotExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NotExpr* kc_result= NotExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprNumber::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_expression_ExprNumber* kc_result= ExprNumber(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprModulo::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprModulo* kc_result= ExprModulo(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprDivision::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprDivision* kc_result= ExprDivision(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprMultiplication::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprMultiplication* kc_result= ExprMultiplication(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprSubtraction::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprSubtraction* kc_result= ExprSubtraction(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprAddition::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2))
	return this;
    else {
	impl_expression_ExprAddition* kc_result= ExprAddition(l_expression_1, l_expression_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_NegativeExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_NegativeExpr* kc_result= NegativeExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_PositiveExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_PositiveExpr* kc_result= PositiveExpr(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValDecrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValDecrement* kc_result= ValDecrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ValIncrement::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ValIncrement* kc_result= ValIncrement(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_DecrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_DecrementVal* kc_result= DecrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_IncrementVal::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_IncrementVal* kc_result= IncrementVal(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMod::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMod* kc_result= AssignMod(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignDivide::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignDivide* kc_result= AssignDivide(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignTimes::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignTimes* kc_result= AssignTimes(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignMinus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignMinus* kc_result= AssignMinus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignPlus::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignPlus* kc_result= AssignPlus(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_AssignEqual::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_expression_AssignEqual* kc_result= AssignEqual(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprInitializerList::rewrite(rview kc_current_view_base)
{
    initializerList l_initializerList_1 =
	initializerList_1->rewrite(kc_current_view_base);
    if ((l_initializerList_1 == initializerList_1))
	return this;
    else {
	impl_expression_ExprInitializerList* kc_result= ExprInitializerList(l_initializerList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expression impl_expression_ExprLeftvalue::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1))
	return this;
    else {
	impl_expression_ExprLeftvalue* kc_result= ExprLeftvalue(l_leftvalue_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValDot::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValDot* kc_result= LeftValDot(l_leftvalue_1, l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValBrackets::rewrite(rview kc_current_view_base)
{
    leftvalue l_leftvalue_1 =
	leftvalue_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_leftvalue_1 == leftvalue_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_leftvalue_LeftValBrackets* kc_result= LeftValBrackets(l_leftvalue_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

leftvalue impl_leftvalue_LeftValIdent::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_leftvalue_LeftValIdent* kc_result= LeftValIdent(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_ExpressionList::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_expressionlist_ExpressionList* kc_result= ExpressionList(l_expression_1, l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionlist impl_expressionlist_EmptyExpressionList::rewrite(rview kc_current_view_base)
{
    return this;

}

initializerList impl_initializerList_ExprInBracesColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_initializerList_ExprInBracesColon* kc_result= ExprInBracesColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

initializerList impl_initializerList_ExprInBraces::rewrite(rview kc_current_view_base)
{
    expressionlist l_expressionlist_1 =
	expressionlist_1->rewrite(kc_current_view_base);
    if ((l_expressionlist_1 == expressionlist_1))
	return this;
    else {
	impl_initializerList_ExprInBraces* kc_result= ExprInBraces(l_expressionlist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_ExpressionListColon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expressionListColon l_expressionListColon_1 =
	expressionListColon_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expressionListColon_1 == expressionListColon_1))
	return this;
    else {
	impl_expressionListColon_ExpressionListColon* kc_result= ExpressionListColon(l_expression_1, l_expression_2, l_expressionListColon_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

expressionListColon impl_expressionListColon_EmptyExpressionListColon::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblocklist impl_placeblocklist_PlaceBlockList::rewrite(rview kc_current_view_base)
{
    placeblock l_placeblock_1 =
	placeblock_1->rewrite(kc_current_view_base);
    placeblocklist l_placeblocklist_1 =
	placeblocklist_1->rewrite(kc_current_view_base);
    if ((l_placeblock_1 == placeblock_1) &&  (l_placeblocklist_1 == placeblocklist_1))
	return this;
    else {
	impl_placeblocklist_PlaceBlockList* kc_result= PlaceBlockList(l_placeblock_1, l_placeblocklist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placeblocklist impl_placeblocklist_EmptyPlaceBlockList::rewrite(rview kc_current_view_base)
{
    return this;

}

optSafe impl_optSafe_Safe::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_optSafe_Safe* kc_result= Safe(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

optSafe impl_optSafe_EmptySafe::rewrite(rview kc_current_view_base)
{
    return this;

}

place impl_place_Place::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1))
	return this;
    else {
	impl_place_Place* kc_result= Place(l_casestring_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_PlaceList::rewrite(rview kc_current_view_base)
{
    place l_place_1 =
	place_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_place_1 == place_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placelist_PlaceList* kc_result= PlaceList(l_place_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

placelist impl_placelist_EmptyPlaceList::rewrite(rview kc_current_view_base)
{
    return this;

}

placeblock impl_placeblock_PlaceBlock::rewrite(rview kc_current_view_base)
{
    optSafe l_optSafe_1 =
	optSafe_1->rewrite(kc_current_view_base);
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    placelist l_placelist_1 =
	placelist_1->rewrite(kc_current_view_base);
    if ((l_optSafe_1 == optSafe_1) &&  (l_type_1 == type_1) &&  (l_placelist_1 == placelist_1))
	return this;
    else {
	impl_placeblock_PlaceBlock* kc_result= PlaceBlock(l_optSafe_1, l_type_1, l_placelist_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_Marking::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    marking l_marking_1 =
	marking_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_marking_1 == marking_1))
	return this;
    else {
	impl_marking_Marking* kc_result= Marking(l_casestring_1, l_expression_1, l_marking_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

marking impl_marking_EmptyMarking::rewrite(rview kc_current_view_base)
{
    return this;

}

transition impl_transition_Transition::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    fairness l_fairness_1 =
	fairness_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    guard l_guard_1 =
	guard_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_2 =
	identExprList_2->rewrite(kc_current_view_base);
    transition l_transition_1 =
	transition_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_fairness_1 == fairness_1) &&  (l_variable_1 == variable_1) &&  (l_guard_1 == guard_1) &&  (l_identExprList_1 == identExprList_1) &&  (l_identExprList_2 == identExprList_2) &&  (l_transition_1 == transition_1))
	return this;
    else {
	impl_transition_Transition* kc_result= Transition(l_casestring_1, l_fairness_1, l_variable_1, l_guard_1, l_identExprList_1, l_identExprList_2, l_transition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

transition impl_transition_EmptyTransition::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_StrongFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_WeakFair::rewrite(rview kc_current_view_base)
{
    return this;

}

fairness impl_fairness_EmptyFairness::rewrite(rview kc_current_view_base)
{
    return this;

}

variable impl_variable_Variable::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    variable l_variable_1 =
	variable_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1) &&  (l_variable_1 == variable_1))
	return this;
    else {
	impl_variable_Variable* kc_result= Variable(l_type_1, l_varOrArrayList_1, l_variable_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

variable impl_variable_EmptyVariable::rewrite(rview kc_current_view_base)
{
    return this;

}

varOrArrayList impl_varOrArrayList_VarOrArrayList::rewrite(rview kc_current_view_base)
{
    varOrArray l_varOrArray_1 =
	varOrArray_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_varOrArray_1 == varOrArray_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_varOrArrayList_VarOrArrayList* kc_result= VarOrArrayList(l_varOrArray_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

varOrArrayList impl_varOrArrayList_EmptyVarOrArrayList::rewrite(rview kc_current_view_base)
{
    return this;

}

guard impl_guard_Guard::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_guard_Guard* kc_result= Guard(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_IdentExprList::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    identExprList l_identExprList_1 =
	identExprList_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_identExprList_1 == identExprList_1))
	return this;
    else {
	impl_identExprList_IdentExprList* kc_result= IdentExprList(l_casestring_1, l_expression_1, l_identExprList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

identExprList impl_identExprList_EmptyIdentExprList::rewrite(rview kc_current_view_base)
{
    return this;

}

block impl_block_Block::rewrite(rview kc_current_view_base)
{
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_block_Block* kc_result= Block(l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemStatement::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemStatement* kc_result= DeclOrStatemStatement(l_statement_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_DeclOrStatemDeclaration::rewrite(rview kc_current_view_base)
{
    declaration l_declaration_1 =
	declaration_1->rewrite(kc_current_view_base);
    declarationOrStatement l_declarationOrStatement_1 =
	declarationOrStatement_1->rewrite(kc_current_view_base);
    if ((l_declaration_1 == declaration_1) &&  (l_declarationOrStatement_1 == declarationOrStatement_1))
	return this;
    else {
	impl_declarationOrStatement_DeclOrStatemDeclaration* kc_result= DeclOrStatemDeclaration(l_declaration_1, l_declarationOrStatement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

declarationOrStatement impl_declarationOrStatement_EmptyDeclarationOrStatement::rewrite(rview kc_current_view_base)
{
    return this;

}

declaration impl_declaration_Declaration::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    varOrArrayList l_varOrArrayList_1 =
	varOrArrayList_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_varOrArrayList_1 == varOrArrayList_1))
	return this;
    else {
	impl_declaration_Declaration* kc_result= Declaration(l_type_1, l_varOrArrayList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementSkip::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementReturn::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementReturn* kc_result= StatementReturn(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementContinue::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementBreak::rewrite(rview kc_current_view_base)
{
    return this;

}

statement impl_statement_StatementSwitch::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_statement_StatementSwitch* kc_result= StatementSwitch(l_expression_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForAll::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    type l_type_2 =
	type_2->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_type_2 == type_2))
	return this;
    else {
	impl_statement_StatementForAll* kc_result= StatementForAll(l_type_1, l_casestring_1, l_type_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForIdentColon::rewrite(rview kc_current_view_base)
{
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForIdentColon* kc_result= StatementForIdentColon(l_casestring_1, l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForTypeExpr::rewrite(rview kc_current_view_base)
{
    type l_type_1 =
	type_1->rewrite(kc_current_view_base);
    casestring l_casestring_1 =
	casestring_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_type_1 == type_1) &&  (l_casestring_1 == casestring_1) &&  (l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForTypeExpr* kc_result= StatementForTypeExpr(l_type_1, l_casestring_1, l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementForExpr::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    expression l_expression_2 =
	expression_2->rewrite(kc_current_view_base);
    expression l_expression_3 =
	expression_3->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_expression_2 == expression_2) &&  (l_expression_3 == expression_3) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementForExpr* kc_result= StatementForExpr(l_expression_1, l_expression_2, l_expression_3, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementDoWhile::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1) &&  (l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementDoWhile* kc_result= StatementDoWhile(l_statement_1, l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementWhile::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_statement_StatementWhile* kc_result= StatementWhile(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementIf::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    statement l_statement_2 =
	statement_2->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1) &&  (l_statement_2 == statement_2))
	return this;
    else {
	impl_statement_StatementIf* kc_result= StatementIf(l_expression_1, l_statement_1, l_statement_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementExprSemicolon::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1))
	return this;
    else {
	impl_statement_StatementExprSemicolon* kc_result= StatementExprSemicolon(l_expression_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

statement impl_statement_StatementBlock::rewrite(rview kc_current_view_base)
{
    block l_block_1 =
	block_1->rewrite(kc_current_view_base);
    if ((l_block_1 == block_1))
	return this;
    else {
	impl_statement_StatementBlock* kc_result= StatementBlock(l_block_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchDefault::rewrite(rview kc_current_view_base)
{
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchDefault* kc_result= SwitchDefault(l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCase impl_switchCase_SwitchCase::rewrite(rview kc_current_view_base)
{
    expression l_expression_1 =
	expression_1->rewrite(kc_current_view_base);
    statement l_statement_1 =
	statement_1->rewrite(kc_current_view_base);
    if ((l_expression_1 == expression_1) &&  (l_statement_1 == statement_1))
	return this;
    else {
	impl_switchCase_SwitchCase* kc_result= SwitchCase(l_expression_1, l_statement_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_SwitchCaseList::rewrite(rview kc_current_view_base)
{
    switchCase l_switchCase_1 =
	switchCase_1->rewrite(kc_current_view_base);
    switchCaseList l_switchCaseList_1 =
	switchCaseList_1->rewrite(kc_current_view_base);
    if ((l_switchCase_1 == switchCase_1) &&  (l_switchCaseList_1 == switchCaseList_1))
	return this;
    else {
	impl_switchCaseList_SwitchCaseList* kc_result= SwitchCaseList(l_switchCase_1, l_switchCaseList_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

switchCaseList impl_switchCaseList_EmptySwitchCaseList::rewrite(rview kc_current_view_base)
{
    return this;

}

} // namespace kc
