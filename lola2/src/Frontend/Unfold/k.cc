/* translation of file(s)
	"abstract.k"
	"unparse.k"
	"rewrite.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.11 (C) 1998-2007 Humboldt-University of Berlin $
 */
#define KC_TYPES

#include "k.h"
#include <stdio.h>
#include <ctype.h>
#include <cstring>
#include <sys/types.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma warning( disable : 4786 )
#endif
#include <new>
#include <set>
#include <list>
#include <algorithm>

#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \
&& !defined(DONT_USE_HASHSET)
#  define USE_HASHSET
#endif
#ifdef USE_HASHSET
#  if defined(__GNUC__) && __GNUC__>2
#    include <ext/hash_set>
#  else
#    include <hash_set>
#  endif
#endif

using namespace std;

namespace kc {

inline bool
ht_less(casestring p1, casestring p2){
    return kc_strcmp(p1->name, p2->name)<0;
}

inline bool
ht_less(nocasestring p1, nocasestring p2){
    return kc_strcasecmp(p1->name, p2->name)<0;
}

inline bool
ht_less(real p1, real p2){
    return p1->value < p2->value;
}

inline bool
ht_less(integer p1, integer p2){
    return p1->value < p2->value;
}

inline bool
ht_less(voidptr p1, voidptr p2){
    return p1->pointer < p2->pointer;
}

bool
ht_less(abstract_phylum p1, abstract_phylum p2)
{
    enum_operators prod_sel=p1->prod_sel();
    enum_operators prod_sel2=p2->prod_sel();
    if(prod_sel<prod_sel2)
	return true;
    if(prod_sel>prod_sel2)
	return false;
    switch(prod_sel) {
	case sel_NoCaseStr:
	    return ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));
	case sel__Str:
	    return ht_less(static_cast<casestring>(p1),static_cast<casestring>(p2));
	case sel__Real:
	    return ht_less(static_cast<real>(p1),static_cast<real>(p2));
	case sel__Int:
	    return ht_less(static_cast<integer>(p1),static_cast<integer>(p2));
	case sel__VoidPtr:
	    return ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));
	default: {
	    int i=0;
	    bool still_unique = kc_storageclass_still_uniq[phylum_info[p1->phylum()].uniq_stored];
	    abstract_phylum sub1=0;
	    do {
		sub1=p1->subphylum(i);
		abstract_phylum sub2=p2->subphylum(i);
		if(still_unique) {
		    if(sub1<sub2)
			return true;
		    if(sub2<sub1)
			return false;
		}
		else {
		    if(ht_less(sub1, sub2))
			return true;
		    if(ht_less(sub2, sub1))
			return false;
		}
		++i;
	    } while(sub1);
	}
    }
    return false;
}

template<typename T>
class phylum_less : std::binary_function<T, T, bool>
{
    public:
    bool operator()(const T& X, const T& Y) const
	{ return ht_less(X,Y); }
};

inline void deletefun(c_abstract_phylum t){
    delete const_cast<abstract_phylum>(t);
}


#ifdef USE_HASHSET
struct hashitem {
    size_t hashvalue;
    casestring contents;
    hashitem(casestring cs): contents(cs) {
	unsigned long h = 0;
	kc_char_t const *s = cs->name;
	for ( ; *s; ++s)
	    h = 5*h + *s;
	hashvalue=(size_t)h;
    }
};

inline void deletefunhashitem(hashitem t) {
    delete t.contents;
}

#  ifdef __GNUC__
struct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) == 0; } };

struct hash_hashitem { size_t operator()(hashitem hi) const {
	return hi.hashvalue; } };

#  else
struct comp_hashitem {
    enum { bucket_size = 4, min_buckets = 8 };
    // bucket_size and min_buckets are just guesses
    size_t operator()(const hashitem hi) const {
	return hi.hashvalue; }
    bool operator()(const hashitem hi1, const hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }
};
#  endif // Whether gcc or icc
#endif // Whether hash or not

struct hashtable_level
{
    hashtable_level(bool cod = true): clean_on_destruction(cod) { }
    void clear(bool free_entries=true) {
	if(free_entries)
	    clear_entries();
	_casestring.clear();
	_nocasestring.clear();
	_integer.clear();
	_real.clear();
	_voidptr.clear();
	_abstract_phylum.clear();
    }
    void clear_entries() {
#ifdef USE_HASHSET
	std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);
#else
	std::for_each(_casestring.begin(),_casestring.end(),deletefun);
#endif
	std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);
	std::for_each(_integer.begin(),_integer.end(),deletefun);
	std::for_each(_real.begin(),_real.end(),deletefun);
	std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);
	std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletefun);
    }
    ~hashtable_level() {
	clear(clean_on_destruction);
    }
    abstract_phylum check_insert(abstract_phylum t) {
	return *_abstract_phylum.insert(t).first;
    }
    casestring check_insert(casestring t) {
#ifdef USE_HASHSET
	return (*_casestring.insert(hashitem(t)).first).contents;
#else
	return *_casestring.insert(t).first;
#endif
    }
    nocasestring check_insert(nocasestring t) {
	return *_nocasestring.insert(t).first;
    }
    integer check_insert(integer t) {
	return *_integer.insert(t).first;
    }
    real check_insert(real t) {
	return *_real.insert(t).first;
    }
    voidptr check_insert(voidptr t) {
	return *_voidptr.insert(t).first;
    }
private:
    bool clean_on_destruction;
#ifdef USE_HASHSET
#  ifdef __GNUC__
#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)
    std::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    else
    __gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    endif
#  else
    std::hash_set<hashitem, comp_hashitem> _casestring;
#  endif
#else
    std::set<casestring, phylum_less<casestring> > _casestring;
#endif
    std::set<nocasestring, phylum_less<nocasestring> > _nocasestring;
    std::set<integer, phylum_less<integer> > _integer;
    std::set<real, phylum_less<real> > _real;
    std::set<voidptr, phylum_less<voidptr> > _voidptr;
    std::set<abstract_phylum, phylum_less<abstract_phylum> > _abstract_phylum;
};

class hashtable_stack: public std::list<hashtable_level> {
public:
    hashtable_stack(): _pos(begin()) { }

    void inc_level() { _pos=insert(_pos, hashtable_level()); }
    void dec_level() { if(valid() && _pos!=end()) ++_pos; }
    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }

    bool valid() const { return !empty(); }
    hashtable_level& get_level() { return *_pos; }

    template<typename T>
    T check_insert(T t) {
	return dynamic_cast<T>((*_pos).check_insert(t));
    }
private:
    iterator _pos;
};

class hashtable_struct_t {
public:
    // don't clean _static_level on destruction (program ends)
    hashtable_struct_t(): _static_level(false), _to_be_freed(false),  _dynamic(false) { }

    template <typename T>
    T ht_check_insert(T t) {
	if(_dynamic && _dynamic_level.valid())
	    return _dynamic_level.check_insert(t);
	else
	    return dynamic_cast<T>(_static_level.check_insert(t));
    }
    void ht_static() {_dynamic=false; }
    void ht_dynamic() {
	_dynamic=true;
	if(!_dynamic_level.valid())
	    _dynamic_level.inc_level();
    }
    void ht_inc_level() { _dynamic_level.inc_level(); }
    void ht_dec_level() { _dynamic_level.dec_level(); }
    void ht_free_level() { _dynamic_level.free_level(); }
    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }

    bool to_be_freed() { return _to_be_freed; }
    void set_to_be_freed(bool b=true) { _to_be_freed=b; }
private:
    hashtable_level _static_level;
    hashtable_stack _dynamic_level;
    bool _to_be_freed; /* should be true for dynamic, false for statically allocated structures */
    bool _dynamic;
};

impl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }
void impl_nocasestring_NoCaseStr::make_own(int length) {
    kc_char_t *newname=new kc_char_t[length+1];
    for (int i=0; i < length && name[i]; ++i)
    newname[i] = kc_tolower(name[i]);
    newname[length]=0;
    name=newname;
}

impl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }
void impl_casestring__Str::make_own(int length) {
    kc_char_t *newname=kc_strncpy(new kc_char_t[length+1],name,length);
    newname[length]=0;
    name=newname;
}
abstract_phylum impl_switchCaseList_SwitchDefaultList::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_switchCaseList_SwitchCaseList::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
	case 2: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_switchCase_SwitchDefault::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_switchCase_SwitchCase::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
	case 2: return switchCaseList_1;
    }
    return 0;
}
abstract_phylum impl_optElse_OptElse::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
    }
    return 0;
}
abstract_phylum impl_ifStatement_IfStatement::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
	case 2: return optElse_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementReturn::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementSwitch::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return switchCase_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForAll::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return type_2;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForIdentColon::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForTypeExpr::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return expression_1;
	case 3: return expression_2;
	case 4: return expression_3;
	case 5: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementForExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expression_3;
	case 3: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementDoWhile::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementWhile::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return statement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementIf::subphylum(int no) const
{
    switch(no){
	case 0: return ifStatement_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementExprSemicolon::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
    }
    return 0;
}
abstract_phylum impl_statement_StatementBlock::subphylum(int no) const
{
    switch(no){
	case 0: return block_1;
    }
    return 0;
}
abstract_phylum impl_declaration_Declaration::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArray_1;
	case 2: return varOrArrayList_1;
    }
    return 0;
}
abstract_phylum impl_declarationOrStatement_DeclOrStatemStatement::subphylum(int no) const
{
    switch(no){
	case 0: return statement_1;
	case 1: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_declarationOrStatement_DeclOrStatemDeclaration::subphylum(int no) const
{
    switch(no){
	case 0: return declaration_1;
	case 1: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_block_Block::subphylum(int no) const
{
    switch(no){
	case 0: return declarationOrStatement_1;
    }
    return 0;
}
abstract_phylum impl_identExprList_IdentExprList::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return identExprList_1;
    }
    return 0;
}
abstract_phylum impl_optIdentExprList_OptIdentExprList::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return identExprList_1;
    }
    return 0;
}
abstract_phylum impl_guard_Guard::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_varOrArrayList_VarOrArrayList::subphylum(int no) const
{
    switch(no){
	case 0: return varOrArray_1;
	case 1: return varOrArrayList_1;
    }
    return 0;
}
abstract_phylum impl_variable_Variable::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArray_1;
	case 2: return varOrArrayList_1;
	case 3: return variable_1;
    }
    return 0;
}
abstract_phylum impl_transition_Transition::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return fairness_1;
	case 2: return variable_1;
	case 3: return guard_1;
	case 4: return optIdentExprList_1;
	case 5: return optIdentExprList_2;
	case 6: return transition_1;
    }
    return 0;
}
abstract_phylum impl_markingList_MarkingList::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return markingList_1;
    }
    return 0;
}
abstract_phylum impl_marking_Marking::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
	case 2: return markingList_1;
    }
    return 0;
}
abstract_phylum impl_morePlaces_MorePlaces::subphylum(int no) const
{
    switch(no){
	case 0: return optSafe_1;
	case 1: return optType_1;
	case 2: return place_1;
	case 3: return commaPlaces_1;
	case 4: return morePlaces_1;
    }
    return 0;
}
abstract_phylum impl_commaPlaces_CommaPlaces::subphylum(int no) const
{
    switch(no){
	case 0: return optType_1;
	case 1: return place_1;
	case 2: return commaPlaces_1;
    }
    return 0;
}
abstract_phylum impl_place_PlaceWithTypeIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return casestring_2;
    }
    return 0;
}
abstract_phylum impl_place_Place::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_optType_PlaceTypeMultiset::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_optType_PlaceTypeStruct::subphylum(int no) const
{
    switch(no){
	case 0: return structTypeList_1;
    }
    return 0;
}
abstract_phylum impl_optType_PlaceTypeIntInterval::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_optType_PlaceTypeEnum::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return integer_1;
	case 2: return identList_1;
    }
    return 0;
}
abstract_phylum impl_optNumber_PlaceNumber::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_optSafe_Safe::subphylum(int no) const
{
    switch(no){
	case 0: return optNumber_1;
    }
    return 0;
}
abstract_phylum impl_places_Places::subphylum(int no) const
{
    switch(no){
	case 0: return optSafe_1;
	case 1: return optType_1;
	case 2: return place_1;
	case 3: return commaPlaces_1;
	case 4: return morePlaces_1;
    }
    return 0;
}
abstract_phylum impl_expressionListColon_ExpressionListColon::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expressionListColon_1;
    }
    return 0;
}
abstract_phylum impl_initializerList_ExprInBracesColon::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expressionListColon_1;
    }
    return 0;
}
abstract_phylum impl_initializerList_ExprInBraces::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_otherWithoutInitializer_ExprAll2::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
	case 2: return expression_2;
    }
    return 0;
}
abstract_phylum impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_otherWithoutInitializer_ExprIdentExprInParenthesis2::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_otherWithoutInitializer_ExprIdentParenthesis2::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_other_ExprAll::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_other_ExprOtherIf::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
	case 2: return expression_3;
    }
    return 0;
}
abstract_phylum impl_other_ExprCommaSeparated::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_other_ExprIdentExprInParenthesis::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_other_ExprIdentParenthesis::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValDot::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValBrackets::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_leftvalue_LeftValIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprGreaterOrEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprLessOrEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprGreaterThan::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprLessThan::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprNotEqual::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_comparison_ExprEquivalent::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_logicalWithoutInitializer_ExprOrWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_logicalWithoutInitializer_ExprAndWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_logicalWithoutInitializer_NotExpr2::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_logical_ExprOr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_logical_ExprAnd::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_logical_NotExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprNumber2::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return expressionWithoutInitializer_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_NegativeExpr2::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmeticWithoutInitializer_PositiveExpr2::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprNumber::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprModulo::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprDivision::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprMultiplication::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprSubtraction::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_arithmetic_ExprAddition::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_arithmetic_NegativeExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arithmetic_PositiveExpr::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_incdecrement_ValDecrement::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_incdecrement_ValIncrement::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_incdecrement_DecrementVal::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_incdecrement_IncrementVal::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignMod::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignDivide::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignTimes::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignMinus::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignPlus::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_assignment_AssignEqual::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
	case 1: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprInParenthesis2::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprOtherWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return otherWithoutInitializer_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprLeftvalue2::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return comparisonWithoutInitializer_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return logicalWithoutInitializer_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer::subphylum(int no) const
{
    switch(no){
	case 0: return arithmeticWithoutInitializer_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprIncdecrement2::subphylum(int no) const
{
    switch(no){
	case 0: return incdecrement_1;
    }
    return 0;
}
abstract_phylum impl_expressionWithoutInitializer_ExprAssignment2::subphylum(int no) const
{
    switch(no){
	case 0: return assignment_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprInParenthesis::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprInitializerList::subphylum(int no) const
{
    switch(no){
	case 0: return initializerList_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprOther::subphylum(int no) const
{
    switch(no){
	case 0: return other_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprLeftvalue::subphylum(int no) const
{
    switch(no){
	case 0: return leftvalue_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprComparison::subphylum(int no) const
{
    switch(no){
	case 0: return comparison_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprLogical::subphylum(int no) const
{
    switch(no){
	case 0: return logical_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprArithmetic::subphylum(int no) const
{
    switch(no){
	case 0: return arithmetic_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprIncdecrement::subphylum(int no) const
{
    switch(no){
	case 0: return incdecrement_1;
    }
    return 0;
}
abstract_phylum impl_expression_ExprAssignment::subphylum(int no) const
{
    switch(no){
	case 0: return assignment_1;
    }
    return 0;
}
abstract_phylum impl_constant_Constant::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
	case 3: return expression_1;
    }
    return 0;
}
abstract_phylum impl_functionParameters_FunctionParameters::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArray_1;
    }
    return 0;
}
abstract_phylum impl_functionParametersList_FunctionParametersList::subphylum(int no) const
{
    switch(no){
	case 0: return functionParametersList_1;
	case 1: return functionParameters_1;
    }
    return 0;
}
abstract_phylum impl_optFunctionParameters_OptFunctionParameters::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return varOrArray_1;
	case 2: return functionParametersList_1;
    }
    return 0;
}
abstract_phylum impl_function_Function::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
	case 3: return optFunctionParameters_1;
	case 4: return block_1;
    }
    return 0;
}
abstract_phylum impl_array_Array::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
    }
    return 0;
}
abstract_phylum impl_arrayList_ArrayList::subphylum(int no) const
{
    switch(no){
	case 0: return arrayList_1;
	case 1: return array_1;
    }
    return 0;
}
abstract_phylum impl_varOrArray_VarOrArray::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_structType_StructType::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_structTypeList_StructTypeList::subphylum(int no) const
{
    switch(no){
	case 0: return structTypeList_1;
	case 1: return structType_1;
    }
    return 0;
}
abstract_phylum impl_structTypeList_SingleStructTypeList::subphylum(int no) const
{
    switch(no){
	case 0: return structType_1;
    }
    return 0;
}
abstract_phylum impl_idents_Ident::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
	case 1: return integer_1;
    }
    return 0;
}
abstract_phylum impl_identList_IdentList::subphylum(int no) const
{
    switch(no){
	case 0: return identList_1;
	case 1: return idents_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeMultiset::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeStruct::subphylum(int no) const
{
    switch(no){
	case 0: return structTypeList_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeIntInterval::subphylum(int no) const
{
    switch(no){
	case 0: return expression_1;
	case 1: return expression_2;
    }
    return 0;
}
abstract_phylum impl_type_TypeIdent::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_type_TypeEnum::subphylum(int no) const
{
    switch(no){
	case 0: return identList_1;
    }
    return 0;
}
abstract_phylum impl_sort_Sort::subphylum(int no) const
{
    switch(no){
	case 0: return type_1;
	case 1: return casestring_1;
	case 2: return arrayList_1;
    }
    return 0;
}
abstract_phylum impl_definitions_DefConstant::subphylum(int no) const
{
    switch(no){
	case 0: return constant_1;
    }
    return 0;
}
abstract_phylum impl_definitions_DefFunction::subphylum(int no) const
{
    switch(no){
	case 0: return function_1;
    }
    return 0;
}
abstract_phylum impl_definitions_DefSort::subphylum(int no) const
{
    switch(no){
	case 0: return sort_1;
    }
    return 0;
}
abstract_phylum impl_definitionsList_DefinitionsList::subphylum(int no) const
{
    switch(no){
	case 0: return definitionsList_1;
	case 1: return definitions_1;
    }
    return 0;
}
abstract_phylum impl_netName_NetName::subphylum(int no) const
{
    switch(no){
	case 0: return casestring_1;
    }
    return 0;
}
abstract_phylum impl_net_Net::subphylum(int no) const
{
    switch(no){
	case 0: return netName_1;
	case 1: return definitionsList_1;
	case 2: return places_1;
	case 3: return marking_1;
	case 4: return transition_1;
    }
    return 0;
}
void impl_switchCaseList_SwitchDefaultList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_switchCaseList_SwitchCaseList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 2: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_switchCase_SwitchDefault::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_switchCase_SwitchCase::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 2: newval = switchCaseList_1 = dynamic_cast<switchCaseList>(val);break;
    }
    assertNonNull(newval);
}
void impl_optElse_OptElse::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_ifStatement_IfStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 2: newval = optElse_1 = dynamic_cast<optElse>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementReturn::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementSwitch::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = switchCase_1 = dynamic_cast<switchCase>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForAll::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = type_2 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForIdentColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForTypeExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 3: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 4: newval = expression_3 = dynamic_cast<expression>(val);break;
	case 5: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementForExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_3 = dynamic_cast<expression>(val);break;
	case 3: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementDoWhile::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementWhile::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = statement_1 = dynamic_cast<statement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementIf::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = ifStatement_1 = dynamic_cast<ifStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementExprSemicolon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
    }
    assertNonNull(newval);
}
void impl_statement_StatementBlock::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}
void impl_declaration_Declaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
	case 2: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_declarationOrStatement_DeclOrStatemStatement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = statement_1 = dynamic_cast<statement>(val);break;
	case 1: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_declarationOrStatement_DeclOrStatemDeclaration::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declaration_1 = dynamic_cast<declaration>(val);break;
	case 1: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_block_Block::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = declarationOrStatement_1 = dynamic_cast<declarationOrStatement>(val);break;
    }
    assertNonNull(newval);
}
void impl_identExprList_IdentExprList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = identExprList_1 = dynamic_cast<identExprList>(val);break;
    }
    assertNonNull(newval);
}
void impl_optIdentExprList_OptIdentExprList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = identExprList_1 = dynamic_cast<identExprList>(val);break;
    }
    assertNonNull(newval);
}
void impl_guard_Guard::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_varOrArrayList_VarOrArrayList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
	case 1: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_variable_Variable::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
	case 2: newval = varOrArrayList_1 = dynamic_cast<varOrArrayList>(val);break;
	case 3: newval = variable_1 = dynamic_cast<variable>(val);break;
    }
    assertNonNull(newval);
}
void impl_transition_Transition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = fairness_1 = dynamic_cast<fairness>(val);break;
	case 2: newval = variable_1 = dynamic_cast<variable>(val);break;
	case 3: newval = guard_1 = dynamic_cast<guard>(val);break;
	case 4: newval = optIdentExprList_1 = dynamic_cast<optIdentExprList>(val);break;
	case 5: newval = optIdentExprList_2 = dynamic_cast<optIdentExprList>(val);break;
	case 6: newval = transition_1 = dynamic_cast<transition>(val);break;
    }
    assertNonNull(newval);
}
void impl_markingList_MarkingList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = markingList_1 = dynamic_cast<markingList>(val);break;
    }
    assertNonNull(newval);
}
void impl_marking_Marking::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = markingList_1 = dynamic_cast<markingList>(val);break;
    }
    assertNonNull(newval);
}
void impl_morePlaces_MorePlaces::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = optSafe_1 = dynamic_cast<optSafe>(val);break;
	case 1: newval = optType_1 = dynamic_cast<optType>(val);break;
	case 2: newval = place_1 = dynamic_cast<place>(val);break;
	case 3: newval = commaPlaces_1 = dynamic_cast<commaPlaces>(val);break;
	case 4: newval = morePlaces_1 = dynamic_cast<morePlaces>(val);break;
    }
    assertNonNull(newval);
}
void impl_commaPlaces_CommaPlaces::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = optType_1 = dynamic_cast<optType>(val);break;
	case 1: newval = place_1 = dynamic_cast<place>(val);break;
	case 2: newval = commaPlaces_1 = dynamic_cast<commaPlaces>(val);break;
    }
    assertNonNull(newval);
}
void impl_place_PlaceWithTypeIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = casestring_2 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_place_Place::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_optType_PlaceTypeMultiset::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_optType_PlaceTypeStruct::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structTypeList_1 = dynamic_cast<structTypeList>(val);break;
    }
    assertNonNull(newval);
}
void impl_optType_PlaceTypeIntInterval::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_optType_PlaceTypeEnum::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 2: newval = identList_1 = dynamic_cast<identList>(val);break;
    }
    assertNonNull(newval);
}
void impl_optNumber_PlaceNumber::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_optSafe_Safe::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = optNumber_1 = dynamic_cast<optNumber>(val);break;
    }
    assertNonNull(newval);
}
void impl_places_Places::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = optSafe_1 = dynamic_cast<optSafe>(val);break;
	case 1: newval = optType_1 = dynamic_cast<optType>(val);break;
	case 2: newval = place_1 = dynamic_cast<place>(val);break;
	case 3: newval = commaPlaces_1 = dynamic_cast<commaPlaces>(val);break;
	case 4: newval = morePlaces_1 = dynamic_cast<morePlaces>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionListColon_ExpressionListColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expressionListColon_1 = dynamic_cast<expressionListColon>(val);break;
    }
    assertNonNull(newval);
}
void impl_initializerList_ExprInBracesColon::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expressionListColon_1 = dynamic_cast<expressionListColon>(val);break;
    }
    assertNonNull(newval);
}
void impl_initializerList_ExprInBraces::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_otherWithoutInitializer_ExprAll2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_otherWithoutInitializer_ExprIdentExprInParenthesis2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_otherWithoutInitializer_ExprIdentParenthesis2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_other_ExprAll::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_other_ExprOtherIf::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
	case 2: newval = expression_3 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_other_ExprCommaSeparated::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_other_ExprIdentExprInParenthesis::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_other_ExprIdentParenthesis::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValDot::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValBrackets::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_leftvalue_LeftValIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprGreaterOrEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprLessOrEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprGreaterThan::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprLessThan::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprNotEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_comparison_ExprEquivalent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logicalWithoutInitializer_ExprOrWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logicalWithoutInitializer_ExprAndWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logicalWithoutInitializer_NotExpr2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logical_ExprOr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logical_ExprAnd::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_logical_NotExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprNumber2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expressionWithoutInitializer_1 = dynamic_cast<expressionWithoutInitializer>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_NegativeExpr2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmeticWithoutInitializer_PositiveExpr2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprNumber::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprModulo::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprDivision::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprMultiplication::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprSubtraction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_ExprAddition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_NegativeExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arithmetic_PositiveExpr::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_incdecrement_ValDecrement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_incdecrement_ValIncrement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_incdecrement_DecrementVal::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_incdecrement_IncrementVal::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignMod::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignDivide::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignTimes::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignMinus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignPlus::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_assignment_AssignEqual::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
	case 1: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprInParenthesis2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprOtherWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = otherWithoutInitializer_1 = dynamic_cast<otherWithoutInitializer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprLeftvalue2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = comparisonWithoutInitializer_1 = dynamic_cast<comparisonWithoutInitializer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = logicalWithoutInitializer_1 = dynamic_cast<logicalWithoutInitializer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = arithmeticWithoutInitializer_1 = dynamic_cast<arithmeticWithoutInitializer>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprIncdecrement2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = incdecrement_1 = dynamic_cast<incdecrement>(val);break;
    }
    assertNonNull(newval);
}
void impl_expressionWithoutInitializer_ExprAssignment2::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = assignment_1 = dynamic_cast<assignment>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprInParenthesis::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprInitializerList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = initializerList_1 = dynamic_cast<initializerList>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprOther::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = other_1 = dynamic_cast<other>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprLeftvalue::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = leftvalue_1 = dynamic_cast<leftvalue>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprComparison::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = comparison_1 = dynamic_cast<comparison>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprLogical::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = logical_1 = dynamic_cast<logical>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprArithmetic::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = arithmetic_1 = dynamic_cast<arithmetic>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprIncdecrement::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = incdecrement_1 = dynamic_cast<incdecrement>(val);break;
    }
    assertNonNull(newval);
}
void impl_expression_ExprAssignment::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = assignment_1 = dynamic_cast<assignment>(val);break;
    }
    assertNonNull(newval);
}
void impl_constant_Constant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 3: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_functionParameters_FunctionParameters::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
    }
    assertNonNull(newval);
}
void impl_functionParametersList_FunctionParametersList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = functionParametersList_1 = dynamic_cast<functionParametersList>(val);break;
	case 1: newval = functionParameters_1 = dynamic_cast<functionParameters>(val);break;
    }
    assertNonNull(newval);
}
void impl_optFunctionParameters_OptFunctionParameters::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = varOrArray_1 = dynamic_cast<varOrArray>(val);break;
	case 2: newval = functionParametersList_1 = dynamic_cast<functionParametersList>(val);break;
    }
    assertNonNull(newval);
}
void impl_function_Function::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 3: newval = optFunctionParameters_1 = dynamic_cast<optFunctionParameters>(val);break;
	case 4: newval = block_1 = dynamic_cast<block>(val);break;
    }
    assertNonNull(newval);
}
void impl_array_Array::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_arrayList_ArrayList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
	case 1: newval = array_1 = dynamic_cast<array>(val);break;
    }
    assertNonNull(newval);
}
void impl_varOrArray_VarOrArray::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_structType_StructType::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_structTypeList_StructTypeList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structTypeList_1 = dynamic_cast<structTypeList>(val);break;
	case 1: newval = structType_1 = dynamic_cast<structType>(val);break;
    }
    assertNonNull(newval);
}
void impl_structTypeList_SingleStructTypeList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structType_1 = dynamic_cast<structType>(val);break;
    }
    assertNonNull(newval);
}
void impl_idents_Ident::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 1: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_identList_IdentList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = identList_1 = dynamic_cast<identList>(val);break;
	case 1: newval = idents_1 = dynamic_cast<idents>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeMultiset::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeStruct::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = structTypeList_1 = dynamic_cast<structTypeList>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeIntInterval::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = expression_1 = dynamic_cast<expression>(val);break;
	case 1: newval = expression_2 = dynamic_cast<expression>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeIdent::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_type_TypeEnum::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = identList_1 = dynamic_cast<identList>(val);break;
    }
    assertNonNull(newval);
}
void impl_sort_Sort::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = type_1 = dynamic_cast<type>(val);break;
	case 1: newval = casestring_1 = dynamic_cast<casestring>(val);break;
	case 2: newval = arrayList_1 = dynamic_cast<arrayList>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_DefConstant::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = constant_1 = dynamic_cast<constant>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_DefFunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = function_1 = dynamic_cast<function>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitions_DefSort::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = sort_1 = dynamic_cast<sort>(val);break;
    }
    assertNonNull(newval);
}
void impl_definitionsList_DefinitionsList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = definitionsList_1 = dynamic_cast<definitionsList>(val);break;
	case 1: newval = definitions_1 = dynamic_cast<definitions>(val);break;
    }
    assertNonNull(newval);
}
void impl_netName_NetName::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = casestring_1 = dynamic_cast<casestring>(val);break;
    }
    assertNonNull(newval);
}
void impl_net_Net::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = netName_1 = dynamic_cast<netName>(val);break;
	case 1: newval = definitionsList_1 = dynamic_cast<definitionsList>(val);break;
	case 2: newval = places_1 = dynamic_cast<places>(val);break;
	case 3: newval = marking_1 = dynamic_cast<marking>(val);break;
	case 4: newval = transition_1 = dynamic_cast<transition>(val);break;
    }
    assertNonNull(newval);
}

void
copy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)
{
    switch(copyPhy) {
    case phylum_expression: {
	c_expression p1 = dynamic_cast<c_expression>(kc_p1);
	expression p2 = dynamic_cast<expression>(kc_p2);
	p2->check = p1->check;
	p2->isConst = p1->isConst;
	p2->constValue = p1->constValue;
	break;
    }
    case phylum_expressionWithoutInitializer:
	dynamic_cast<expressionWithoutInitializer>(kc_p2)->check = dynamic_cast<c_expressionWithoutInitializer>(kc_p1)->check;
	break;
    case phylum_assignment:
	dynamic_cast<assignment>(kc_p2)->check = dynamic_cast<c_assignment>(kc_p1)->check;
	break;
    case phylum_arithmetic:
	dynamic_cast<arithmetic>(kc_p2)->check = dynamic_cast<c_arithmetic>(kc_p1)->check;
	break;
    case phylum_arithmeticWithoutInitializer:
	dynamic_cast<arithmeticWithoutInitializer>(kc_p2)->check = dynamic_cast<c_arithmeticWithoutInitializer>(kc_p1)->check;
	break;
    case phylum_logical:
	dynamic_cast<logical>(kc_p2)->check = dynamic_cast<c_logical>(kc_p1)->check;
	break;
    case phylum_logicalWithoutInitializer:
	dynamic_cast<logicalWithoutInitializer>(kc_p2)->check = dynamic_cast<c_logicalWithoutInitializer>(kc_p1)->check;
	break;
    case phylum_comparison:
	dynamic_cast<comparison>(kc_p2)->check = dynamic_cast<c_comparison>(kc_p1)->check;
	break;
    case phylum_comparisonWithoutInitializer:
	dynamic_cast<comparisonWithoutInitializer>(kc_p2)->check = dynamic_cast<c_comparisonWithoutInitializer>(kc_p1)->check;
	break;
    case phylum_other:
	dynamic_cast<other>(kc_p2)->check = dynamic_cast<c_other>(kc_p1)->check;
	break;
    case phylum_otherWithoutInitializer:
	dynamic_cast<otherWithoutInitializer>(kc_p2)->check = dynamic_cast<c_otherWithoutInitializer>(kc_p1)->check;
	break;
    case one_before_first_phylum: // just to avoid a warning about missing case if empty
    default:
	break; // it's alright, no attributes to copy
    }
    enum_operators copyOp=kc_p1->prod_sel();
    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)
	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);
}

KC_PHYLUM_INFO phylum_info[] = {
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */
    { "nocasestring", sel_NoCaseStr, sel_NoCaseStr, uniq },
    { "casestring", sel__Str, sel__Str, uniq },
    { "real", sel__Real, sel__Real, uniq },
    { "integer", sel__Int, sel__Int, uniq },
    { "voidptr", sel__VoidPtr, sel__VoidPtr, uniq },
    { "net", sel_Net, sel_Net, kc_not_uniq },
    { "netName", sel_EmptyNetName, sel_NetName, kc_not_uniq },
    { "definitionsList", sel_EmptyDefinitionsList, sel_DefinitionsList, kc_not_uniq },
    { "definitions", sel_DefSort, sel_DefConstant, kc_not_uniq },
    { "sort", sel_Sort, sel_Sort, kc_not_uniq },
    { "type", sel_TypeBool, sel_TypeMultiset, kc_not_uniq },
    { "identList", sel_EmptyIdentList, sel_IdentList, kc_not_uniq },
    { "idents", sel_Ident, sel_Ident, kc_not_uniq },
    { "structTypeList", sel_SingleStructTypeList, sel_StructTypeList, kc_not_uniq },
    { "structType", sel_StructType, sel_StructType, kc_not_uniq },
    { "varOrArray", sel_VarOrArray, sel_VarOrArray, kc_not_uniq },
    { "arrayList", sel_EmptyArrayList, sel_ArrayList, kc_not_uniq },
    { "array", sel_Array, sel_Array, kc_not_uniq },
    { "function", sel_Function, sel_Function, kc_not_uniq },
    { "optFunctionParameters", sel_EmptyOptFunctionParameters, sel_OptFunctionParameters, kc_not_uniq },
    { "functionParametersList", sel_EmptyFunctionParametersList, sel_FunctionParametersList, kc_not_uniq },
    { "functionParameters", sel_FunctionParameters, sel_FunctionParameters, kc_not_uniq },
    { "constant", sel_Constant, sel_Constant, kc_not_uniq },
    { "expression", sel_ExprAssignment, sel_ExprInParenthesis, kc_not_uniq },
    { "expressionWithoutInitializer", sel_ExprAssignment2, sel_ExprInParenthesis2, kc_not_uniq },
    { "assignment", sel_AssignEqual, sel_AssignMod, kc_not_uniq },
    { "incdecrement", sel_IncrementVal, sel_ValDecrement, kc_not_uniq },
    { "arithmetic", sel_PositiveExpr, sel_ExprNumber, kc_not_uniq },
    { "arithmeticWithoutInitializer", sel_PositiveExpr2, sel_ExprNumber2, kc_not_uniq },
    { "logical", sel_NotExpr, sel_ExprFalse, kc_not_uniq },
    { "logicalWithoutInitializer", sel_NotExpr2, sel_ExprFalse2, kc_not_uniq },
    { "comparison", sel_ExprEquivalent, sel_ExprGreaterOrEqual, kc_not_uniq },
    { "comparisonWithoutInitializer", sel_ExprEquivalentWithoutInitializer, sel_ExprGreaterOrEqualWithoutInitializer, kc_not_uniq },
    { "leftvalue", sel_LeftValIdent, sel_LeftValDot, kc_not_uniq },
    { "other", sel_ExprIdentParenthesis, sel_ExprAll, kc_not_uniq },
    { "otherWithoutInitializer", sel_ExprIdentParenthesis2, sel_ExprAll2, kc_not_uniq },
    { "initializerList", sel_Braces, sel_ExprInBracesColon, kc_not_uniq },
    { "expressionListColon", sel_EmptyExpressionListColon, sel_ExpressionListColon, kc_not_uniq },
    { "places", sel_Places, sel_Places, kc_not_uniq },
    { "optSafe", sel_EmptySafe, sel_Safe, kc_not_uniq },
    { "optNumber", sel_EmptyPlaceNumber, sel_PlaceNumber, kc_not_uniq },
    { "optType", sel_EmptyPlaceType, sel_PlaceTypeMultiset, kc_not_uniq },
    { "place", sel_Place, sel_PlaceWithTypeIdent, kc_not_uniq },
    { "commaPlaces", sel_EmptyCommaPlaces, sel_CommaPlaces, kc_not_uniq },
    { "morePlaces", sel_EmptyMorePlaces, sel_MorePlaces, kc_not_uniq },
    { "marking", sel_EmptyMarking, sel_Marking, kc_not_uniq },
    { "markingList", sel_EmptyMarkingList, sel_MarkingList, kc_not_uniq },
    { "transition", sel_EmptyTransition, sel_Transition, kc_not_uniq },
    { "fairness", sel_EmptyFairness, sel_StrongFair, kc_not_uniq },
    { "variable", sel_EmptyVariable, sel_Variable, kc_not_uniq },
    { "varOrArrayList", sel_EmptyVarOrArrayList, sel_VarOrArrayList, kc_not_uniq },
    { "guard", sel_EmptyGuard, sel_Guard, kc_not_uniq },
    { "optIdentExprList", sel_EmptyOptIdentExprList, sel_OptIdentExprList, kc_not_uniq },
    { "identExprList", sel_EmptyIdentExprList, sel_IdentExprList, kc_not_uniq },
    { "block", sel_Block, sel_Block, kc_not_uniq },
    { "declarationOrStatement", sel_EmptyDeclarationOrStatement, sel_DeclOrStatemStatement, kc_not_uniq },
    { "declaration", sel_Declaration, sel_Declaration, kc_not_uniq },
    { "statement", sel_StatementSemiolon, sel_StatementReturn, kc_not_uniq },
    { "ifStatement", sel_IfStatement, sel_IfStatement, kc_not_uniq },
    { "optElse", sel_OptElseEmpty, sel_OptElse, kc_not_uniq },
    { "switchCase", sel_SwitchCase, sel_SwitchDefault, kc_not_uniq },
    { "switchCaseList", sel_EmptySwitchCaseList, sel_SwitchDefaultList, kc_not_uniq },
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */
};

static enum_phyla kc_subphyla_Net[] = { phylum_netName, phylum_definitionsList, phylum_places, phylum_marking, phylum_transition };
static enum_phyla kc_subphyla_NetName[] = { phylum_casestring };
static enum_phyla kc_subphyla_DefinitionsList[] = { phylum_definitionsList, phylum_definitions };
static enum_phyla kc_subphyla_DefSort[] = { phylum_sort };
static enum_phyla kc_subphyla_DefFunction[] = { phylum_function };
static enum_phyla kc_subphyla_DefConstant[] = { phylum_constant };
static enum_phyla kc_subphyla_Sort[] = { phylum_type, phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_TypeEnum[] = { phylum_identList };
static enum_phyla kc_subphyla_TypeIdent[] = { phylum_casestring };
static enum_phyla kc_subphyla_TypeIntInterval[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_TypeStruct[] = { phylum_structTypeList };
static enum_phyla kc_subphyla_TypeMultiset[] = { phylum_type };
static enum_phyla kc_subphyla_IdentList[] = { phylum_identList, phylum_idents };
static enum_phyla kc_subphyla_Ident[] = { phylum_casestring, phylum_integer };
static enum_phyla kc_subphyla_SingleStructTypeList[] = { phylum_structType };
static enum_phyla kc_subphyla_StructTypeList[] = { phylum_structTypeList, phylum_structType };
static enum_phyla kc_subphyla_StructType[] = { phylum_type, phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_VarOrArray[] = { phylum_casestring, phylum_arrayList };
static enum_phyla kc_subphyla_ArrayList[] = { phylum_arrayList, phylum_array };
static enum_phyla kc_subphyla_Array[] = { phylum_expression };
static enum_phyla kc_subphyla_Function[] = { phylum_type, phylum_casestring, phylum_arrayList, phylum_optFunctionParameters, phylum_block };
static enum_phyla kc_subphyla_OptFunctionParameters[] = { phylum_type, phylum_varOrArray, phylum_functionParametersList };
static enum_phyla kc_subphyla_FunctionParametersList[] = { phylum_functionParametersList, phylum_functionParameters };
static enum_phyla kc_subphyla_FunctionParameters[] = { phylum_type, phylum_varOrArray };
static enum_phyla kc_subphyla_Constant[] = { phylum_type, phylum_casestring, phylum_arrayList, phylum_expression };
static enum_phyla kc_subphyla_ExprAssignment[] = { phylum_assignment };
static enum_phyla kc_subphyla_ExprIncdecrement[] = { phylum_incdecrement };
static enum_phyla kc_subphyla_ExprArithmetic[] = { phylum_arithmetic };
static enum_phyla kc_subphyla_ExprLogical[] = { phylum_logical };
static enum_phyla kc_subphyla_ExprComparison[] = { phylum_comparison };
static enum_phyla kc_subphyla_ExprLeftvalue[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ExprOther[] = { phylum_other };
static enum_phyla kc_subphyla_ExprInitializerList[] = { phylum_initializerList };
static enum_phyla kc_subphyla_ExprInParenthesis[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAssignment2[] = { phylum_assignment };
static enum_phyla kc_subphyla_ExprIncdecrement2[] = { phylum_incdecrement };
static enum_phyla kc_subphyla_ExprArithmeticWithoutInitializer[] = { phylum_arithmeticWithoutInitializer };
static enum_phyla kc_subphyla_ExprLogicalWithoutInitializer[] = { phylum_logicalWithoutInitializer };
static enum_phyla kc_subphyla_ExprComparisonWithoutInitializer[] = { phylum_comparisonWithoutInitializer };
static enum_phyla kc_subphyla_ExprLeftvalue2[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ExprOtherWithoutInitializer[] = { phylum_otherWithoutInitializer };
static enum_phyla kc_subphyla_ExprInParenthesis2[] = { phylum_expression };
static enum_phyla kc_subphyla_AssignEqual[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignPlus[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignMinus[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignTimes[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignDivide[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_AssignMod[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_IncrementVal[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_DecrementVal[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ValIncrement[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_ValDecrement[] = { phylum_leftvalue };
static enum_phyla kc_subphyla_PositiveExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_NegativeExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAddition[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprSubtraction[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprMultiplication[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprDivision[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprModulo[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprNumber[] = { phylum_integer };
static enum_phyla kc_subphyla_PositiveExpr2[] = { phylum_expression };
static enum_phyla kc_subphyla_NegativeExpr2[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAdditionWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprSubtractionWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprMultiplicationWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprDivisionWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprModuloWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprNumber2[] = { phylum_integer };
static enum_phyla kc_subphyla_NotExpr[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAnd[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprOr[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_NotExpr2[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprAndWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprOrWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprEquivalent[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprNotEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprLessThan[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterThan[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprLessOrEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterOrEqual[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprEquivalentWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprNotEqualWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprLessThanWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterThanWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprLessOrEqualWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprGreaterOrEqualWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_LeftValIdent[] = { phylum_casestring };
static enum_phyla kc_subphyla_LeftValBrackets[] = { phylum_leftvalue, phylum_expression };
static enum_phyla kc_subphyla_LeftValDot[] = { phylum_leftvalue, phylum_casestring };
static enum_phyla kc_subphyla_ExprIdentParenthesis[] = { phylum_casestring };
static enum_phyla kc_subphyla_ExprIdentExprInParenthesis[] = { phylum_casestring, phylum_expression };
static enum_phyla kc_subphyla_ExprCommaSeparated[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprOtherIf[] = { phylum_expression, phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprAll[] = { phylum_type };
static enum_phyla kc_subphyla_ExprIdentParenthesis2[] = { phylum_casestring };
static enum_phyla kc_subphyla_ExprIdentExprInParenthesis2[] = { phylum_casestring, phylum_expression };
static enum_phyla kc_subphyla_ExprCommaSeparatedWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression };
static enum_phyla kc_subphyla_ExprOtherIfWithoutInitializer[] = { phylum_expressionWithoutInitializer, phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_ExprAll2[] = { phylum_type };
static enum_phyla kc_subphyla_ExprInBraces[] = { phylum_expression };
static enum_phyla kc_subphyla_ExprInBracesColon[] = { phylum_expression, phylum_expression, phylum_expressionListColon };
static enum_phyla kc_subphyla_ExpressionListColon[] = { phylum_expression, phylum_expression, phylum_expressionListColon };
static enum_phyla kc_subphyla_Places[] = { phylum_optSafe, phylum_optType, phylum_place, phylum_commaPlaces, phylum_morePlaces };
static enum_phyla kc_subphyla_Safe[] = { phylum_optNumber };
static enum_phyla kc_subphyla_PlaceNumber[] = { phylum_integer };
static enum_phyla kc_subphyla_PlaceTypeEnum[] = { phylum_casestring, phylum_integer, phylum_identList };
static enum_phyla kc_subphyla_PlaceTypeIntInterval[] = { phylum_expression, phylum_expression };
static enum_phyla kc_subphyla_PlaceTypeStruct[] = { phylum_structTypeList };
static enum_phyla kc_subphyla_PlaceTypeMultiset[] = { phylum_type };
static enum_phyla kc_subphyla_Place[] = { phylum_casestring };
static enum_phyla kc_subphyla_PlaceWithTypeIdent[] = { phylum_casestring, phylum_casestring };
static enum_phyla kc_subphyla_CommaPlaces[] = { phylum_optType, phylum_place, phylum_commaPlaces };
static enum_phyla kc_subphyla_MorePlaces[] = { phylum_optSafe, phylum_optType, phylum_place, phylum_commaPlaces, phylum_morePlaces };
static enum_phyla kc_subphyla_Marking[] = { phylum_casestring, phylum_expression, phylum_markingList };
static enum_phyla kc_subphyla_MarkingList[] = { phylum_casestring, phylum_expression, phylum_markingList };
static enum_phyla kc_subphyla_Transition[] = { phylum_casestring, phylum_fairness, phylum_variable, phylum_guard, phylum_optIdentExprList, phylum_optIdentExprList, phylum_transition };
static enum_phyla kc_subphyla_Variable[] = { phylum_type, phylum_varOrArray, phylum_varOrArrayList, phylum_variable };
static enum_phyla kc_subphyla_VarOrArrayList[] = { phylum_varOrArray, phylum_varOrArrayList };
static enum_phyla kc_subphyla_Guard[] = { phylum_expression };
static enum_phyla kc_subphyla_OptIdentExprList[] = { phylum_casestring, phylum_expression, phylum_identExprList };
static enum_phyla kc_subphyla_IdentExprList[] = { phylum_casestring, phylum_expression, phylum_identExprList };
static enum_phyla kc_subphyla_Block[] = { phylum_declarationOrStatement };
static enum_phyla kc_subphyla_DeclOrStatemDeclaration[] = { phylum_declaration, phylum_declarationOrStatement };
static enum_phyla kc_subphyla_DeclOrStatemStatement[] = { phylum_statement, phylum_declarationOrStatement };
static enum_phyla kc_subphyla_Declaration[] = { phylum_type, phylum_varOrArray, phylum_varOrArrayList };
static enum_phyla kc_subphyla_StatementBlock[] = { phylum_block };
static enum_phyla kc_subphyla_StatementExprSemicolon[] = { phylum_expressionWithoutInitializer };
static enum_phyla kc_subphyla_StatementIf[] = { phylum_ifStatement };
static enum_phyla kc_subphyla_StatementWhile[] = { phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementDoWhile[] = { phylum_statement, phylum_expression };
static enum_phyla kc_subphyla_StatementForExpr[] = { phylum_expression, phylum_expression, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForTypeExpr[] = { phylum_type, phylum_casestring, phylum_expression, phylum_expression, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForIdentColon[] = { phylum_casestring, phylum_expression, phylum_statement };
static enum_phyla kc_subphyla_StatementForAll[] = { phylum_type, phylum_casestring, phylum_type };
static enum_phyla kc_subphyla_StatementSwitch[] = { phylum_expression, phylum_switchCase };
static enum_phyla kc_subphyla_StatementReturn[] = { phylum_expression };
static enum_phyla kc_subphyla_IfStatement[] = { phylum_expression, phylum_statement, phylum_optElse };
static enum_phyla kc_subphyla_OptElse[] = { phylum_statement };
static enum_phyla kc_subphyla_SwitchCase[] = { phylum_expression, phylum_statement, phylum_switchCaseList };
static enum_phyla kc_subphyla_SwitchDefault[] = { phylum_statement, phylum_switchCaseList };
static enum_phyla kc_subphyla_SwitchCaseList[] = { phylum_expression, phylum_statement, phylum_switchCaseList };
static enum_phyla kc_subphyla_SwitchDefaultList[] = { phylum_statement, phylum_switchCaseList };


KC_OPERATOR_INFO operator_info[] = {
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */
    { "NoCaseStr", 0, true, phylum_nocasestring, 0, 0, 0, sizeof(impl_nocasestring_NoCaseStr) },
    { "_Str", 0, true, phylum_casestring, 0, 0, 0, sizeof(impl_casestring__Str) },
    { "_Real", 0, true, phylum_real, 0, 0, 0, sizeof(impl_real__Real) },
    { "_Int", 0, true, phylum_integer, 0, 0, 0, sizeof(impl_integer__Int) },
    { "_VoidPtr", 0, true, phylum_voidptr, 0, 0, 0, sizeof(impl_voidptr__VoidPtr) },
    { "Net", 5, false, phylum_net, kc_subphyla_Net, 0, 0, sizeof(impl_net_Net) },
    { "EmptyNetName", 0, false, phylum_netName, 0, 0, 0, sizeof(impl_netName_EmptyNetName) },
    { "NetName", 1, false, phylum_netName, kc_subphyla_NetName, 0, 0, sizeof(impl_netName_NetName) },
    { "EmptyDefinitionsList", 0, false, phylum_definitionsList, 0, 0, 0, sizeof(impl_definitionsList_EmptyDefinitionsList) },
    { "DefinitionsList", 2, false, phylum_definitionsList, kc_subphyla_DefinitionsList, 0, 0, sizeof(impl_definitionsList_DefinitionsList) },
    { "DefSort", 1, false, phylum_definitions, kc_subphyla_DefSort, 0, 0, sizeof(impl_definitions_DefSort) },
    { "DefFunction", 1, false, phylum_definitions, kc_subphyla_DefFunction, 0, 0, sizeof(impl_definitions_DefFunction) },
    { "DefConstant", 1, false, phylum_definitions, kc_subphyla_DefConstant, 0, 0, sizeof(impl_definitions_DefConstant) },
    { "Sort", 3, false, phylum_sort, kc_subphyla_Sort, 0, 0, sizeof(impl_sort_Sort) },
    { "TypeBool", 0, false, phylum_type, 0, 0, 0, sizeof(impl_type_TypeBool) },
    { "TypeEnum", 1, false, phylum_type, kc_subphyla_TypeEnum, 0, 0, sizeof(impl_type_TypeEnum) },
    { "TypeIdent", 1, false, phylum_type, kc_subphyla_TypeIdent, 0, 0, sizeof(impl_type_TypeIdent) },
    { "TypeIntInterval", 2, false, phylum_type, kc_subphyla_TypeIntInterval, 0, 0, sizeof(impl_type_TypeIntInterval) },
    { "TypeStruct", 1, false, phylum_type, kc_subphyla_TypeStruct, 0, 0, sizeof(impl_type_TypeStruct) },
    { "TypeInt", 0, false, phylum_type, 0, 0, 0, sizeof(impl_type_TypeInt) },
    { "TypeMultiset", 1, false, phylum_type, kc_subphyla_TypeMultiset, 0, 0, sizeof(impl_type_TypeMultiset) },
    { "EmptyIdentList", 0, false, phylum_identList, 0, 0, 0, sizeof(impl_identList_EmptyIdentList) },
    { "IdentList", 2, false, phylum_identList, kc_subphyla_IdentList, 0, 0, sizeof(impl_identList_IdentList) },
    { "Ident", 2, false, phylum_idents, kc_subphyla_Ident, 0, 0, sizeof(impl_idents_Ident) },
    { "SingleStructTypeList", 1, false, phylum_structTypeList, kc_subphyla_SingleStructTypeList, 0, 0, sizeof(impl_structTypeList_SingleStructTypeList) },
    { "StructTypeList", 2, false, phylum_structTypeList, kc_subphyla_StructTypeList, 0, 0, sizeof(impl_structTypeList_StructTypeList) },
    { "StructType", 3, false, phylum_structType, kc_subphyla_StructType, 0, 0, sizeof(impl_structType_StructType) },
    { "VarOrArray", 2, false, phylum_varOrArray, kc_subphyla_VarOrArray, 0, 0, sizeof(impl_varOrArray_VarOrArray) },
    { "EmptyArrayList", 0, false, phylum_arrayList, 0, 0, 0, sizeof(impl_arrayList_EmptyArrayList) },
    { "ArrayList", 2, false, phylum_arrayList, kc_subphyla_ArrayList, 0, 0, sizeof(impl_arrayList_ArrayList) },
    { "Array", 1, false, phylum_array, kc_subphyla_Array, 0, 0, sizeof(impl_array_Array) },
    { "Function", 5, false, phylum_function, kc_subphyla_Function, 0, 0, sizeof(impl_function_Function) },
    { "EmptyOptFunctionParameters", 0, false, phylum_optFunctionParameters, 0, 0, 0, sizeof(impl_optFunctionParameters_EmptyOptFunctionParameters) },
    { "OptFunctionParameters", 3, false, phylum_optFunctionParameters, kc_subphyla_OptFunctionParameters, 0, 0, sizeof(impl_optFunctionParameters_OptFunctionParameters) },
    { "EmptyFunctionParametersList", 0, false, phylum_functionParametersList, 0, 0, 0, sizeof(impl_functionParametersList_EmptyFunctionParametersList) },
    { "FunctionParametersList", 2, false, phylum_functionParametersList, kc_subphyla_FunctionParametersList, 0, 0, sizeof(impl_functionParametersList_FunctionParametersList) },
    { "FunctionParameters", 2, false, phylum_functionParameters, kc_subphyla_FunctionParameters, 0, 0, sizeof(impl_functionParameters_FunctionParameters) },
    { "Constant", 4, false, phylum_constant, kc_subphyla_Constant, 0, 0, sizeof(impl_constant_Constant) },
    { "ExprAssignment", 1, false, phylum_expression, kc_subphyla_ExprAssignment, 0, 0, sizeof(impl_expression_ExprAssignment) },
    { "ExprIncdecrement", 1, false, phylum_expression, kc_subphyla_ExprIncdecrement, 0, 0, sizeof(impl_expression_ExprIncdecrement) },
    { "ExprArithmetic", 1, false, phylum_expression, kc_subphyla_ExprArithmetic, 0, 0, sizeof(impl_expression_ExprArithmetic) },
    { "ExprLogical", 1, false, phylum_expression, kc_subphyla_ExprLogical, 0, 0, sizeof(impl_expression_ExprLogical) },
    { "ExprComparison", 1, false, phylum_expression, kc_subphyla_ExprComparison, 0, 0, sizeof(impl_expression_ExprComparison) },
    { "ExprLeftvalue", 1, false, phylum_expression, kc_subphyla_ExprLeftvalue, 0, 0, sizeof(impl_expression_ExprLeftvalue) },
    { "ExprOther", 1, false, phylum_expression, kc_subphyla_ExprOther, 0, 0, sizeof(impl_expression_ExprOther) },
    { "ExprInitializerList", 1, false, phylum_expression, kc_subphyla_ExprInitializerList, 0, 0, sizeof(impl_expression_ExprInitializerList) },
    { "ExprInParenthesis", 1, false, phylum_expression, kc_subphyla_ExprInParenthesis, 0, 0, sizeof(impl_expression_ExprInParenthesis) },
    { "ExprAssignment2", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprAssignment2, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprAssignment2) },
    { "ExprIncdecrement2", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprIncdecrement2, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprIncdecrement2) },
    { "ExprArithmeticWithoutInitializer", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprArithmeticWithoutInitializer, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer) },
    { "ExprLogicalWithoutInitializer", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprLogicalWithoutInitializer, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer) },
    { "ExprComparisonWithoutInitializer", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprComparisonWithoutInitializer, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer) },
    { "ExprLeftvalue2", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprLeftvalue2, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprLeftvalue2) },
    { "ExprOtherWithoutInitializer", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprOtherWithoutInitializer, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprOtherWithoutInitializer) },
    { "ExprInParenthesis2", 1, false, phylum_expressionWithoutInitializer, kc_subphyla_ExprInParenthesis2, 0, 0, sizeof(impl_expressionWithoutInitializer_ExprInParenthesis2) },
    { "AssignEqual", 2, false, phylum_assignment, kc_subphyla_AssignEqual, 0, 0, sizeof(impl_assignment_AssignEqual) },
    { "AssignPlus", 2, false, phylum_assignment, kc_subphyla_AssignPlus, 0, 0, sizeof(impl_assignment_AssignPlus) },
    { "AssignMinus", 2, false, phylum_assignment, kc_subphyla_AssignMinus, 0, 0, sizeof(impl_assignment_AssignMinus) },
    { "AssignTimes", 2, false, phylum_assignment, kc_subphyla_AssignTimes, 0, 0, sizeof(impl_assignment_AssignTimes) },
    { "AssignDivide", 2, false, phylum_assignment, kc_subphyla_AssignDivide, 0, 0, sizeof(impl_assignment_AssignDivide) },
    { "AssignMod", 2, false, phylum_assignment, kc_subphyla_AssignMod, 0, 0, sizeof(impl_assignment_AssignMod) },
    { "IncrementVal", 1, false, phylum_incdecrement, kc_subphyla_IncrementVal, 0, 0, sizeof(impl_incdecrement_IncrementVal) },
    { "DecrementVal", 1, false, phylum_incdecrement, kc_subphyla_DecrementVal, 0, 0, sizeof(impl_incdecrement_DecrementVal) },
    { "ValIncrement", 1, false, phylum_incdecrement, kc_subphyla_ValIncrement, 0, 0, sizeof(impl_incdecrement_ValIncrement) },
    { "ValDecrement", 1, false, phylum_incdecrement, kc_subphyla_ValDecrement, 0, 0, sizeof(impl_incdecrement_ValDecrement) },
    { "PositiveExpr", 1, false, phylum_arithmetic, kc_subphyla_PositiveExpr, 0, 0, sizeof(impl_arithmetic_PositiveExpr) },
    { "NegativeExpr", 1, false, phylum_arithmetic, kc_subphyla_NegativeExpr, 0, 0, sizeof(impl_arithmetic_NegativeExpr) },
    { "ExprAddition", 2, false, phylum_arithmetic, kc_subphyla_ExprAddition, 0, 0, sizeof(impl_arithmetic_ExprAddition) },
    { "ExprSubtraction", 2, false, phylum_arithmetic, kc_subphyla_ExprSubtraction, 0, 0, sizeof(impl_arithmetic_ExprSubtraction) },
    { "ExprMultiplication", 2, false, phylum_arithmetic, kc_subphyla_ExprMultiplication, 0, 0, sizeof(impl_arithmetic_ExprMultiplication) },
    { "ExprDivision", 2, false, phylum_arithmetic, kc_subphyla_ExprDivision, 0, 0, sizeof(impl_arithmetic_ExprDivision) },
    { "ExprModulo", 2, false, phylum_arithmetic, kc_subphyla_ExprModulo, 0, 0, sizeof(impl_arithmetic_ExprModulo) },
    { "ExprNumber", 1, false, phylum_arithmetic, kc_subphyla_ExprNumber, 0, 0, sizeof(impl_arithmetic_ExprNumber) },
    { "PositiveExpr2", 1, false, phylum_arithmeticWithoutInitializer, kc_subphyla_PositiveExpr2, 0, 0, sizeof(impl_arithmeticWithoutInitializer_PositiveExpr2) },
    { "NegativeExpr2", 1, false, phylum_arithmeticWithoutInitializer, kc_subphyla_NegativeExpr2, 0, 0, sizeof(impl_arithmeticWithoutInitializer_NegativeExpr2) },
    { "ExprAdditionWithoutInitializer", 2, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprAdditionWithoutInitializer, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer) },
    { "ExprSubtractionWithoutInitializer", 2, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprSubtractionWithoutInitializer, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer) },
    { "ExprMultiplicationWithoutInitializer", 2, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprMultiplicationWithoutInitializer, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer) },
    { "ExprDivisionWithoutInitializer", 2, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprDivisionWithoutInitializer, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer) },
    { "ExprModuloWithoutInitializer", 2, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprModuloWithoutInitializer, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer) },
    { "ExprNumber2", 1, false, phylum_arithmeticWithoutInitializer, kc_subphyla_ExprNumber2, 0, 0, sizeof(impl_arithmeticWithoutInitializer_ExprNumber2) },
    { "NotExpr", 1, false, phylum_logical, kc_subphyla_NotExpr, 0, 0, sizeof(impl_logical_NotExpr) },
    { "ExprAnd", 2, false, phylum_logical, kc_subphyla_ExprAnd, 0, 0, sizeof(impl_logical_ExprAnd) },
    { "ExprOr", 2, false, phylum_logical, kc_subphyla_ExprOr, 0, 0, sizeof(impl_logical_ExprOr) },
    { "ExprTrue", 0, false, phylum_logical, 0, 0, 0, sizeof(impl_logical_ExprTrue) },
    { "ExprFalse", 0, false, phylum_logical, 0, 0, 0, sizeof(impl_logical_ExprFalse) },
    { "NotExpr2", 1, false, phylum_logicalWithoutInitializer, kc_subphyla_NotExpr2, 0, 0, sizeof(impl_logicalWithoutInitializer_NotExpr2) },
    { "ExprAndWithoutInitializer", 2, false, phylum_logicalWithoutInitializer, kc_subphyla_ExprAndWithoutInitializer, 0, 0, sizeof(impl_logicalWithoutInitializer_ExprAndWithoutInitializer) },
    { "ExprOrWithoutInitializer", 2, false, phylum_logicalWithoutInitializer, kc_subphyla_ExprOrWithoutInitializer, 0, 0, sizeof(impl_logicalWithoutInitializer_ExprOrWithoutInitializer) },
    { "ExprTrue2", 0, false, phylum_logicalWithoutInitializer, 0, 0, 0, sizeof(impl_logicalWithoutInitializer_ExprTrue2) },
    { "ExprFalse2", 0, false, phylum_logicalWithoutInitializer, 0, 0, 0, sizeof(impl_logicalWithoutInitializer_ExprFalse2) },
    { "ExprEquivalent", 2, false, phylum_comparison, kc_subphyla_ExprEquivalent, 0, 0, sizeof(impl_comparison_ExprEquivalent) },
    { "ExprNotEqual", 2, false, phylum_comparison, kc_subphyla_ExprNotEqual, 0, 0, sizeof(impl_comparison_ExprNotEqual) },
    { "ExprLessThan", 2, false, phylum_comparison, kc_subphyla_ExprLessThan, 0, 0, sizeof(impl_comparison_ExprLessThan) },
    { "ExprGreaterThan", 2, false, phylum_comparison, kc_subphyla_ExprGreaterThan, 0, 0, sizeof(impl_comparison_ExprGreaterThan) },
    { "ExprLessOrEqual", 2, false, phylum_comparison, kc_subphyla_ExprLessOrEqual, 0, 0, sizeof(impl_comparison_ExprLessOrEqual) },
    { "ExprGreaterOrEqual", 2, false, phylum_comparison, kc_subphyla_ExprGreaterOrEqual, 0, 0, sizeof(impl_comparison_ExprGreaterOrEqual) },
    { "ExprEquivalentWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprEquivalentWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer) },
    { "ExprNotEqualWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprNotEqualWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer) },
    { "ExprLessThanWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprLessThanWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer) },
    { "ExprGreaterThanWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprGreaterThanWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer) },
    { "ExprLessOrEqualWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprLessOrEqualWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer) },
    { "ExprGreaterOrEqualWithoutInitializer", 2, false, phylum_comparisonWithoutInitializer, kc_subphyla_ExprGreaterOrEqualWithoutInitializer, 0, 0, sizeof(impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer) },
    { "LeftValIdent", 1, false, phylum_leftvalue, kc_subphyla_LeftValIdent, 0, 0, sizeof(impl_leftvalue_LeftValIdent) },
    { "LeftValBrackets", 2, false, phylum_leftvalue, kc_subphyla_LeftValBrackets, 0, 0, sizeof(impl_leftvalue_LeftValBrackets) },
    { "LeftValDot", 2, false, phylum_leftvalue, kc_subphyla_LeftValDot, 0, 0, sizeof(impl_leftvalue_LeftValDot) },
    { "ExprIdentParenthesis", 1, false, phylum_other, kc_subphyla_ExprIdentParenthesis, 0, 0, sizeof(impl_other_ExprIdentParenthesis) },
    { "ExprIdentExprInParenthesis", 2, false, phylum_other, kc_subphyla_ExprIdentExprInParenthesis, 0, 0, sizeof(impl_other_ExprIdentExprInParenthesis) },
    { "ExprCommaSeparated", 2, false, phylum_other, kc_subphyla_ExprCommaSeparated, 0, 0, sizeof(impl_other_ExprCommaSeparated) },
    { "ExprOtherIf", 3, false, phylum_other, kc_subphyla_ExprOtherIf, 0, 0, sizeof(impl_other_ExprOtherIf) },
    { "ExprAll", 1, false, phylum_other, kc_subphyla_ExprAll, 0, 0, sizeof(impl_other_ExprAll) },
    { "ExprIdentParenthesis2", 1, false, phylum_otherWithoutInitializer, kc_subphyla_ExprIdentParenthesis2, 0, 0, sizeof(impl_otherWithoutInitializer_ExprIdentParenthesis2) },
    { "ExprIdentExprInParenthesis2", 2, false, phylum_otherWithoutInitializer, kc_subphyla_ExprIdentExprInParenthesis2, 0, 0, sizeof(impl_otherWithoutInitializer_ExprIdentExprInParenthesis2) },
    { "ExprCommaSeparatedWithoutInitializer", 2, false, phylum_otherWithoutInitializer, kc_subphyla_ExprCommaSeparatedWithoutInitializer, 0, 0, sizeof(impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer) },
    { "ExprOtherIfWithoutInitializer", 3, false, phylum_otherWithoutInitializer, kc_subphyla_ExprOtherIfWithoutInitializer, 0, 0, sizeof(impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer) },
    { "ExprAll2", 1, false, phylum_otherWithoutInitializer, kc_subphyla_ExprAll2, 0, 0, sizeof(impl_otherWithoutInitializer_ExprAll2) },
    { "Braces", 0, false, phylum_initializerList, 0, 0, 0, sizeof(impl_initializerList_Braces) },
    { "ExprInBraces", 1, false, phylum_initializerList, kc_subphyla_ExprInBraces, 0, 0, sizeof(impl_initializerList_ExprInBraces) },
    { "ExprInBracesColon", 3, false, phylum_initializerList, kc_subphyla_ExprInBracesColon, 0, 0, sizeof(impl_initializerList_ExprInBracesColon) },
    { "EmptyExpressionListColon", 0, false, phylum_expressionListColon, 0, 0, 0, sizeof(impl_expressionListColon_EmptyExpressionListColon) },
    { "ExpressionListColon", 3, false, phylum_expressionListColon, kc_subphyla_ExpressionListColon, 0, 0, sizeof(impl_expressionListColon_ExpressionListColon) },
    { "Places", 5, false, phylum_places, kc_subphyla_Places, 0, 0, sizeof(impl_places_Places) },
    { "EmptySafe", 0, false, phylum_optSafe, 0, 0, 0, sizeof(impl_optSafe_EmptySafe) },
    { "Safe", 1, false, phylum_optSafe, kc_subphyla_Safe, 0, 0, sizeof(impl_optSafe_Safe) },
    { "EmptyPlaceNumber", 0, false, phylum_optNumber, 0, 0, 0, sizeof(impl_optNumber_EmptyPlaceNumber) },
    { "PlaceNumber", 1, false, phylum_optNumber, kc_subphyla_PlaceNumber, 0, 0, sizeof(impl_optNumber_PlaceNumber) },
    { "EmptyPlaceType", 0, false, phylum_optType, 0, 0, 0, sizeof(impl_optType_EmptyPlaceType) },
    { "PlaceTypeBool", 0, false, phylum_optType, 0, 0, 0, sizeof(impl_optType_PlaceTypeBool) },
    { "PlaceTypeEnum", 3, false, phylum_optType, kc_subphyla_PlaceTypeEnum, 0, 0, sizeof(impl_optType_PlaceTypeEnum) },
    { "PlaceTypeIntInterval", 2, false, phylum_optType, kc_subphyla_PlaceTypeIntInterval, 0, 0, sizeof(impl_optType_PlaceTypeIntInterval) },
    { "PlaceTypeStruct", 1, false, phylum_optType, kc_subphyla_PlaceTypeStruct, 0, 0, sizeof(impl_optType_PlaceTypeStruct) },
    { "PlaceTypeInt", 0, false, phylum_optType, 0, 0, 0, sizeof(impl_optType_PlaceTypeInt) },
    { "PlaceTypeMultiset", 1, false, phylum_optType, kc_subphyla_PlaceTypeMultiset, 0, 0, sizeof(impl_optType_PlaceTypeMultiset) },
    { "Place", 1, false, phylum_place, kc_subphyla_Place, 0, 0, sizeof(impl_place_Place) },
    { "PlaceWithTypeIdent", 2, false, phylum_place, kc_subphyla_PlaceWithTypeIdent, 0, 0, sizeof(impl_place_PlaceWithTypeIdent) },
    { "EmptyCommaPlaces", 0, false, phylum_commaPlaces, 0, 0, 0, sizeof(impl_commaPlaces_EmptyCommaPlaces) },
    { "CommaPlaces", 3, false, phylum_commaPlaces, kc_subphyla_CommaPlaces, 0, 0, sizeof(impl_commaPlaces_CommaPlaces) },
    { "EmptyMorePlaces", 0, false, phylum_morePlaces, 0, 0, 0, sizeof(impl_morePlaces_EmptyMorePlaces) },
    { "MorePlaces", 5, false, phylum_morePlaces, kc_subphyla_MorePlaces, 0, 0, sizeof(impl_morePlaces_MorePlaces) },
    { "EmptyMarking", 0, false, phylum_marking, 0, 0, 0, sizeof(impl_marking_EmptyMarking) },
    { "Marking", 3, false, phylum_marking, kc_subphyla_Marking, 0, 0, sizeof(impl_marking_Marking) },
    { "EmptyMarkingList", 0, false, phylum_markingList, 0, 0, 0, sizeof(impl_markingList_EmptyMarkingList) },
    { "MarkingList", 3, false, phylum_markingList, kc_subphyla_MarkingList, 0, 0, sizeof(impl_markingList_MarkingList) },
    { "EmptyTransition", 0, false, phylum_transition, 0, 0, 0, sizeof(impl_transition_EmptyTransition) },
    { "Transition", 7, false, phylum_transition, kc_subphyla_Transition, 0, 0, sizeof(impl_transition_Transition) },
    { "EmptyFairness", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_EmptyFairness) },
    { "WeakFair", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_WeakFair) },
    { "StrongFair", 0, false, phylum_fairness, 0, 0, 0, sizeof(impl_fairness_StrongFair) },
    { "EmptyVariable", 0, false, phylum_variable, 0, 0, 0, sizeof(impl_variable_EmptyVariable) },
    { "Variable", 4, false, phylum_variable, kc_subphyla_Variable, 0, 0, sizeof(impl_variable_Variable) },
    { "EmptyVarOrArrayList", 0, false, phylum_varOrArrayList, 0, 0, 0, sizeof(impl_varOrArrayList_EmptyVarOrArrayList) },
    { "VarOrArrayList", 2, false, phylum_varOrArrayList, kc_subphyla_VarOrArrayList, 0, 0, sizeof(impl_varOrArrayList_VarOrArrayList) },
    { "EmptyGuard", 0, false, phylum_guard, 0, 0, 0, sizeof(impl_guard_EmptyGuard) },
    { "Guard", 1, false, phylum_guard, kc_subphyla_Guard, 0, 0, sizeof(impl_guard_Guard) },
    { "EmptyOptIdentExprList", 0, false, phylum_optIdentExprList, 0, 0, 0, sizeof(impl_optIdentExprList_EmptyOptIdentExprList) },
    { "OptIdentExprList", 3, false, phylum_optIdentExprList, kc_subphyla_OptIdentExprList, 0, 0, sizeof(impl_optIdentExprList_OptIdentExprList) },
    { "EmptyIdentExprList", 0, false, phylum_identExprList, 0, 0, 0, sizeof(impl_identExprList_EmptyIdentExprList) },
    { "IdentExprList", 3, false, phylum_identExprList, kc_subphyla_IdentExprList, 0, 0, sizeof(impl_identExprList_IdentExprList) },
    { "Block", 1, false, phylum_block, kc_subphyla_Block, 0, 0, sizeof(impl_block_Block) },
    { "EmptyDeclarationOrStatement", 0, false, phylum_declarationOrStatement, 0, 0, 0, sizeof(impl_declarationOrStatement_EmptyDeclarationOrStatement) },
    { "DeclOrStatemDeclaration", 2, false, phylum_declarationOrStatement, kc_subphyla_DeclOrStatemDeclaration, 0, 0, sizeof(impl_declarationOrStatement_DeclOrStatemDeclaration) },
    { "DeclOrStatemStatement", 2, false, phylum_declarationOrStatement, kc_subphyla_DeclOrStatemStatement, 0, 0, sizeof(impl_declarationOrStatement_DeclOrStatemStatement) },
    { "Declaration", 3, false, phylum_declaration, kc_subphyla_Declaration, 0, 0, sizeof(impl_declaration_Declaration) },
    { "StatementSemiolon", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementSemiolon) },
    { "StatementBlock", 1, false, phylum_statement, kc_subphyla_StatementBlock, 0, 0, sizeof(impl_statement_StatementBlock) },
    { "StatementExprSemicolon", 1, false, phylum_statement, kc_subphyla_StatementExprSemicolon, 0, 0, sizeof(impl_statement_StatementExprSemicolon) },
    { "StatementIf", 1, false, phylum_statement, kc_subphyla_StatementIf, 0, 0, sizeof(impl_statement_StatementIf) },
    { "StatementWhile", 2, false, phylum_statement, kc_subphyla_StatementWhile, 0, 0, sizeof(impl_statement_StatementWhile) },
    { "StatementDoWhile", 2, false, phylum_statement, kc_subphyla_StatementDoWhile, 0, 0, sizeof(impl_statement_StatementDoWhile) },
    { "StatementForExpr", 4, false, phylum_statement, kc_subphyla_StatementForExpr, 0, 0, sizeof(impl_statement_StatementForExpr) },
    { "StatementForTypeExpr", 6, false, phylum_statement, kc_subphyla_StatementForTypeExpr, 0, 0, sizeof(impl_statement_StatementForTypeExpr) },
    { "StatementForIdentColon", 3, false, phylum_statement, kc_subphyla_StatementForIdentColon, 0, 0, sizeof(impl_statement_StatementForIdentColon) },
    { "StatementForAll", 3, false, phylum_statement, kc_subphyla_StatementForAll, 0, 0, sizeof(impl_statement_StatementForAll) },
    { "StatementSwitch", 2, false, phylum_statement, kc_subphyla_StatementSwitch, 0, 0, sizeof(impl_statement_StatementSwitch) },
    { "StatementBreak", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementBreak) },
    { "StatementContinue", 0, false, phylum_statement, 0, 0, 0, sizeof(impl_statement_StatementContinue) },
    { "StatementReturn", 1, false, phylum_statement, kc_subphyla_StatementReturn, 0, 0, sizeof(impl_statement_StatementReturn) },
    { "IfStatement", 3, false, phylum_ifStatement, kc_subphyla_IfStatement, 0, 0, sizeof(impl_ifStatement_IfStatement) },
    { "OptElseEmpty", 0, false, phylum_optElse, 0, 0, 0, sizeof(impl_optElse_OptElseEmpty) },
    { "OptElse", 1, false, phylum_optElse, kc_subphyla_OptElse, 0, 0, sizeof(impl_optElse_OptElse) },
    { "SwitchCase", 3, false, phylum_switchCase, kc_subphyla_SwitchCase, 0, 0, sizeof(impl_switchCase_SwitchCase) },
    { "SwitchDefault", 2, false, phylum_switchCase, kc_subphyla_SwitchDefault, 0, 0, sizeof(impl_switchCase_SwitchDefault) },
    { "EmptySwitchCaseList", 0, false, phylum_switchCaseList, 0, 0, 0, sizeof(impl_switchCaseList_EmptySwitchCaseList) },
    { "SwitchCaseList", 3, false, phylum_switchCaseList, kc_subphyla_SwitchCaseList, 0, 0, sizeof(impl_switchCaseList_SwitchCaseList) },
    { "SwitchDefaultList", 2, false, phylum_switchCaseList, kc_subphyla_SwitchDefaultList, 0, 0, sizeof(impl_switchCaseList_SwitchDefaultList) },
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */
};

static enum_phyla phylumstorageclass_uniq[] = { one_before_first_phylum, phylum_nocasestring, phylum_casestring, phylum_real, phylum_integer, phylum_voidptr, last_phylum };

KC_UNIQ_INFO kc_UniqInfo[] = {
    (KC_UNIQ_INFO)0,
    phylumstorageclass_uniq
};

} // namespace kc

namespace kc {

void
kc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN_WITH);
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: function %s does not return a value, at %s:%d");
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: function %s does not return a value, at %s:%d", kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionFailed(const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    TRACE( format, tkc_func, kc_l );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d\n", kc_fn, kc_l );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at file %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_s);
    TRACE( format, tkc_func, kc_l, tkc_s );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at file %s:%d: %s\n", kc_fn, kc_l, kc_s );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionNonNullFailed(const char *kc_fn, int kc_l, const char *kc_str)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_str);
    TRACE( format , tkc_func, kc_l, tkc_s);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n", kc_fn, kc_l, kc_str );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s1=A2CT(kc_str1);
    const _TCHAR* tkc_s2=A2CT(kc_str2);
    const _TCHAR* tname=A2CT(kc_phy);
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );
    } else {
	format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n");
	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);
	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);
	TRACE(format,tkc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );
    }
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, kc_op );
    } else {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );
    }
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: invalid operator code in %s%s at %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_func_prefix);
    const _TCHAR* tkc_file=A2CT(kc_file);
    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));
    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));
    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: invalid operator code in %s%s at %s:%d: %s\n", kc_func_prefix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));
#ifndef KC_INVALID_OPERATOR_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}
const enum_phyla impl_nocasestring::phylum_sel_ = phylum_nocasestring;
const enum_phyla impl_casestring::phylum_sel_ = phylum_casestring;
const enum_phyla impl_real::phylum_sel_ = phylum_real;
impl_real__Real::impl_real__Real(REAL _value)
    : value(_value) { }
const enum_phyla impl_integer::phylum_sel_ = phylum_integer;
impl_integer__Int::impl_integer__Int(INTEGER _value)
    : value(_value) { }
const enum_phyla impl_voidptr::phylum_sel_ = phylum_voidptr;
impl_voidptr__VoidPtr::impl_voidptr__VoidPtr(void* _pointer)
    : pointer(_pointer) { }
const enum_phyla impl_net::phylum_sel_ = phylum_net;
impl_net_Net::impl_net_Net(netName _netName_1, definitionsList _definitionsList_1, places _places_1, marking _marking_1, transition _transition_1)
    : netName_1(_netName_1), definitionsList_1(_definitionsList_1), places_1(_places_1), marking_1(_marking_1), transition_1(_transition_1) { }
const enum_phyla impl_netName::phylum_sel_ = phylum_netName;
impl_netName_NetName::impl_netName_NetName(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_netName_EmptyNetName::impl_netName_EmptyNetName()
    { }
const enum_phyla impl_definitionsList::phylum_sel_ = phylum_definitionsList;
impl_definitionsList_DefinitionsList::impl_definitionsList_DefinitionsList(definitionsList _definitionsList_1, definitions _definitions_1)
    : definitionsList_1(_definitionsList_1), definitions_1(_definitions_1) { }
impl_definitionsList_EmptyDefinitionsList::impl_definitionsList_EmptyDefinitionsList()
    { }
const enum_phyla impl_definitions::phylum_sel_ = phylum_definitions;
impl_definitions_DefConstant::impl_definitions_DefConstant(constant _constant_1)
    : constant_1(_constant_1) { }
impl_definitions_DefFunction::impl_definitions_DefFunction(function _function_1)
    : function_1(_function_1) { }
impl_definitions_DefSort::impl_definitions_DefSort(sort _sort_1)
    : sort_1(_sort_1) { }
const enum_phyla impl_sort::phylum_sel_ = phylum_sort;
impl_sort_Sort::impl_sort_Sort(type _type_1, casestring _casestring_1, arrayList _arrayList_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
const enum_phyla impl_type::phylum_sel_ = phylum_type;
impl_type_TypeMultiset::impl_type_TypeMultiset(type _type_1)
    : type_1(_type_1) { }
impl_type_TypeInt::impl_type_TypeInt()
    { }
impl_type_TypeStruct::impl_type_TypeStruct(structTypeList _structTypeList_1)
    : structTypeList_1(_structTypeList_1) { }
impl_type_TypeIntInterval::impl_type_TypeIntInterval(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_type_TypeIdent::impl_type_TypeIdent(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
impl_type_TypeEnum::impl_type_TypeEnum(identList _identList_1)
    : identList_1(_identList_1) { }
impl_type_TypeBool::impl_type_TypeBool()
    { }
const enum_phyla impl_identList::phylum_sel_ = phylum_identList;
impl_identList_IdentList::impl_identList_IdentList(identList _identList_1, idents _idents_1)
    : identList_1(_identList_1), idents_1(_idents_1) { }
impl_identList_EmptyIdentList::impl_identList_EmptyIdentList()
    { }
const enum_phyla impl_idents::phylum_sel_ = phylum_idents;
impl_idents_Ident::impl_idents_Ident(casestring _casestring_1, integer _integer_1)
    : casestring_1(_casestring_1), integer_1(_integer_1) { }
const enum_phyla impl_structTypeList::phylum_sel_ = phylum_structTypeList;
impl_structTypeList_StructTypeList::impl_structTypeList_StructTypeList(structTypeList _structTypeList_1, structType _structType_1)
    : structTypeList_1(_structTypeList_1), structType_1(_structType_1) { }
impl_structTypeList_SingleStructTypeList::impl_structTypeList_SingleStructTypeList(structType _structType_1)
    : structType_1(_structType_1) { }
const enum_phyla impl_structType::phylum_sel_ = phylum_structType;
impl_structType_StructType::impl_structType_StructType(type _type_1, casestring _casestring_1, arrayList _arrayList_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
const enum_phyla impl_varOrArray::phylum_sel_ = phylum_varOrArray;
impl_varOrArray_VarOrArray::impl_varOrArray_VarOrArray(casestring _casestring_1, arrayList _arrayList_1)
    : casestring_1(_casestring_1), arrayList_1(_arrayList_1) { }
const enum_phyla impl_arrayList::phylum_sel_ = phylum_arrayList;
impl_arrayList_ArrayList::impl_arrayList_ArrayList(arrayList _arrayList_1, array _array_1)
    : arrayList_1(_arrayList_1), array_1(_array_1) { }
impl_arrayList_EmptyArrayList::impl_arrayList_EmptyArrayList()
    { }
const enum_phyla impl_array::phylum_sel_ = phylum_array;
impl_array_Array::impl_array_Array(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_function::phylum_sel_ = phylum_function;
impl_function_Function::impl_function_Function(type _type_1, casestring _casestring_1, arrayList _arrayList_1, optFunctionParameters _optFunctionParameters_1, block _block_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1), optFunctionParameters_1(_optFunctionParameters_1), block_1(_block_1) { }
const enum_phyla impl_optFunctionParameters::phylum_sel_ = phylum_optFunctionParameters;
impl_optFunctionParameters_OptFunctionParameters::impl_optFunctionParameters_OptFunctionParameters(type _type_1, varOrArray _varOrArray_1, functionParametersList _functionParametersList_1)
    : type_1(_type_1), varOrArray_1(_varOrArray_1), functionParametersList_1(_functionParametersList_1) { }
impl_optFunctionParameters_EmptyOptFunctionParameters::impl_optFunctionParameters_EmptyOptFunctionParameters()
    { }
const enum_phyla impl_functionParametersList::phylum_sel_ = phylum_functionParametersList;
impl_functionParametersList_FunctionParametersList::impl_functionParametersList_FunctionParametersList(functionParametersList _functionParametersList_1, functionParameters _functionParameters_1)
    : functionParametersList_1(_functionParametersList_1), functionParameters_1(_functionParameters_1) { }
impl_functionParametersList_EmptyFunctionParametersList::impl_functionParametersList_EmptyFunctionParametersList()
    { }
const enum_phyla impl_functionParameters::phylum_sel_ = phylum_functionParameters;
impl_functionParameters_FunctionParameters::impl_functionParameters_FunctionParameters(type _type_1, varOrArray _varOrArray_1)
    : type_1(_type_1), varOrArray_1(_varOrArray_1) { }
const enum_phyla impl_constant::phylum_sel_ = phylum_constant;
impl_constant_Constant::impl_constant_Constant(type _type_1, casestring _casestring_1, arrayList _arrayList_1, expression _expression_1)
    : type_1(_type_1), casestring_1(_casestring_1), arrayList_1(_arrayList_1), expression_1(_expression_1) { }
const enum_phyla impl_expression::phylum_sel_ = phylum_expression;
impl_expression_ExprInParenthesis::impl_expression_ExprInParenthesis(expression _expression_1)
    : expression_1(_expression_1) { }
impl_expression_ExprInitializerList::impl_expression_ExprInitializerList(initializerList _initializerList_1)
    : initializerList_1(_initializerList_1) { }
impl_expression_ExprOther::impl_expression_ExprOther(other _other_1)
    : other_1(_other_1) { }
impl_expression_ExprLeftvalue::impl_expression_ExprLeftvalue(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expression_ExprComparison::impl_expression_ExprComparison(comparison _comparison_1)
    : comparison_1(_comparison_1) { }
impl_expression_ExprLogical::impl_expression_ExprLogical(logical _logical_1)
    : logical_1(_logical_1) { }
impl_expression_ExprArithmetic::impl_expression_ExprArithmetic(arithmetic _arithmetic_1)
    : arithmetic_1(_arithmetic_1) { }
impl_expression_ExprIncdecrement::impl_expression_ExprIncdecrement(incdecrement _incdecrement_1)
    : incdecrement_1(_incdecrement_1) { }
impl_expression_ExprAssignment::impl_expression_ExprAssignment(assignment _assignment_1)
    : assignment_1(_assignment_1) { }
const enum_phyla impl_expressionWithoutInitializer::phylum_sel_ = phylum_expressionWithoutInitializer;
impl_expressionWithoutInitializer_ExprInParenthesis2::impl_expressionWithoutInitializer_ExprInParenthesis2(expression _expression_1)
    : expression_1(_expression_1) { }
impl_expressionWithoutInitializer_ExprOtherWithoutInitializer::impl_expressionWithoutInitializer_ExprOtherWithoutInitializer(otherWithoutInitializer _otherWithoutInitializer_1)
    : otherWithoutInitializer_1(_otherWithoutInitializer_1) { }
impl_expressionWithoutInitializer_ExprLeftvalue2::impl_expressionWithoutInitializer_ExprLeftvalue2(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer::impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer(comparisonWithoutInitializer _comparisonWithoutInitializer_1)
    : comparisonWithoutInitializer_1(_comparisonWithoutInitializer_1) { }
impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer::impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer(logicalWithoutInitializer _logicalWithoutInitializer_1)
    : logicalWithoutInitializer_1(_logicalWithoutInitializer_1) { }
impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer::impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer(arithmeticWithoutInitializer _arithmeticWithoutInitializer_1)
    : arithmeticWithoutInitializer_1(_arithmeticWithoutInitializer_1) { }
impl_expressionWithoutInitializer_ExprIncdecrement2::impl_expressionWithoutInitializer_ExprIncdecrement2(incdecrement _incdecrement_1)
    : incdecrement_1(_incdecrement_1) { }
impl_expressionWithoutInitializer_ExprAssignment2::impl_expressionWithoutInitializer_ExprAssignment2(assignment _assignment_1)
    : assignment_1(_assignment_1) { }
const enum_phyla impl_assignment::phylum_sel_ = phylum_assignment;
impl_assignment_AssignMod::impl_assignment_AssignMod(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_assignment_AssignDivide::impl_assignment_AssignDivide(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_assignment_AssignTimes::impl_assignment_AssignTimes(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_assignment_AssignMinus::impl_assignment_AssignMinus(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_assignment_AssignPlus::impl_assignment_AssignPlus(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_assignment_AssignEqual::impl_assignment_AssignEqual(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
const enum_phyla impl_incdecrement::phylum_sel_ = phylum_incdecrement;
impl_incdecrement_ValDecrement::impl_incdecrement_ValDecrement(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_incdecrement_ValIncrement::impl_incdecrement_ValIncrement(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_incdecrement_DecrementVal::impl_incdecrement_DecrementVal(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
impl_incdecrement_IncrementVal::impl_incdecrement_IncrementVal(leftvalue _leftvalue_1)
    : leftvalue_1(_leftvalue_1) { }
const enum_phyla impl_arithmetic::phylum_sel_ = phylum_arithmetic;
impl_arithmetic_ExprNumber::impl_arithmetic_ExprNumber(integer _integer_1)
    : integer_1(_integer_1) { }
impl_arithmetic_ExprModulo::impl_arithmetic_ExprModulo(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_arithmetic_ExprDivision::impl_arithmetic_ExprDivision(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_arithmetic_ExprMultiplication::impl_arithmetic_ExprMultiplication(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_arithmetic_ExprSubtraction::impl_arithmetic_ExprSubtraction(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_arithmetic_ExprAddition::impl_arithmetic_ExprAddition(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_arithmetic_NegativeExpr::impl_arithmetic_NegativeExpr(expression _expression_1)
    : expression_1(_expression_1) { }
impl_arithmetic_PositiveExpr::impl_arithmetic_PositiveExpr(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_arithmeticWithoutInitializer::phylum_sel_ = phylum_arithmeticWithoutInitializer;
impl_arithmeticWithoutInitializer_ExprNumber2::impl_arithmeticWithoutInitializer_ExprNumber2(integer _integer_1)
    : integer_1(_integer_1) { }
impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer::impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer::impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer::impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer::impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer::impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_NegativeExpr2::impl_arithmeticWithoutInitializer_NegativeExpr2(expression _expression_1)
    : expression_1(_expression_1) { }
impl_arithmeticWithoutInitializer_PositiveExpr2::impl_arithmeticWithoutInitializer_PositiveExpr2(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_logical::phylum_sel_ = phylum_logical;
impl_logical_ExprFalse::impl_logical_ExprFalse()
    { }
impl_logical_ExprTrue::impl_logical_ExprTrue()
    { }
impl_logical_ExprOr::impl_logical_ExprOr(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_logical_ExprAnd::impl_logical_ExprAnd(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_logical_NotExpr::impl_logical_NotExpr(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_logicalWithoutInitializer::phylum_sel_ = phylum_logicalWithoutInitializer;
impl_logicalWithoutInitializer_ExprFalse2::impl_logicalWithoutInitializer_ExprFalse2()
    { }
impl_logicalWithoutInitializer_ExprTrue2::impl_logicalWithoutInitializer_ExprTrue2()
    { }
impl_logicalWithoutInitializer_ExprOrWithoutInitializer::impl_logicalWithoutInitializer_ExprOrWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_logicalWithoutInitializer_ExprAndWithoutInitializer::impl_logicalWithoutInitializer_ExprAndWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_logicalWithoutInitializer_NotExpr2::impl_logicalWithoutInitializer_NotExpr2(expression _expression_1)
    : expression_1(_expression_1) { }
const enum_phyla impl_comparison::phylum_sel_ = phylum_comparison;
impl_comparison_ExprGreaterOrEqual::impl_comparison_ExprGreaterOrEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_comparison_ExprLessOrEqual::impl_comparison_ExprLessOrEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_comparison_ExprGreaterThan::impl_comparison_ExprGreaterThan(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_comparison_ExprLessThan::impl_comparison_ExprLessThan(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_comparison_ExprNotEqual::impl_comparison_ExprNotEqual(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_comparison_ExprEquivalent::impl_comparison_ExprEquivalent(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
const enum_phyla impl_comparisonWithoutInitializer::phylum_sel_ = phylum_comparisonWithoutInitializer;
impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer::impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer::impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer::impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer::impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer::impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer::impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
const enum_phyla impl_leftvalue::phylum_sel_ = phylum_leftvalue;
impl_leftvalue_LeftValDot::impl_leftvalue_LeftValDot(leftvalue _leftvalue_1, casestring _casestring_1)
    : leftvalue_1(_leftvalue_1), casestring_1(_casestring_1) { }
impl_leftvalue_LeftValBrackets::impl_leftvalue_LeftValBrackets(leftvalue _leftvalue_1, expression _expression_1)
    : leftvalue_1(_leftvalue_1), expression_1(_expression_1) { }
impl_leftvalue_LeftValIdent::impl_leftvalue_LeftValIdent(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_other::phylum_sel_ = phylum_other;
impl_other_ExprAll::impl_other_ExprAll(type _type_1)
    : type_1(_type_1) { }
impl_other_ExprOtherIf::impl_other_ExprOtherIf(expression _expression_1, expression _expression_2, expression _expression_3)
    : expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3) { }
impl_other_ExprCommaSeparated::impl_other_ExprCommaSeparated(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_other_ExprIdentExprInParenthesis::impl_other_ExprIdentExprInParenthesis(casestring _casestring_1, expression _expression_1)
    : casestring_1(_casestring_1), expression_1(_expression_1) { }
impl_other_ExprIdentParenthesis::impl_other_ExprIdentParenthesis(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_otherWithoutInitializer::phylum_sel_ = phylum_otherWithoutInitializer;
impl_otherWithoutInitializer_ExprAll2::impl_otherWithoutInitializer_ExprAll2(type _type_1)
    : type_1(_type_1) { }
impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer::impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1, expression _expression_2)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1), expression_2(_expression_2) { }
impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer::impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1), expression_1(_expression_1) { }
impl_otherWithoutInitializer_ExprIdentExprInParenthesis2::impl_otherWithoutInitializer_ExprIdentExprInParenthesis2(casestring _casestring_1, expression _expression_1)
    : casestring_1(_casestring_1), expression_1(_expression_1) { }
impl_otherWithoutInitializer_ExprIdentParenthesis2::impl_otherWithoutInitializer_ExprIdentParenthesis2(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_initializerList::phylum_sel_ = phylum_initializerList;
impl_initializerList_ExprInBracesColon::impl_initializerList_ExprInBracesColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1)
    : expression_1(_expression_1), expression_2(_expression_2), expressionListColon_1(_expressionListColon_1) { }
impl_initializerList_ExprInBraces::impl_initializerList_ExprInBraces(expression _expression_1)
    : expression_1(_expression_1) { }
impl_initializerList_Braces::impl_initializerList_Braces()
    { }
const enum_phyla impl_expressionListColon::phylum_sel_ = phylum_expressionListColon;
impl_expressionListColon_ExpressionListColon::impl_expressionListColon_ExpressionListColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1)
    : expression_1(_expression_1), expression_2(_expression_2), expressionListColon_1(_expressionListColon_1) { }
impl_expressionListColon_EmptyExpressionListColon::impl_expressionListColon_EmptyExpressionListColon()
    { }
const enum_phyla impl_places::phylum_sel_ = phylum_places;
impl_places_Places::impl_places_Places(optSafe _optSafe_1, optType _optType_1, place _place_1, commaPlaces _commaPlaces_1, morePlaces _morePlaces_1)
    : optSafe_1(_optSafe_1), optType_1(_optType_1), place_1(_place_1), commaPlaces_1(_commaPlaces_1), morePlaces_1(_morePlaces_1) { }
const enum_phyla impl_optSafe::phylum_sel_ = phylum_optSafe;
impl_optSafe_Safe::impl_optSafe_Safe(optNumber _optNumber_1)
    : optNumber_1(_optNumber_1) { }
impl_optSafe_EmptySafe::impl_optSafe_EmptySafe()
    { }
const enum_phyla impl_optNumber::phylum_sel_ = phylum_optNumber;
impl_optNumber_PlaceNumber::impl_optNumber_PlaceNumber(integer _integer_1)
    : integer_1(_integer_1) { }
impl_optNumber_EmptyPlaceNumber::impl_optNumber_EmptyPlaceNumber()
    { }
const enum_phyla impl_optType::phylum_sel_ = phylum_optType;
impl_optType_PlaceTypeMultiset::impl_optType_PlaceTypeMultiset(type _type_1)
    : type_1(_type_1) { }
impl_optType_PlaceTypeInt::impl_optType_PlaceTypeInt()
    { }
impl_optType_PlaceTypeStruct::impl_optType_PlaceTypeStruct(structTypeList _structTypeList_1)
    : structTypeList_1(_structTypeList_1) { }
impl_optType_PlaceTypeIntInterval::impl_optType_PlaceTypeIntInterval(expression _expression_1, expression _expression_2)
    : expression_1(_expression_1), expression_2(_expression_2) { }
impl_optType_PlaceTypeEnum::impl_optType_PlaceTypeEnum(casestring _casestring_1, integer _integer_1, identList _identList_1)
    : casestring_1(_casestring_1), integer_1(_integer_1), identList_1(_identList_1) { }
impl_optType_PlaceTypeBool::impl_optType_PlaceTypeBool()
    { }
impl_optType_EmptyPlaceType::impl_optType_EmptyPlaceType()
    { }
const enum_phyla impl_place::phylum_sel_ = phylum_place;
impl_place_PlaceWithTypeIdent::impl_place_PlaceWithTypeIdent(casestring _casestring_1, casestring _casestring_2)
    : casestring_1(_casestring_1), casestring_2(_casestring_2) { }
impl_place_Place::impl_place_Place(casestring _casestring_1)
    : casestring_1(_casestring_1) { }
const enum_phyla impl_commaPlaces::phylum_sel_ = phylum_commaPlaces;
impl_commaPlaces_CommaPlaces::impl_commaPlaces_CommaPlaces(optType _optType_1, place _place_1, commaPlaces _commaPlaces_1)
    : optType_1(_optType_1), place_1(_place_1), commaPlaces_1(_commaPlaces_1) { }
impl_commaPlaces_EmptyCommaPlaces::impl_commaPlaces_EmptyCommaPlaces()
    { }
const enum_phyla impl_morePlaces::phylum_sel_ = phylum_morePlaces;
impl_morePlaces_MorePlaces::impl_morePlaces_MorePlaces(optSafe _optSafe_1, optType _optType_1, place _place_1, commaPlaces _commaPlaces_1, morePlaces _morePlaces_1)
    : optSafe_1(_optSafe_1), optType_1(_optType_1), place_1(_place_1), commaPlaces_1(_commaPlaces_1), morePlaces_1(_morePlaces_1) { }
impl_morePlaces_EmptyMorePlaces::impl_morePlaces_EmptyMorePlaces()
    { }
const enum_phyla impl_marking::phylum_sel_ = phylum_marking;
impl_marking_Marking::impl_marking_Marking(casestring _casestring_1, expression _expression_1, markingList _markingList_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), markingList_1(_markingList_1) { }
impl_marking_EmptyMarking::impl_marking_EmptyMarking()
    { }
const enum_phyla impl_markingList::phylum_sel_ = phylum_markingList;
impl_markingList_MarkingList::impl_markingList_MarkingList(casestring _casestring_1, expression _expression_1, markingList _markingList_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), markingList_1(_markingList_1) { }
impl_markingList_EmptyMarkingList::impl_markingList_EmptyMarkingList()
    { }
const enum_phyla impl_transition::phylum_sel_ = phylum_transition;
impl_transition_Transition::impl_transition_Transition(casestring _casestring_1, fairness _fairness_1, variable _variable_1, guard _guard_1, optIdentExprList _optIdentExprList_1, optIdentExprList _optIdentExprList_2, transition _transition_1)
    : casestring_1(_casestring_1), fairness_1(_fairness_1), variable_1(_variable_1), guard_1(_guard_1), optIdentExprList_1(_optIdentExprList_1), optIdentExprList_2(_optIdentExprList_2), transition_1(_transition_1) { }
impl_transition_EmptyTransition::impl_transition_EmptyTransition()
    { }
const enum_phyla impl_fairness::phylum_sel_ = phylum_fairness;
impl_fairness_StrongFair::impl_fairness_StrongFair()
    { }
impl_fairness_WeakFair::impl_fairness_WeakFair()
    { }
impl_fairness_EmptyFairness::impl_fairness_EmptyFairness()
    { }
const enum_phyla impl_variable::phylum_sel_ = phylum_variable;
impl_variable_Variable::impl_variable_Variable(type _type_1, varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1, variable _variable_1)
    : type_1(_type_1), varOrArray_1(_varOrArray_1), varOrArrayList_1(_varOrArrayList_1), variable_1(_variable_1) { }
impl_variable_EmptyVariable::impl_variable_EmptyVariable()
    { }
const enum_phyla impl_varOrArrayList::phylum_sel_ = phylum_varOrArrayList;
impl_varOrArrayList_VarOrArrayList::impl_varOrArrayList_VarOrArrayList(varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1)
    : varOrArray_1(_varOrArray_1), varOrArrayList_1(_varOrArrayList_1) { }
impl_varOrArrayList_EmptyVarOrArrayList::impl_varOrArrayList_EmptyVarOrArrayList()
    { }
const enum_phyla impl_guard::phylum_sel_ = phylum_guard;
impl_guard_Guard::impl_guard_Guard(expression _expression_1)
    : expression_1(_expression_1) { }
impl_guard_EmptyGuard::impl_guard_EmptyGuard()
    { }
const enum_phyla impl_optIdentExprList::phylum_sel_ = phylum_optIdentExprList;
impl_optIdentExprList_OptIdentExprList::impl_optIdentExprList_OptIdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), identExprList_1(_identExprList_1) { }
impl_optIdentExprList_EmptyOptIdentExprList::impl_optIdentExprList_EmptyOptIdentExprList()
    { }
const enum_phyla impl_identExprList::phylum_sel_ = phylum_identExprList;
impl_identExprList_IdentExprList::impl_identExprList_IdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), identExprList_1(_identExprList_1) { }
impl_identExprList_EmptyIdentExprList::impl_identExprList_EmptyIdentExprList()
    { }
const enum_phyla impl_block::phylum_sel_ = phylum_block;
impl_block_Block::impl_block_Block(declarationOrStatement _declarationOrStatement_1)
    : declarationOrStatement_1(_declarationOrStatement_1) { }
const enum_phyla impl_declarationOrStatement::phylum_sel_ = phylum_declarationOrStatement;
impl_declarationOrStatement_DeclOrStatemStatement::impl_declarationOrStatement_DeclOrStatemStatement(statement _statement_1, declarationOrStatement _declarationOrStatement_1)
    : statement_1(_statement_1), declarationOrStatement_1(_declarationOrStatement_1) { }
impl_declarationOrStatement_DeclOrStatemDeclaration::impl_declarationOrStatement_DeclOrStatemDeclaration(declaration _declaration_1, declarationOrStatement _declarationOrStatement_1)
    : declaration_1(_declaration_1), declarationOrStatement_1(_declarationOrStatement_1) { }
impl_declarationOrStatement_EmptyDeclarationOrStatement::impl_declarationOrStatement_EmptyDeclarationOrStatement()
    { }
const enum_phyla impl_declaration::phylum_sel_ = phylum_declaration;
impl_declaration_Declaration::impl_declaration_Declaration(type _type_1, varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1)
    : type_1(_type_1), varOrArray_1(_varOrArray_1), varOrArrayList_1(_varOrArrayList_1) { }
const enum_phyla impl_statement::phylum_sel_ = phylum_statement;
impl_statement_StatementReturn::impl_statement_StatementReturn(expression _expression_1)
    : expression_1(_expression_1) { }
impl_statement_StatementContinue::impl_statement_StatementContinue()
    { }
impl_statement_StatementBreak::impl_statement_StatementBreak()
    { }
impl_statement_StatementSwitch::impl_statement_StatementSwitch(expression _expression_1, switchCase _switchCase_1)
    : expression_1(_expression_1), switchCase_1(_switchCase_1) { }
impl_statement_StatementForAll::impl_statement_StatementForAll(type _type_1, casestring _casestring_1, type _type_2)
    : type_1(_type_1), casestring_1(_casestring_1), type_2(_type_2) { }
impl_statement_StatementForIdentColon::impl_statement_StatementForIdentColon(casestring _casestring_1, expression _expression_1, statement _statement_1)
    : casestring_1(_casestring_1), expression_1(_expression_1), statement_1(_statement_1) { }
impl_statement_StatementForTypeExpr::impl_statement_StatementForTypeExpr(type _type_1, casestring _casestring_1, expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1)
    : type_1(_type_1), casestring_1(_casestring_1), expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3), statement_1(_statement_1) { }
impl_statement_StatementForExpr::impl_statement_StatementForExpr(expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1)
    : expression_1(_expression_1), expression_2(_expression_2), expression_3(_expression_3), statement_1(_statement_1) { }
impl_statement_StatementDoWhile::impl_statement_StatementDoWhile(statement _statement_1, expression _expression_1)
    : statement_1(_statement_1), expression_1(_expression_1) { }
impl_statement_StatementWhile::impl_statement_StatementWhile(expression _expression_1, statement _statement_1)
    : expression_1(_expression_1), statement_1(_statement_1) { }
impl_statement_StatementIf::impl_statement_StatementIf(ifStatement _ifStatement_1)
    : ifStatement_1(_ifStatement_1) { }
impl_statement_StatementExprSemicolon::impl_statement_StatementExprSemicolon(expressionWithoutInitializer _expressionWithoutInitializer_1)
    : expressionWithoutInitializer_1(_expressionWithoutInitializer_1) { }
impl_statement_StatementBlock::impl_statement_StatementBlock(block _block_1)
    : block_1(_block_1) { }
impl_statement_StatementSemiolon::impl_statement_StatementSemiolon()
    { }
const enum_phyla impl_ifStatement::phylum_sel_ = phylum_ifStatement;
impl_ifStatement_IfStatement::impl_ifStatement_IfStatement(expression _expression_1, statement _statement_1, optElse _optElse_1)
    : expression_1(_expression_1), statement_1(_statement_1), optElse_1(_optElse_1) { }
const enum_phyla impl_optElse::phylum_sel_ = phylum_optElse;
impl_optElse_OptElse::impl_optElse_OptElse(statement _statement_1)
    : statement_1(_statement_1) { }
impl_optElse_OptElseEmpty::impl_optElse_OptElseEmpty()
    { }
const enum_phyla impl_switchCase::phylum_sel_ = phylum_switchCase;
impl_switchCase_SwitchDefault::impl_switchCase_SwitchDefault(statement _statement_1, switchCaseList _switchCaseList_1)
    : statement_1(_statement_1), switchCaseList_1(_switchCaseList_1) { }
impl_switchCase_SwitchCase::impl_switchCase_SwitchCase(expression _expression_1, statement _statement_1, switchCaseList _switchCaseList_1)
    : expression_1(_expression_1), statement_1(_statement_1), switchCaseList_1(_switchCaseList_1) { }
const enum_phyla impl_switchCaseList::phylum_sel_ = phylum_switchCaseList;
impl_switchCaseList_SwitchDefaultList::impl_switchCaseList_SwitchDefaultList(statement _statement_1, switchCaseList _switchCaseList_1)
    : statement_1(_statement_1), switchCaseList_1(_switchCaseList_1) { }
impl_switchCaseList_SwitchCaseList::impl_switchCaseList_SwitchCaseList(expression _expression_1, statement _statement_1, switchCaseList _switchCaseList_1)
    : expression_1(_expression_1), statement_1(_statement_1), switchCaseList_1(_switchCaseList_1) { }
impl_switchCaseList_EmptySwitchCaseList::impl_switchCaseList_EmptySwitchCaseList()
    { }

#ifdef KC_STATISTICS
KC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];
static int kc_casestring_strlen =0;
static int kc_nocasestring_strlen =0;
#  define KC_COLLECT_STATS0(v) v
#else
#  define KC_COLLECT_STATS0(v)
#endif

#ifndef KC_CREATE_STATS
#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;
#endif
#ifndef KC_EXISTINGNOTFOUND_STATS
#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;
#endif

#ifndef KC_FREE_CALLED_STATS
#  define KC_FREE_CALLED_STATS(oper,rec) operator_statistics[oper].free_called[(rec?true:false)]++;
#endif

#ifndef KC_FREED_STATS
#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;
#endif
static hashtable_struct_t kc_not_uniq_static_hashtable;
static hashtable_struct_t uniq_static_hashtable;

bool kc_storageclass_still_uniq[] = {
    true, true };

hashtable_t hashtables[] = {
    &kc_not_uniq_static_hashtable,
    &uniq_static_hashtable,
};

const char* kc_storageclassnames[] = { "kc_not_uniq", "uniq" };

namespace { // all local to k.cc

expression kc_initialize_expression(expression kc_x)
{
#line 103 "abstract.k"
    kc_x->check =  UNDEF;
#line 104 "abstract.k"
    kc_x->isConst =  false;
#line 105 "abstract.k"
    kc_x->constValue =  0;

#line  3815 "k.cc"
    return kc_x;
}

expressionWithoutInitializer kc_initialize_expressionWithoutInitializer(expressionWithoutInitializer kc_x)
{
#line 118 "abstract.k"
    kc_x->check =  UNDEF;

#line  3824 "k.cc"
    return kc_x;
}

assignment kc_initialize_assignment(assignment kc_x)
{
#line 128 "abstract.k"
    kc_x->check =  UNDEF;

#line  3833 "k.cc"
    return kc_x;
}

arithmetic kc_initialize_arithmetic(arithmetic kc_x)
{
#line 147 "abstract.k"
    kc_x->check =  UNDEF;

#line  3842 "k.cc"
    return kc_x;
}

arithmeticWithoutInitializer kc_initialize_arithmeticWithoutInitializer(arithmeticWithoutInitializer kc_x)
{
#line 159 "abstract.k"
    kc_x->check =  UNDEF;

#line  3851 "k.cc"
    return kc_x;
}

logical kc_initialize_logical(logical kc_x)
{
#line 168 "abstract.k"
    kc_x->check =  UNDEF;

#line  3860 "k.cc"
    return kc_x;
}

logicalWithoutInitializer kc_initialize_logicalWithoutInitializer(logicalWithoutInitializer kc_x)
{
#line 177 "abstract.k"
    kc_x->check =  UNDEF;

#line  3869 "k.cc"
    return kc_x;
}

comparison kc_initialize_comparison(comparison kc_x)
{
#line 187 "abstract.k"
    kc_x->check =  UNDEF;

#line  3878 "k.cc"
    return kc_x;
}

comparisonWithoutInitializer kc_initialize_comparisonWithoutInitializer(comparisonWithoutInitializer kc_x)
{
#line 197 "abstract.k"
    kc_x->check =  UNDEF;

#line  3887 "k.cc"
    return kc_x;
}

other kc_initialize_other(other kc_x)
{
#line 212 "abstract.k"
    kc_x->check =  UNDEF;

#line  3896 "k.cc"
    return kc_x;
}

otherWithoutInitializer kc_initialize_otherWithoutInitializer(otherWithoutInitializer kc_x)
{
#line 221 "abstract.k"
    kc_x->check =  UNDEF;

#line  3905 "k.cc"
    return kc_x;
}


} // namespace

enum_phyla
impl_abstract_phylum::phylum() const {
    return operator_info[prod_sel()].phylum;
}

const char*
impl_abstract_phylum::phylum_name() const {
    return phylum_info[phylum()].name;
}

const char*
impl_abstract_phylum::op_name() const {
    return operator_info[prod_sel()].name;
}

casestring
mkcasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));

    casestring kc_x=new impl_casestring__Str(kc_s);
    if(length>=0) 
	kc_x->make_own(length);

    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0) 
	    kc_x->name=0;

	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));
	if(length<0) 
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));

	kc_x->post_create();
    }
    return kc_x;
}

nocasestring
mknocasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));

    nocasestring kc_x=new impl_nocasestring_NoCaseStr(kc_s);
    if(length>=0)
	kc_x->make_own(length);
    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0)
	    kc_x->name=0;
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));
	if(length<0)
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));
	kc_x->post_create();
    }

    return kc_x;
}

integer
mkinteger(const INTEGER kc_i)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));

    integer kc_x =new impl_integer__Int(kc_i);
    integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));
	kc_x->post_create();
    }

    return kc_x;
}

real
mkreal(const REAL kc_r)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));

    real kc_x=new impl_real__Real(kc_r);
    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));
	kc_x->post_create();
    }

    return kc_x;
}

voidptr
mkvoidptr(void *kc_p)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));
    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);
    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));
	kc_x->post_create();
    }
    return kc_x;
}

impl_net_Net*
Net(netName _netName_1, definitionsList _definitionsList_1, places _places_1, marking _marking_1, transition _transition_1) {
    assertPhylum(_netName_1, phylum_netName);
    assertPhylum(_definitionsList_1, phylum_definitionsList);
    assertPhylum(_places_1, phylum_places);
    assertPhylum(_marking_1, phylum_marking);
    assertPhylum(_transition_1, phylum_transition);
    net kc_x = new impl_net_Net(_netName_1, _definitionsList_1, _places_1, _marking_1, _transition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Net));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Net));
    kc_x->post_create();
    return static_cast<impl_net_Net*>(kc_x);
}

impl_netName_EmptyNetName*
EmptyNetName() {
    netName kc_x = new impl_netName_EmptyNetName();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyNetName));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyNetName));
    kc_x->post_create();
    return static_cast<impl_netName_EmptyNetName*>(kc_x);
}

impl_netName_NetName*
NetName(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    netName kc_x = new impl_netName_NetName(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NetName));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NetName));
    kc_x->post_create();
    return static_cast<impl_netName_NetName*>(kc_x);
}

impl_definitionsList_EmptyDefinitionsList*
EmptyDefinitionsList() {
    definitionsList kc_x = new impl_definitionsList_EmptyDefinitionsList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyDefinitionsList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyDefinitionsList));
    kc_x->post_create();
    return static_cast<impl_definitionsList_EmptyDefinitionsList*>(kc_x);
}

impl_definitionsList_DefinitionsList*
DefinitionsList(definitionsList _definitionsList_1, definitions _definitions_1) {
    assertPhylum(_definitionsList_1, phylum_definitionsList);
    assertPhylum(_definitions_1, phylum_definitions);
    definitionsList kc_x = new impl_definitionsList_DefinitionsList(_definitionsList_1, _definitions_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DefinitionsList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DefinitionsList));
    kc_x->post_create();
    return static_cast<impl_definitionsList_DefinitionsList*>(kc_x);
}

impl_definitions_DefSort*
DefSort(sort _sort_1) {
    assertPhylum(_sort_1, phylum_sort);
    definitions kc_x = new impl_definitions_DefSort(_sort_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DefSort));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DefSort));
    kc_x->post_create();
    return static_cast<impl_definitions_DefSort*>(kc_x);
}

impl_definitions_DefFunction*
DefFunction(function _function_1) {
    assertPhylum(_function_1, phylum_function);
    definitions kc_x = new impl_definitions_DefFunction(_function_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DefFunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DefFunction));
    kc_x->post_create();
    return static_cast<impl_definitions_DefFunction*>(kc_x);
}

impl_definitions_DefConstant*
DefConstant(constant _constant_1) {
    assertPhylum(_constant_1, phylum_constant);
    definitions kc_x = new impl_definitions_DefConstant(_constant_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DefConstant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DefConstant));
    kc_x->post_create();
    return static_cast<impl_definitions_DefConstant*>(kc_x);
}

impl_sort_Sort*
Sort(type _type_1, casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    sort kc_x = new impl_sort_Sort(_type_1, _casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Sort));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Sort));
    kc_x->post_create();
    return static_cast<impl_sort_Sort*>(kc_x);
}

impl_type_TypeBool*
TypeBool() {
    type kc_x = new impl_type_TypeBool();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeBool));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeBool));
    kc_x->post_create();
    return static_cast<impl_type_TypeBool*>(kc_x);
}

impl_type_TypeEnum*
TypeEnum(identList _identList_1) {
    assertPhylum(_identList_1, phylum_identList);
    type kc_x = new impl_type_TypeEnum(_identList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeEnum));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeEnum));
    kc_x->post_create();
    return static_cast<impl_type_TypeEnum*>(kc_x);
}

impl_type_TypeIdent*
TypeIdent(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    type kc_x = new impl_type_TypeIdent(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeIdent));
    kc_x->post_create();
    return static_cast<impl_type_TypeIdent*>(kc_x);
}

impl_type_TypeIntInterval*
TypeIntInterval(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    type kc_x = new impl_type_TypeIntInterval(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeIntInterval));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeIntInterval));
    kc_x->post_create();
    return static_cast<impl_type_TypeIntInterval*>(kc_x);
}

impl_type_TypeStruct*
TypeStruct(structTypeList _structTypeList_1) {
    assertPhylum(_structTypeList_1, phylum_structTypeList);
    type kc_x = new impl_type_TypeStruct(_structTypeList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeStruct));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeStruct));
    kc_x->post_create();
    return static_cast<impl_type_TypeStruct*>(kc_x);
}

impl_type_TypeInt*
TypeInt() {
    type kc_x = new impl_type_TypeInt();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeInt));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeInt));
    kc_x->post_create();
    return static_cast<impl_type_TypeInt*>(kc_x);
}

impl_type_TypeMultiset*
TypeMultiset(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    type kc_x = new impl_type_TypeMultiset(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TypeMultiset));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TypeMultiset));
    kc_x->post_create();
    return static_cast<impl_type_TypeMultiset*>(kc_x);
}

impl_identList_EmptyIdentList*
EmptyIdentList() {
    identList kc_x = new impl_identList_EmptyIdentList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyIdentList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyIdentList));
    kc_x->post_create();
    return static_cast<impl_identList_EmptyIdentList*>(kc_x);
}

impl_identList_IdentList*
IdentList(identList _identList_1, idents _idents_1) {
    assertPhylum(_identList_1, phylum_identList);
    assertPhylum(_idents_1, phylum_idents);
    identList kc_x = new impl_identList_IdentList(_identList_1, _idents_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IdentList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IdentList));
    kc_x->post_create();
    return static_cast<impl_identList_IdentList*>(kc_x);
}

impl_idents_Ident*
Ident(casestring _casestring_1, integer _integer_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_integer_1, phylum_integer);
    idents kc_x = new impl_idents_Ident(_casestring_1, _integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Ident));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Ident));
    kc_x->post_create();
    return static_cast<impl_idents_Ident*>(kc_x);
}

impl_structTypeList_SingleStructTypeList*
SingleStructTypeList(structType _structType_1) {
    assertPhylum(_structType_1, phylum_structType);
    structTypeList kc_x = new impl_structTypeList_SingleStructTypeList(_structType_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SingleStructTypeList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SingleStructTypeList));
    kc_x->post_create();
    return static_cast<impl_structTypeList_SingleStructTypeList*>(kc_x);
}

impl_structTypeList_StructTypeList*
StructTypeList(structTypeList _structTypeList_1, structType _structType_1) {
    assertPhylum(_structTypeList_1, phylum_structTypeList);
    assertPhylum(_structType_1, phylum_structType);
    structTypeList kc_x = new impl_structTypeList_StructTypeList(_structTypeList_1, _structType_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StructTypeList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StructTypeList));
    kc_x->post_create();
    return static_cast<impl_structTypeList_StructTypeList*>(kc_x);
}

impl_structType_StructType*
StructType(type _type_1, casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    structType kc_x = new impl_structType_StructType(_type_1, _casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StructType));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StructType));
    kc_x->post_create();
    return static_cast<impl_structType_StructType*>(kc_x);
}

impl_varOrArray_VarOrArray*
VarOrArray(casestring _casestring_1, arrayList _arrayList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    varOrArray kc_x = new impl_varOrArray_VarOrArray(_casestring_1, _arrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VarOrArray));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VarOrArray));
    kc_x->post_create();
    return static_cast<impl_varOrArray_VarOrArray*>(kc_x);
}

impl_arrayList_EmptyArrayList*
EmptyArrayList() {
    arrayList kc_x = new impl_arrayList_EmptyArrayList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyArrayList));
    kc_x->post_create();
    return static_cast<impl_arrayList_EmptyArrayList*>(kc_x);
}

impl_arrayList_ArrayList*
ArrayList(arrayList _arrayList_1, array _array_1) {
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_array_1, phylum_array);
    arrayList kc_x = new impl_arrayList_ArrayList(_arrayList_1, _array_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ArrayList));
    kc_x->post_create();
    return static_cast<impl_arrayList_ArrayList*>(kc_x);
}

impl_array_Array*
Array(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    array kc_x = new impl_array_Array(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Array));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Array));
    kc_x->post_create();
    return static_cast<impl_array_Array*>(kc_x);
}

impl_function_Function*
Function(type _type_1, casestring _casestring_1, arrayList _arrayList_1, optFunctionParameters _optFunctionParameters_1, block _block_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_optFunctionParameters_1, phylum_optFunctionParameters);
    assertPhylum(_block_1, phylum_block);
    function kc_x = new impl_function_Function(_type_1, _casestring_1, _arrayList_1, _optFunctionParameters_1, _block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Function));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Function));
    kc_x->post_create();
    return static_cast<impl_function_Function*>(kc_x);
}

impl_optFunctionParameters_EmptyOptFunctionParameters*
EmptyOptFunctionParameters() {
    optFunctionParameters kc_x = new impl_optFunctionParameters_EmptyOptFunctionParameters();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyOptFunctionParameters));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyOptFunctionParameters));
    kc_x->post_create();
    return static_cast<impl_optFunctionParameters_EmptyOptFunctionParameters*>(kc_x);
}

impl_optFunctionParameters_OptFunctionParameters*
OptFunctionParameters(type _type_1, varOrArray _varOrArray_1, functionParametersList _functionParametersList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    assertPhylum(_functionParametersList_1, phylum_functionParametersList);
    optFunctionParameters kc_x = new impl_optFunctionParameters_OptFunctionParameters(_type_1, _varOrArray_1, _functionParametersList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_OptFunctionParameters));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_OptFunctionParameters));
    kc_x->post_create();
    return static_cast<impl_optFunctionParameters_OptFunctionParameters*>(kc_x);
}

impl_functionParametersList_EmptyFunctionParametersList*
EmptyFunctionParametersList() {
    functionParametersList kc_x = new impl_functionParametersList_EmptyFunctionParametersList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyFunctionParametersList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyFunctionParametersList));
    kc_x->post_create();
    return static_cast<impl_functionParametersList_EmptyFunctionParametersList*>(kc_x);
}

impl_functionParametersList_FunctionParametersList*
FunctionParametersList(functionParametersList _functionParametersList_1, functionParameters _functionParameters_1) {
    assertPhylum(_functionParametersList_1, phylum_functionParametersList);
    assertPhylum(_functionParameters_1, phylum_functionParameters);
    functionParametersList kc_x = new impl_functionParametersList_FunctionParametersList(_functionParametersList_1, _functionParameters_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionParametersList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionParametersList));
    kc_x->post_create();
    return static_cast<impl_functionParametersList_FunctionParametersList*>(kc_x);
}

impl_functionParameters_FunctionParameters*
FunctionParameters(type _type_1, varOrArray _varOrArray_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    functionParameters kc_x = new impl_functionParameters_FunctionParameters(_type_1, _varOrArray_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_FunctionParameters));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_FunctionParameters));
    kc_x->post_create();
    return static_cast<impl_functionParameters_FunctionParameters*>(kc_x);
}

impl_constant_Constant*
Constant(type _type_1, casestring _casestring_1, arrayList _arrayList_1, expression _expression_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_arrayList_1, phylum_arrayList);
    assertPhylum(_expression_1, phylum_expression);
    constant kc_x = new impl_constant_Constant(_type_1, _casestring_1, _arrayList_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Constant));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Constant));
    kc_x->post_create();
    return static_cast<impl_constant_Constant*>(kc_x);
}

impl_expression_ExprAssignment*
ExprAssignment(assignment _assignment_1) {
    assertPhylum(_assignment_1, phylum_assignment);
    expression kc_x = new impl_expression_ExprAssignment(_assignment_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAssignment));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAssignment));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprAssignment*>(kc_x);
}

impl_expression_ExprIncdecrement*
ExprIncdecrement(incdecrement _incdecrement_1) {
    assertPhylum(_incdecrement_1, phylum_incdecrement);
    expression kc_x = new impl_expression_ExprIncdecrement(_incdecrement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIncdecrement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIncdecrement));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprIncdecrement*>(kc_x);
}

impl_expression_ExprArithmetic*
ExprArithmetic(arithmetic _arithmetic_1) {
    assertPhylum(_arithmetic_1, phylum_arithmetic);
    expression kc_x = new impl_expression_ExprArithmetic(_arithmetic_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprArithmetic));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprArithmetic));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprArithmetic*>(kc_x);
}

impl_expression_ExprLogical*
ExprLogical(logical _logical_1) {
    assertPhylum(_logical_1, phylum_logical);
    expression kc_x = new impl_expression_ExprLogical(_logical_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLogical));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLogical));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprLogical*>(kc_x);
}

impl_expression_ExprComparison*
ExprComparison(comparison _comparison_1) {
    assertPhylum(_comparison_1, phylum_comparison);
    expression kc_x = new impl_expression_ExprComparison(_comparison_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprComparison));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprComparison));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprComparison*>(kc_x);
}

impl_expression_ExprLeftvalue*
ExprLeftvalue(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expression kc_x = new impl_expression_ExprLeftvalue(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLeftvalue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLeftvalue));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprLeftvalue*>(kc_x);
}

impl_expression_ExprOther*
ExprOther(other _other_1) {
    assertPhylum(_other_1, phylum_other);
    expression kc_x = new impl_expression_ExprOther(_other_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOther));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOther));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprOther*>(kc_x);
}

impl_expression_ExprInitializerList*
ExprInitializerList(initializerList _initializerList_1) {
    assertPhylum(_initializerList_1, phylum_initializerList);
    expression kc_x = new impl_expression_ExprInitializerList(_initializerList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInitializerList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInitializerList));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprInitializerList*>(kc_x);
}

impl_expression_ExprInParenthesis*
ExprInParenthesis(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expression kc_x = new impl_expression_ExprInParenthesis(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInParenthesis));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInParenthesis));
    kc_x->post_create();
    kc_x = kc_initialize_expression(kc_x);
    return static_cast<impl_expression_ExprInParenthesis*>(kc_x);
}

impl_expressionWithoutInitializer_ExprAssignment2*
ExprAssignment2(assignment _assignment_1) {
    assertPhylum(_assignment_1, phylum_assignment);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprAssignment2(_assignment_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAssignment2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAssignment2));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprAssignment2*>(kc_x);
}

impl_expressionWithoutInitializer_ExprIncdecrement2*
ExprIncdecrement2(incdecrement _incdecrement_1) {
    assertPhylum(_incdecrement_1, phylum_incdecrement);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprIncdecrement2(_incdecrement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIncdecrement2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIncdecrement2));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprIncdecrement2*>(kc_x);
}

impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer*
ExprArithmeticWithoutInitializer(arithmeticWithoutInitializer _arithmeticWithoutInitializer_1) {
    assertPhylum(_arithmeticWithoutInitializer_1, phylum_arithmeticWithoutInitializer);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer(_arithmeticWithoutInitializer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprArithmeticWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprArithmeticWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer*>(kc_x);
}

impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer*
ExprLogicalWithoutInitializer(logicalWithoutInitializer _logicalWithoutInitializer_1) {
    assertPhylum(_logicalWithoutInitializer_1, phylum_logicalWithoutInitializer);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer(_logicalWithoutInitializer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLogicalWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLogicalWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer*>(kc_x);
}

impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer*
ExprComparisonWithoutInitializer(comparisonWithoutInitializer _comparisonWithoutInitializer_1) {
    assertPhylum(_comparisonWithoutInitializer_1, phylum_comparisonWithoutInitializer);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer(_comparisonWithoutInitializer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprComparisonWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprComparisonWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer*>(kc_x);
}

impl_expressionWithoutInitializer_ExprLeftvalue2*
ExprLeftvalue2(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprLeftvalue2(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLeftvalue2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLeftvalue2));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprLeftvalue2*>(kc_x);
}

impl_expressionWithoutInitializer_ExprOtherWithoutInitializer*
ExprOtherWithoutInitializer(otherWithoutInitializer _otherWithoutInitializer_1) {
    assertPhylum(_otherWithoutInitializer_1, phylum_otherWithoutInitializer);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprOtherWithoutInitializer(_otherWithoutInitializer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOtherWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOtherWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprOtherWithoutInitializer*>(kc_x);
}

impl_expressionWithoutInitializer_ExprInParenthesis2*
ExprInParenthesis2(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    expressionWithoutInitializer kc_x = new impl_expressionWithoutInitializer_ExprInParenthesis2(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInParenthesis2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInParenthesis2));
    kc_x->post_create();
    kc_x = kc_initialize_expressionWithoutInitializer(kc_x);
    return static_cast<impl_expressionWithoutInitializer_ExprInParenthesis2*>(kc_x);
}

impl_assignment_AssignEqual*
AssignEqual(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignEqual(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignEqual));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignEqual*>(kc_x);
}

impl_assignment_AssignPlus*
AssignPlus(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignPlus(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignPlus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignPlus));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignPlus*>(kc_x);
}

impl_assignment_AssignMinus*
AssignMinus(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignMinus(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignMinus));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignMinus));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignMinus*>(kc_x);
}

impl_assignment_AssignTimes*
AssignTimes(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignTimes(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignTimes));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignTimes));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignTimes*>(kc_x);
}

impl_assignment_AssignDivide*
AssignDivide(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignDivide(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignDivide));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignDivide));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignDivide*>(kc_x);
}

impl_assignment_AssignMod*
AssignMod(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    assignment kc_x = new impl_assignment_AssignMod(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AssignMod));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AssignMod));
    kc_x->post_create();
    kc_x = kc_initialize_assignment(kc_x);
    return static_cast<impl_assignment_AssignMod*>(kc_x);
}

impl_incdecrement_IncrementVal*
IncrementVal(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    incdecrement kc_x = new impl_incdecrement_IncrementVal(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IncrementVal));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IncrementVal));
    kc_x->post_create();
    return static_cast<impl_incdecrement_IncrementVal*>(kc_x);
}

impl_incdecrement_DecrementVal*
DecrementVal(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    incdecrement kc_x = new impl_incdecrement_DecrementVal(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DecrementVal));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DecrementVal));
    kc_x->post_create();
    return static_cast<impl_incdecrement_DecrementVal*>(kc_x);
}

impl_incdecrement_ValIncrement*
ValIncrement(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    incdecrement kc_x = new impl_incdecrement_ValIncrement(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ValIncrement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ValIncrement));
    kc_x->post_create();
    return static_cast<impl_incdecrement_ValIncrement*>(kc_x);
}

impl_incdecrement_ValDecrement*
ValDecrement(leftvalue _leftvalue_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    incdecrement kc_x = new impl_incdecrement_ValDecrement(_leftvalue_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ValDecrement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ValDecrement));
    kc_x->post_create();
    return static_cast<impl_incdecrement_ValDecrement*>(kc_x);
}

impl_arithmetic_PositiveExpr*
PositiveExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_PositiveExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PositiveExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PositiveExpr));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_PositiveExpr*>(kc_x);
}

impl_arithmetic_NegativeExpr*
NegativeExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_NegativeExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NegativeExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NegativeExpr));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_NegativeExpr*>(kc_x);
}

impl_arithmetic_ExprAddition*
ExprAddition(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_ExprAddition(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAddition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAddition));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprAddition*>(kc_x);
}

impl_arithmetic_ExprSubtraction*
ExprSubtraction(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_ExprSubtraction(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprSubtraction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprSubtraction));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprSubtraction*>(kc_x);
}

impl_arithmetic_ExprMultiplication*
ExprMultiplication(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_ExprMultiplication(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprMultiplication));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprMultiplication));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprMultiplication*>(kc_x);
}

impl_arithmetic_ExprDivision*
ExprDivision(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_ExprDivision(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprDivision));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprDivision));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprDivision*>(kc_x);
}

impl_arithmetic_ExprModulo*
ExprModulo(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    arithmetic kc_x = new impl_arithmetic_ExprModulo(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprModulo));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprModulo));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprModulo*>(kc_x);
}

impl_arithmetic_ExprNumber*
ExprNumber(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    arithmetic kc_x = new impl_arithmetic_ExprNumber(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNumber));
    kc_x->post_create();
    kc_x = kc_initialize_arithmetic(kc_x);
    return static_cast<impl_arithmetic_ExprNumber*>(kc_x);
}

impl_arithmeticWithoutInitializer_PositiveExpr2*
PositiveExpr2(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_PositiveExpr2(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PositiveExpr2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PositiveExpr2));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_PositiveExpr2*>(kc_x);
}

impl_arithmeticWithoutInitializer_NegativeExpr2*
NegativeExpr2(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_NegativeExpr2(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NegativeExpr2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NegativeExpr2));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_NegativeExpr2*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer*
ExprAdditionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAdditionWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAdditionWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer*
ExprSubtractionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprSubtractionWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprSubtractionWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer*
ExprMultiplicationWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprMultiplicationWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprMultiplicationWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer*
ExprDivisionWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprDivisionWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprDivisionWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer*
ExprModuloWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprModuloWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprModuloWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer*>(kc_x);
}

impl_arithmeticWithoutInitializer_ExprNumber2*
ExprNumber2(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    arithmeticWithoutInitializer kc_x = new impl_arithmeticWithoutInitializer_ExprNumber2(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNumber2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNumber2));
    kc_x->post_create();
    kc_x = kc_initialize_arithmeticWithoutInitializer(kc_x);
    return static_cast<impl_arithmeticWithoutInitializer_ExprNumber2*>(kc_x);
}

impl_logical_NotExpr*
NotExpr(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    logical kc_x = new impl_logical_NotExpr(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NotExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NotExpr));
    kc_x->post_create();
    kc_x = kc_initialize_logical(kc_x);
    return static_cast<impl_logical_NotExpr*>(kc_x);
}

impl_logical_ExprAnd*
ExprAnd(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    logical kc_x = new impl_logical_ExprAnd(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAnd));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAnd));
    kc_x->post_create();
    kc_x = kc_initialize_logical(kc_x);
    return static_cast<impl_logical_ExprAnd*>(kc_x);
}

impl_logical_ExprOr*
ExprOr(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    logical kc_x = new impl_logical_ExprOr(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOr));
    kc_x->post_create();
    kc_x = kc_initialize_logical(kc_x);
    return static_cast<impl_logical_ExprOr*>(kc_x);
}

impl_logical_ExprTrue*
ExprTrue() {
    logical kc_x = new impl_logical_ExprTrue();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprTrue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprTrue));
    kc_x->post_create();
    kc_x = kc_initialize_logical(kc_x);
    return static_cast<impl_logical_ExprTrue*>(kc_x);
}

impl_logical_ExprFalse*
ExprFalse() {
    logical kc_x = new impl_logical_ExprFalse();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprFalse));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprFalse));
    kc_x->post_create();
    kc_x = kc_initialize_logical(kc_x);
    return static_cast<impl_logical_ExprFalse*>(kc_x);
}

impl_logicalWithoutInitializer_NotExpr2*
NotExpr2(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    logicalWithoutInitializer kc_x = new impl_logicalWithoutInitializer_NotExpr2(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NotExpr2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NotExpr2));
    kc_x->post_create();
    kc_x = kc_initialize_logicalWithoutInitializer(kc_x);
    return static_cast<impl_logicalWithoutInitializer_NotExpr2*>(kc_x);
}

impl_logicalWithoutInitializer_ExprAndWithoutInitializer*
ExprAndWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    logicalWithoutInitializer kc_x = new impl_logicalWithoutInitializer_ExprAndWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAndWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAndWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_logicalWithoutInitializer(kc_x);
    return static_cast<impl_logicalWithoutInitializer_ExprAndWithoutInitializer*>(kc_x);
}

impl_logicalWithoutInitializer_ExprOrWithoutInitializer*
ExprOrWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    logicalWithoutInitializer kc_x = new impl_logicalWithoutInitializer_ExprOrWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOrWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOrWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_logicalWithoutInitializer(kc_x);
    return static_cast<impl_logicalWithoutInitializer_ExprOrWithoutInitializer*>(kc_x);
}

impl_logicalWithoutInitializer_ExprTrue2*
ExprTrue2() {
    logicalWithoutInitializer kc_x = new impl_logicalWithoutInitializer_ExprTrue2();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprTrue2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprTrue2));
    kc_x->post_create();
    kc_x = kc_initialize_logicalWithoutInitializer(kc_x);
    return static_cast<impl_logicalWithoutInitializer_ExprTrue2*>(kc_x);
}

impl_logicalWithoutInitializer_ExprFalse2*
ExprFalse2() {
    logicalWithoutInitializer kc_x = new impl_logicalWithoutInitializer_ExprFalse2();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprFalse2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprFalse2));
    kc_x->post_create();
    kc_x = kc_initialize_logicalWithoutInitializer(kc_x);
    return static_cast<impl_logicalWithoutInitializer_ExprFalse2*>(kc_x);
}

impl_comparison_ExprEquivalent*
ExprEquivalent(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprEquivalent(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprEquivalent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprEquivalent));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprEquivalent*>(kc_x);
}

impl_comparison_ExprNotEqual*
ExprNotEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprNotEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNotEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNotEqual));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprNotEqual*>(kc_x);
}

impl_comparison_ExprLessThan*
ExprLessThan(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprLessThan(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessThan));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessThan));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprLessThan*>(kc_x);
}

impl_comparison_ExprGreaterThan*
ExprGreaterThan(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprGreaterThan(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterThan));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterThan));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprGreaterThan*>(kc_x);
}

impl_comparison_ExprLessOrEqual*
ExprLessOrEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprLessOrEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessOrEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessOrEqual));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprLessOrEqual*>(kc_x);
}

impl_comparison_ExprGreaterOrEqual*
ExprGreaterOrEqual(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    comparison kc_x = new impl_comparison_ExprGreaterOrEqual(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterOrEqual));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterOrEqual));
    kc_x->post_create();
    kc_x = kc_initialize_comparison(kc_x);
    return static_cast<impl_comparison_ExprGreaterOrEqual*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer*
ExprEquivalentWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprEquivalentWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprEquivalentWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer*
ExprNotEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprNotEqualWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprNotEqualWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer*
ExprLessThanWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessThanWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessThanWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer*
ExprGreaterThanWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterThanWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterThanWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer*
ExprLessOrEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprLessOrEqualWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprLessOrEqualWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer*>(kc_x);
}

impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer*
ExprGreaterOrEqualWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    comparisonWithoutInitializer kc_x = new impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprGreaterOrEqualWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprGreaterOrEqualWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_comparisonWithoutInitializer(kc_x);
    return static_cast<impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer*>(kc_x);
}

impl_leftvalue_LeftValIdent*
LeftValIdent(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    leftvalue kc_x = new impl_leftvalue_LeftValIdent(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValIdent));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValIdent*>(kc_x);
}

impl_leftvalue_LeftValBrackets*
LeftValBrackets(leftvalue _leftvalue_1, expression _expression_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_expression_1, phylum_expression);
    leftvalue kc_x = new impl_leftvalue_LeftValBrackets(_leftvalue_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValBrackets));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValBrackets));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValBrackets*>(kc_x);
}

impl_leftvalue_LeftValDot*
LeftValDot(leftvalue _leftvalue_1, casestring _casestring_1) {
    assertPhylum(_leftvalue_1, phylum_leftvalue);
    assertPhylum(_casestring_1, phylum_casestring);
    leftvalue kc_x = new impl_leftvalue_LeftValDot(_leftvalue_1, _casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LeftValDot));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LeftValDot));
    kc_x->post_create();
    return static_cast<impl_leftvalue_LeftValDot*>(kc_x);
}

impl_other_ExprIdentParenthesis*
ExprIdentParenthesis(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    other kc_x = new impl_other_ExprIdentParenthesis(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIdentParenthesis));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIdentParenthesis));
    kc_x->post_create();
    kc_x = kc_initialize_other(kc_x);
    return static_cast<impl_other_ExprIdentParenthesis*>(kc_x);
}

impl_other_ExprIdentExprInParenthesis*
ExprIdentExprInParenthesis(casestring _casestring_1, expression _expression_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    other kc_x = new impl_other_ExprIdentExprInParenthesis(_casestring_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIdentExprInParenthesis));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIdentExprInParenthesis));
    kc_x->post_create();
    kc_x = kc_initialize_other(kc_x);
    return static_cast<impl_other_ExprIdentExprInParenthesis*>(kc_x);
}

impl_other_ExprCommaSeparated*
ExprCommaSeparated(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    other kc_x = new impl_other_ExprCommaSeparated(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprCommaSeparated));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprCommaSeparated));
    kc_x->post_create();
    kc_x = kc_initialize_other(kc_x);
    return static_cast<impl_other_ExprCommaSeparated*>(kc_x);
}

impl_other_ExprOtherIf*
ExprOtherIf(expression _expression_1, expression _expression_2, expression _expression_3) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    other kc_x = new impl_other_ExprOtherIf(_expression_1, _expression_2, _expression_3);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOtherIf));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOtherIf));
    kc_x->post_create();
    kc_x = kc_initialize_other(kc_x);
    return static_cast<impl_other_ExprOtherIf*>(kc_x);
}

impl_other_ExprAll*
ExprAll(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    other kc_x = new impl_other_ExprAll(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAll));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAll));
    kc_x->post_create();
    kc_x = kc_initialize_other(kc_x);
    return static_cast<impl_other_ExprAll*>(kc_x);
}

impl_otherWithoutInitializer_ExprIdentParenthesis2*
ExprIdentParenthesis2(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    otherWithoutInitializer kc_x = new impl_otherWithoutInitializer_ExprIdentParenthesis2(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIdentParenthesis2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIdentParenthesis2));
    kc_x->post_create();
    kc_x = kc_initialize_otherWithoutInitializer(kc_x);
    return static_cast<impl_otherWithoutInitializer_ExprIdentParenthesis2*>(kc_x);
}

impl_otherWithoutInitializer_ExprIdentExprInParenthesis2*
ExprIdentExprInParenthesis2(casestring _casestring_1, expression _expression_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    otherWithoutInitializer kc_x = new impl_otherWithoutInitializer_ExprIdentExprInParenthesis2(_casestring_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprIdentExprInParenthesis2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprIdentExprInParenthesis2));
    kc_x->post_create();
    kc_x = kc_initialize_otherWithoutInitializer(kc_x);
    return static_cast<impl_otherWithoutInitializer_ExprIdentExprInParenthesis2*>(kc_x);
}

impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer*
ExprCommaSeparatedWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    otherWithoutInitializer kc_x = new impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer(_expressionWithoutInitializer_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprCommaSeparatedWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprCommaSeparatedWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_otherWithoutInitializer(kc_x);
    return static_cast<impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer*>(kc_x);
}

impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer*
ExprOtherIfWithoutInitializer(expressionWithoutInitializer _expressionWithoutInitializer_1, expression _expression_1, expression _expression_2) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    otherWithoutInitializer kc_x = new impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer(_expressionWithoutInitializer_1, _expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprOtherIfWithoutInitializer));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprOtherIfWithoutInitializer));
    kc_x->post_create();
    kc_x = kc_initialize_otherWithoutInitializer(kc_x);
    return static_cast<impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer*>(kc_x);
}

impl_otherWithoutInitializer_ExprAll2*
ExprAll2(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    otherWithoutInitializer kc_x = new impl_otherWithoutInitializer_ExprAll2(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprAll2));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprAll2));
    kc_x->post_create();
    kc_x = kc_initialize_otherWithoutInitializer(kc_x);
    return static_cast<impl_otherWithoutInitializer_ExprAll2*>(kc_x);
}

impl_initializerList_Braces*
Braces() {
    initializerList kc_x = new impl_initializerList_Braces();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Braces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Braces));
    kc_x->post_create();
    return static_cast<impl_initializerList_Braces*>(kc_x);
}

impl_initializerList_ExprInBraces*
ExprInBraces(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    initializerList kc_x = new impl_initializerList_ExprInBraces(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInBraces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInBraces));
    kc_x->post_create();
    return static_cast<impl_initializerList_ExprInBraces*>(kc_x);
}

impl_initializerList_ExprInBracesColon*
ExprInBracesColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expressionListColon_1, phylum_expressionListColon);
    initializerList kc_x = new impl_initializerList_ExprInBracesColon(_expression_1, _expression_2, _expressionListColon_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExprInBracesColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExprInBracesColon));
    kc_x->post_create();
    return static_cast<impl_initializerList_ExprInBracesColon*>(kc_x);
}

impl_expressionListColon_EmptyExpressionListColon*
EmptyExpressionListColon() {
    expressionListColon kc_x = new impl_expressionListColon_EmptyExpressionListColon();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyExpressionListColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyExpressionListColon));
    kc_x->post_create();
    return static_cast<impl_expressionListColon_EmptyExpressionListColon*>(kc_x);
}

impl_expressionListColon_ExpressionListColon*
ExpressionListColon(expression _expression_1, expression _expression_2, expressionListColon _expressionListColon_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expressionListColon_1, phylum_expressionListColon);
    expressionListColon kc_x = new impl_expressionListColon_ExpressionListColon(_expression_1, _expression_2, _expressionListColon_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExpressionListColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExpressionListColon));
    kc_x->post_create();
    return static_cast<impl_expressionListColon_ExpressionListColon*>(kc_x);
}

impl_places_Places*
Places(optSafe _optSafe_1, optType _optType_1, place _place_1, commaPlaces _commaPlaces_1, morePlaces _morePlaces_1) {
    assertPhylum(_optSafe_1, phylum_optSafe);
    assertPhylum(_optType_1, phylum_optType);
    assertPhylum(_place_1, phylum_place);
    assertPhylum(_commaPlaces_1, phylum_commaPlaces);
    assertPhylum(_morePlaces_1, phylum_morePlaces);
    places kc_x = new impl_places_Places(_optSafe_1, _optType_1, _place_1, _commaPlaces_1, _morePlaces_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Places));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Places));
    kc_x->post_create();
    return static_cast<impl_places_Places*>(kc_x);
}

impl_optSafe_EmptySafe*
EmptySafe() {
    optSafe kc_x = new impl_optSafe_EmptySafe();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptySafe));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptySafe));
    kc_x->post_create();
    return static_cast<impl_optSafe_EmptySafe*>(kc_x);
}

impl_optSafe_Safe*
Safe(optNumber _optNumber_1) {
    assertPhylum(_optNumber_1, phylum_optNumber);
    optSafe kc_x = new impl_optSafe_Safe(_optNumber_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Safe));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Safe));
    kc_x->post_create();
    return static_cast<impl_optSafe_Safe*>(kc_x);
}

impl_optNumber_EmptyPlaceNumber*
EmptyPlaceNumber() {
    optNumber kc_x = new impl_optNumber_EmptyPlaceNumber();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyPlaceNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyPlaceNumber));
    kc_x->post_create();
    return static_cast<impl_optNumber_EmptyPlaceNumber*>(kc_x);
}

impl_optNumber_PlaceNumber*
PlaceNumber(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    optNumber kc_x = new impl_optNumber_PlaceNumber(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceNumber));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceNumber));
    kc_x->post_create();
    return static_cast<impl_optNumber_PlaceNumber*>(kc_x);
}

impl_optType_EmptyPlaceType*
EmptyPlaceType() {
    optType kc_x = new impl_optType_EmptyPlaceType();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyPlaceType));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyPlaceType));
    kc_x->post_create();
    return static_cast<impl_optType_EmptyPlaceType*>(kc_x);
}

impl_optType_PlaceTypeBool*
PlaceTypeBool() {
    optType kc_x = new impl_optType_PlaceTypeBool();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeBool));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeBool));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeBool*>(kc_x);
}

impl_optType_PlaceTypeEnum*
PlaceTypeEnum(casestring _casestring_1, integer _integer_1, identList _identList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_identList_1, phylum_identList);
    optType kc_x = new impl_optType_PlaceTypeEnum(_casestring_1, _integer_1, _identList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeEnum));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeEnum));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeEnum*>(kc_x);
}

impl_optType_PlaceTypeIntInterval*
PlaceTypeIntInterval(expression _expression_1, expression _expression_2) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    optType kc_x = new impl_optType_PlaceTypeIntInterval(_expression_1, _expression_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeIntInterval));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeIntInterval));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeIntInterval*>(kc_x);
}

impl_optType_PlaceTypeStruct*
PlaceTypeStruct(structTypeList _structTypeList_1) {
    assertPhylum(_structTypeList_1, phylum_structTypeList);
    optType kc_x = new impl_optType_PlaceTypeStruct(_structTypeList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeStruct));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeStruct));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeStruct*>(kc_x);
}

impl_optType_PlaceTypeInt*
PlaceTypeInt() {
    optType kc_x = new impl_optType_PlaceTypeInt();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeInt));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeInt));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeInt*>(kc_x);
}

impl_optType_PlaceTypeMultiset*
PlaceTypeMultiset(type _type_1) {
    assertPhylum(_type_1, phylum_type);
    optType kc_x = new impl_optType_PlaceTypeMultiset(_type_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceTypeMultiset));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceTypeMultiset));
    kc_x->post_create();
    return static_cast<impl_optType_PlaceTypeMultiset*>(kc_x);
}

impl_place_Place*
Place(casestring _casestring_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    place kc_x = new impl_place_Place(_casestring_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Place));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Place));
    kc_x->post_create();
    return static_cast<impl_place_Place*>(kc_x);
}

impl_place_PlaceWithTypeIdent*
PlaceWithTypeIdent(casestring _casestring_1, casestring _casestring_2) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_casestring_2, phylum_casestring);
    place kc_x = new impl_place_PlaceWithTypeIdent(_casestring_1, _casestring_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_PlaceWithTypeIdent));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_PlaceWithTypeIdent));
    kc_x->post_create();
    return static_cast<impl_place_PlaceWithTypeIdent*>(kc_x);
}

impl_commaPlaces_EmptyCommaPlaces*
EmptyCommaPlaces() {
    commaPlaces kc_x = new impl_commaPlaces_EmptyCommaPlaces();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyCommaPlaces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyCommaPlaces));
    kc_x->post_create();
    return static_cast<impl_commaPlaces_EmptyCommaPlaces*>(kc_x);
}

impl_commaPlaces_CommaPlaces*
CommaPlaces(optType _optType_1, place _place_1, commaPlaces _commaPlaces_1) {
    assertPhylum(_optType_1, phylum_optType);
    assertPhylum(_place_1, phylum_place);
    assertPhylum(_commaPlaces_1, phylum_commaPlaces);
    commaPlaces kc_x = new impl_commaPlaces_CommaPlaces(_optType_1, _place_1, _commaPlaces_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_CommaPlaces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_CommaPlaces));
    kc_x->post_create();
    return static_cast<impl_commaPlaces_CommaPlaces*>(kc_x);
}

impl_morePlaces_EmptyMorePlaces*
EmptyMorePlaces() {
    morePlaces kc_x = new impl_morePlaces_EmptyMorePlaces();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyMorePlaces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyMorePlaces));
    kc_x->post_create();
    return static_cast<impl_morePlaces_EmptyMorePlaces*>(kc_x);
}

impl_morePlaces_MorePlaces*
MorePlaces(optSafe _optSafe_1, optType _optType_1, place _place_1, commaPlaces _commaPlaces_1, morePlaces _morePlaces_1) {
    assertPhylum(_optSafe_1, phylum_optSafe);
    assertPhylum(_optType_1, phylum_optType);
    assertPhylum(_place_1, phylum_place);
    assertPhylum(_commaPlaces_1, phylum_commaPlaces);
    assertPhylum(_morePlaces_1, phylum_morePlaces);
    morePlaces kc_x = new impl_morePlaces_MorePlaces(_optSafe_1, _optType_1, _place_1, _commaPlaces_1, _morePlaces_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_MorePlaces));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_MorePlaces));
    kc_x->post_create();
    return static_cast<impl_morePlaces_MorePlaces*>(kc_x);
}

impl_marking_EmptyMarking*
EmptyMarking() {
    marking kc_x = new impl_marking_EmptyMarking();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyMarking));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyMarking));
    kc_x->post_create();
    return static_cast<impl_marking_EmptyMarking*>(kc_x);
}

impl_marking_Marking*
Marking(casestring _casestring_1, expression _expression_1, markingList _markingList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_markingList_1, phylum_markingList);
    marking kc_x = new impl_marking_Marking(_casestring_1, _expression_1, _markingList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Marking));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Marking));
    kc_x->post_create();
    return static_cast<impl_marking_Marking*>(kc_x);
}

impl_markingList_EmptyMarkingList*
EmptyMarkingList() {
    markingList kc_x = new impl_markingList_EmptyMarkingList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyMarkingList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyMarkingList));
    kc_x->post_create();
    return static_cast<impl_markingList_EmptyMarkingList*>(kc_x);
}

impl_markingList_MarkingList*
MarkingList(casestring _casestring_1, expression _expression_1, markingList _markingList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_markingList_1, phylum_markingList);
    markingList kc_x = new impl_markingList_MarkingList(_casestring_1, _expression_1, _markingList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_MarkingList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_MarkingList));
    kc_x->post_create();
    return static_cast<impl_markingList_MarkingList*>(kc_x);
}

impl_transition_EmptyTransition*
EmptyTransition() {
    transition kc_x = new impl_transition_EmptyTransition();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyTransition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyTransition));
    kc_x->post_create();
    return static_cast<impl_transition_EmptyTransition*>(kc_x);
}

impl_transition_Transition*
Transition(casestring _casestring_1, fairness _fairness_1, variable _variable_1, guard _guard_1, optIdentExprList _optIdentExprList_1, optIdentExprList _optIdentExprList_2, transition _transition_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_fairness_1, phylum_fairness);
    assertPhylum(_variable_1, phylum_variable);
    assertPhylum(_guard_1, phylum_guard);
    assertPhylum(_optIdentExprList_1, phylum_optIdentExprList);
    assertPhylum(_optIdentExprList_2, phylum_optIdentExprList);
    assertPhylum(_transition_1, phylum_transition);
    transition kc_x = new impl_transition_Transition(_casestring_1, _fairness_1, _variable_1, _guard_1, _optIdentExprList_1, _optIdentExprList_2, _transition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Transition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Transition));
    kc_x->post_create();
    return static_cast<impl_transition_Transition*>(kc_x);
}

impl_fairness_EmptyFairness*
EmptyFairness() {
    fairness kc_x = new impl_fairness_EmptyFairness();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyFairness));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyFairness));
    kc_x->post_create();
    return static_cast<impl_fairness_EmptyFairness*>(kc_x);
}

impl_fairness_WeakFair*
WeakFair() {
    fairness kc_x = new impl_fairness_WeakFair();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_WeakFair));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_WeakFair));
    kc_x->post_create();
    return static_cast<impl_fairness_WeakFair*>(kc_x);
}

impl_fairness_StrongFair*
StrongFair() {
    fairness kc_x = new impl_fairness_StrongFair();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StrongFair));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StrongFair));
    kc_x->post_create();
    return static_cast<impl_fairness_StrongFair*>(kc_x);
}

impl_variable_EmptyVariable*
EmptyVariable() {
    variable kc_x = new impl_variable_EmptyVariable();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyVariable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyVariable));
    kc_x->post_create();
    return static_cast<impl_variable_EmptyVariable*>(kc_x);
}

impl_variable_Variable*
Variable(type _type_1, varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1, variable _variable_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    assertPhylum(_variable_1, phylum_variable);
    variable kc_x = new impl_variable_Variable(_type_1, _varOrArray_1, _varOrArrayList_1, _variable_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Variable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Variable));
    kc_x->post_create();
    return static_cast<impl_variable_Variable*>(kc_x);
}

impl_varOrArrayList_EmptyVarOrArrayList*
EmptyVarOrArrayList() {
    varOrArrayList kc_x = new impl_varOrArrayList_EmptyVarOrArrayList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyVarOrArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyVarOrArrayList));
    kc_x->post_create();
    return static_cast<impl_varOrArrayList_EmptyVarOrArrayList*>(kc_x);
}

impl_varOrArrayList_VarOrArrayList*
VarOrArrayList(varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1) {
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    varOrArrayList kc_x = new impl_varOrArrayList_VarOrArrayList(_varOrArray_1, _varOrArrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_VarOrArrayList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_VarOrArrayList));
    kc_x->post_create();
    return static_cast<impl_varOrArrayList_VarOrArrayList*>(kc_x);
}

impl_guard_EmptyGuard*
EmptyGuard() {
    guard kc_x = new impl_guard_EmptyGuard();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyGuard));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyGuard));
    kc_x->post_create();
    return static_cast<impl_guard_EmptyGuard*>(kc_x);
}

impl_guard_Guard*
Guard(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    guard kc_x = new impl_guard_Guard(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Guard));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Guard));
    kc_x->post_create();
    return static_cast<impl_guard_Guard*>(kc_x);
}

impl_optIdentExprList_EmptyOptIdentExprList*
EmptyOptIdentExprList() {
    optIdentExprList kc_x = new impl_optIdentExprList_EmptyOptIdentExprList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyOptIdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyOptIdentExprList));
    kc_x->post_create();
    return static_cast<impl_optIdentExprList_EmptyOptIdentExprList*>(kc_x);
}

impl_optIdentExprList_OptIdentExprList*
OptIdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_identExprList_1, phylum_identExprList);
    optIdentExprList kc_x = new impl_optIdentExprList_OptIdentExprList(_casestring_1, _expression_1, _identExprList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_OptIdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_OptIdentExprList));
    kc_x->post_create();
    return static_cast<impl_optIdentExprList_OptIdentExprList*>(kc_x);
}

impl_identExprList_EmptyIdentExprList*
EmptyIdentExprList() {
    identExprList kc_x = new impl_identExprList_EmptyIdentExprList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyIdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyIdentExprList));
    kc_x->post_create();
    return static_cast<impl_identExprList_EmptyIdentExprList*>(kc_x);
}

impl_identExprList_IdentExprList*
IdentExprList(casestring _casestring_1, expression _expression_1, identExprList _identExprList_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_identExprList_1, phylum_identExprList);
    identExprList kc_x = new impl_identExprList_IdentExprList(_casestring_1, _expression_1, _identExprList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IdentExprList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IdentExprList));
    kc_x->post_create();
    return static_cast<impl_identExprList_IdentExprList*>(kc_x);
}

impl_block_Block*
Block(declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    block kc_x = new impl_block_Block(_declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Block));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Block));
    kc_x->post_create();
    return static_cast<impl_block_Block*>(kc_x);
}

impl_declarationOrStatement_EmptyDeclarationOrStatement*
EmptyDeclarationOrStatement() {
    declarationOrStatement kc_x = new impl_declarationOrStatement_EmptyDeclarationOrStatement();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyDeclarationOrStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyDeclarationOrStatement));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_EmptyDeclarationOrStatement*>(kc_x);
}

impl_declarationOrStatement_DeclOrStatemDeclaration*
DeclOrStatemDeclaration(declaration _declaration_1, declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_declaration_1, phylum_declaration);
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    declarationOrStatement kc_x = new impl_declarationOrStatement_DeclOrStatemDeclaration(_declaration_1, _declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DeclOrStatemDeclaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DeclOrStatemDeclaration));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_DeclOrStatemDeclaration*>(kc_x);
}

impl_declarationOrStatement_DeclOrStatemStatement*
DeclOrStatemStatement(statement _statement_1, declarationOrStatement _declarationOrStatement_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_declarationOrStatement_1, phylum_declarationOrStatement);
    declarationOrStatement kc_x = new impl_declarationOrStatement_DeclOrStatemStatement(_statement_1, _declarationOrStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DeclOrStatemStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DeclOrStatemStatement));
    kc_x->post_create();
    return static_cast<impl_declarationOrStatement_DeclOrStatemStatement*>(kc_x);
}

impl_declaration_Declaration*
Declaration(type _type_1, varOrArray _varOrArray_1, varOrArrayList _varOrArrayList_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_varOrArray_1, phylum_varOrArray);
    assertPhylum(_varOrArrayList_1, phylum_varOrArrayList);
    declaration kc_x = new impl_declaration_Declaration(_type_1, _varOrArray_1, _varOrArrayList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Declaration));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Declaration));
    kc_x->post_create();
    return static_cast<impl_declaration_Declaration*>(kc_x);
}

impl_statement_StatementSemiolon*
StatementSemiolon() {
    statement kc_x = new impl_statement_StatementSemiolon();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementSemiolon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementSemiolon));
    kc_x->post_create();
    return static_cast<impl_statement_StatementSemiolon*>(kc_x);
}

impl_statement_StatementBlock*
StatementBlock(block _block_1) {
    assertPhylum(_block_1, phylum_block);
    statement kc_x = new impl_statement_StatementBlock(_block_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementBlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementBlock));
    kc_x->post_create();
    return static_cast<impl_statement_StatementBlock*>(kc_x);
}

impl_statement_StatementExprSemicolon*
StatementExprSemicolon(expressionWithoutInitializer _expressionWithoutInitializer_1) {
    assertPhylum(_expressionWithoutInitializer_1, phylum_expressionWithoutInitializer);
    statement kc_x = new impl_statement_StatementExprSemicolon(_expressionWithoutInitializer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementExprSemicolon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementExprSemicolon));
    kc_x->post_create();
    return static_cast<impl_statement_StatementExprSemicolon*>(kc_x);
}

impl_statement_StatementIf*
StatementIf(ifStatement _ifStatement_1) {
    assertPhylum(_ifStatement_1, phylum_ifStatement);
    statement kc_x = new impl_statement_StatementIf(_ifStatement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementIf));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementIf));
    kc_x->post_create();
    return static_cast<impl_statement_StatementIf*>(kc_x);
}

impl_statement_StatementWhile*
StatementWhile(expression _expression_1, statement _statement_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementWhile(_expression_1, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementWhile));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementWhile));
    kc_x->post_create();
    return static_cast<impl_statement_StatementWhile*>(kc_x);
}

impl_statement_StatementDoWhile*
StatementDoWhile(statement _statement_1, expression _expression_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_expression_1, phylum_expression);
    statement kc_x = new impl_statement_StatementDoWhile(_statement_1, _expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementDoWhile));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementDoWhile));
    kc_x->post_create();
    return static_cast<impl_statement_StatementDoWhile*>(kc_x);
}

impl_statement_StatementForExpr*
StatementForExpr(expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForExpr(_expression_1, _expression_2, _expression_3, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForExpr));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForExpr*>(kc_x);
}

impl_statement_StatementForTypeExpr*
StatementForTypeExpr(type _type_1, casestring _casestring_1, expression _expression_1, expression _expression_2, expression _expression_3, statement _statement_1) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_expression_2, phylum_expression);
    assertPhylum(_expression_3, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForTypeExpr(_type_1, _casestring_1, _expression_1, _expression_2, _expression_3, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForTypeExpr));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForTypeExpr));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForTypeExpr*>(kc_x);
}

impl_statement_StatementForIdentColon*
StatementForIdentColon(casestring _casestring_1, expression _expression_1, statement _statement_1) {
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    statement kc_x = new impl_statement_StatementForIdentColon(_casestring_1, _expression_1, _statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForIdentColon));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForIdentColon));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForIdentColon*>(kc_x);
}

impl_statement_StatementForAll*
StatementForAll(type _type_1, casestring _casestring_1, type _type_2) {
    assertPhylum(_type_1, phylum_type);
    assertPhylum(_casestring_1, phylum_casestring);
    assertPhylum(_type_2, phylum_type);
    statement kc_x = new impl_statement_StatementForAll(_type_1, _casestring_1, _type_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementForAll));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementForAll));
    kc_x->post_create();
    return static_cast<impl_statement_StatementForAll*>(kc_x);
}

impl_statement_StatementSwitch*
StatementSwitch(expression _expression_1, switchCase _switchCase_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_switchCase_1, phylum_switchCase);
    statement kc_x = new impl_statement_StatementSwitch(_expression_1, _switchCase_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementSwitch));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementSwitch));
    kc_x->post_create();
    return static_cast<impl_statement_StatementSwitch*>(kc_x);
}

impl_statement_StatementBreak*
StatementBreak() {
    statement kc_x = new impl_statement_StatementBreak();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementBreak));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementBreak));
    kc_x->post_create();
    return static_cast<impl_statement_StatementBreak*>(kc_x);
}

impl_statement_StatementContinue*
StatementContinue() {
    statement kc_x = new impl_statement_StatementContinue();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementContinue));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementContinue));
    kc_x->post_create();
    return static_cast<impl_statement_StatementContinue*>(kc_x);
}

impl_statement_StatementReturn*
StatementReturn(expression _expression_1) {
    assertPhylum(_expression_1, phylum_expression);
    statement kc_x = new impl_statement_StatementReturn(_expression_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatementReturn));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatementReturn));
    kc_x->post_create();
    return static_cast<impl_statement_StatementReturn*>(kc_x);
}

impl_ifStatement_IfStatement*
IfStatement(expression _expression_1, statement _statement_1, optElse _optElse_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_optElse_1, phylum_optElse);
    ifStatement kc_x = new impl_ifStatement_IfStatement(_expression_1, _statement_1, _optElse_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_IfStatement));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_IfStatement));
    kc_x->post_create();
    return static_cast<impl_ifStatement_IfStatement*>(kc_x);
}

impl_optElse_OptElseEmpty*
OptElseEmpty() {
    optElse kc_x = new impl_optElse_OptElseEmpty();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_OptElseEmpty));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_OptElseEmpty));
    kc_x->post_create();
    return static_cast<impl_optElse_OptElseEmpty*>(kc_x);
}

impl_optElse_OptElse*
OptElse(statement _statement_1) {
    assertPhylum(_statement_1, phylum_statement);
    optElse kc_x = new impl_optElse_OptElse(_statement_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_OptElse));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_OptElse));
    kc_x->post_create();
    return static_cast<impl_optElse_OptElse*>(kc_x);
}

impl_switchCase_SwitchCase*
SwitchCase(expression _expression_1, statement _statement_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    switchCase kc_x = new impl_switchCase_SwitchCase(_expression_1, _statement_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchCase));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchCase));
    kc_x->post_create();
    return static_cast<impl_switchCase_SwitchCase*>(kc_x);
}

impl_switchCase_SwitchDefault*
SwitchDefault(statement _statement_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    switchCase kc_x = new impl_switchCase_SwitchDefault(_statement_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchDefault));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchDefault));
    kc_x->post_create();
    return static_cast<impl_switchCase_SwitchDefault*>(kc_x);
}

impl_switchCaseList_EmptySwitchCaseList*
EmptySwitchCaseList() {
    switchCaseList kc_x = new impl_switchCaseList_EmptySwitchCaseList();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptySwitchCaseList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptySwitchCaseList));
    kc_x->post_create();
    return static_cast<impl_switchCaseList_EmptySwitchCaseList*>(kc_x);
}

impl_switchCaseList_SwitchCaseList*
SwitchCaseList(expression _expression_1, statement _statement_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_expression_1, phylum_expression);
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    switchCaseList kc_x = new impl_switchCaseList_SwitchCaseList(_expression_1, _statement_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchCaseList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchCaseList));
    kc_x->post_create();
    return static_cast<impl_switchCaseList_SwitchCaseList*>(kc_x);
}

impl_switchCaseList_SwitchDefaultList*
SwitchDefaultList(statement _statement_1, switchCaseList _switchCaseList_1) {
    assertPhylum(_statement_1, phylum_statement);
    assertPhylum(_switchCaseList_1, phylum_switchCaseList);
    switchCaseList kc_x = new impl_switchCaseList_SwitchDefaultList(_statement_1, _switchCaseList_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_SwitchDefaultList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_SwitchDefaultList));
    kc_x->post_create();
    return static_cast<impl_switchCaseList_SwitchDefaultList*>(kc_x);
}


abstract_phylum
kc_create(enum_operators createOp, abstract_phylum kc_p1, abstract_phylum kc_p2, abstract_phylum kc_p3, abstract_phylum kc_p4, abstract_phylum kc_p5, abstract_phylum kc_p6, abstract_phylum kc_p7)
{
    switch(createOp) {
    case sel__VoidPtr:
    case sel__Int:
    case sel__Real:
    case sel__Str:
    case sel_NoCaseStr:
	assertionFailed("Cannot create this kind of phylum - predefined phyla must be handled seperately");break;
    case sel_SwitchDefaultList:
	return SwitchDefaultList(phylum_cast<statement>(kc_p1), phylum_cast<switchCaseList>(kc_p2));
    case sel_SwitchCaseList:
	return SwitchCaseList(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2), phylum_cast<switchCaseList>(kc_p3));
    case sel_EmptySwitchCaseList:
	return EmptySwitchCaseList();
    case sel_SwitchDefault:
	return SwitchDefault(phylum_cast<statement>(kc_p1), phylum_cast<switchCaseList>(kc_p2));
    case sel_SwitchCase:
	return SwitchCase(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2), phylum_cast<switchCaseList>(kc_p3));
    case sel_OptElse:
	return OptElse(phylum_cast<statement>(kc_p1));
    case sel_OptElseEmpty:
	return OptElseEmpty();
    case sel_IfStatement:
	return IfStatement(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2), phylum_cast<optElse>(kc_p3));
    case sel_StatementReturn:
	return StatementReturn(phylum_cast<expression>(kc_p1));
    case sel_StatementContinue:
	return StatementContinue();
    case sel_StatementBreak:
	return StatementBreak();
    case sel_StatementSwitch:
	return StatementSwitch(phylum_cast<expression>(kc_p1), phylum_cast<switchCase>(kc_p2));
    case sel_StatementForAll:
	return StatementForAll(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<type>(kc_p3));
    case sel_StatementForIdentColon:
	return StatementForIdentColon(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<statement>(kc_p3));
    case sel_StatementForTypeExpr:
	return StatementForTypeExpr(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<expression>(kc_p3), phylum_cast<expression>(kc_p4), phylum_cast<expression>(kc_p5), phylum_cast<statement>(kc_p6));
    case sel_StatementForExpr:
	return StatementForExpr(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3), phylum_cast<statement>(kc_p4));
    case sel_StatementDoWhile:
	return StatementDoWhile(phylum_cast<statement>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_StatementWhile:
	return StatementWhile(phylum_cast<expression>(kc_p1), phylum_cast<statement>(kc_p2));
    case sel_StatementIf:
	return StatementIf(phylum_cast<ifStatement>(kc_p1));
    case sel_StatementExprSemicolon:
	return StatementExprSemicolon(phylum_cast<expressionWithoutInitializer>(kc_p1));
    case sel_StatementBlock:
	return StatementBlock(phylum_cast<block>(kc_p1));
    case sel_StatementSemiolon:
	return StatementSemiolon();
    case sel_Declaration:
	return Declaration(phylum_cast<type>(kc_p1), phylum_cast<varOrArray>(kc_p2), phylum_cast<varOrArrayList>(kc_p3));
    case sel_DeclOrStatemStatement:
	return DeclOrStatemStatement(phylum_cast<statement>(kc_p1), phylum_cast<declarationOrStatement>(kc_p2));
    case sel_DeclOrStatemDeclaration:
	return DeclOrStatemDeclaration(phylum_cast<declaration>(kc_p1), phylum_cast<declarationOrStatement>(kc_p2));
    case sel_EmptyDeclarationOrStatement:
	return EmptyDeclarationOrStatement();
    case sel_Block:
	return Block(phylum_cast<declarationOrStatement>(kc_p1));
    case sel_IdentExprList:
	return IdentExprList(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<identExprList>(kc_p3));
    case sel_EmptyIdentExprList:
	return EmptyIdentExprList();
    case sel_OptIdentExprList:
	return OptIdentExprList(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<identExprList>(kc_p3));
    case sel_EmptyOptIdentExprList:
	return EmptyOptIdentExprList();
    case sel_Guard:
	return Guard(phylum_cast<expression>(kc_p1));
    case sel_EmptyGuard:
	return EmptyGuard();
    case sel_VarOrArrayList:
	return VarOrArrayList(phylum_cast<varOrArray>(kc_p1), phylum_cast<varOrArrayList>(kc_p2));
    case sel_EmptyVarOrArrayList:
	return EmptyVarOrArrayList();
    case sel_Variable:
	return Variable(phylum_cast<type>(kc_p1), phylum_cast<varOrArray>(kc_p2), phylum_cast<varOrArrayList>(kc_p3), phylum_cast<variable>(kc_p4));
    case sel_EmptyVariable:
	return EmptyVariable();
    case sel_StrongFair:
	return StrongFair();
    case sel_WeakFair:
	return WeakFair();
    case sel_EmptyFairness:
	return EmptyFairness();
    case sel_Transition:
	return Transition(phylum_cast<casestring>(kc_p1), phylum_cast<fairness>(kc_p2), phylum_cast<variable>(kc_p3), phylum_cast<guard>(kc_p4), phylum_cast<optIdentExprList>(kc_p5), phylum_cast<optIdentExprList>(kc_p6), phylum_cast<transition>(kc_p7));
    case sel_EmptyTransition:
	return EmptyTransition();
    case sel_MarkingList:
	return MarkingList(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<markingList>(kc_p3));
    case sel_EmptyMarkingList:
	return EmptyMarkingList();
    case sel_Marking:
	return Marking(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<markingList>(kc_p3));
    case sel_EmptyMarking:
	return EmptyMarking();
    case sel_MorePlaces:
	return MorePlaces(phylum_cast<optSafe>(kc_p1), phylum_cast<optType>(kc_p2), phylum_cast<place>(kc_p3), phylum_cast<commaPlaces>(kc_p4), phylum_cast<morePlaces>(kc_p5));
    case sel_EmptyMorePlaces:
	return EmptyMorePlaces();
    case sel_CommaPlaces:
	return CommaPlaces(phylum_cast<optType>(kc_p1), phylum_cast<place>(kc_p2), phylum_cast<commaPlaces>(kc_p3));
    case sel_EmptyCommaPlaces:
	return EmptyCommaPlaces();
    case sel_PlaceWithTypeIdent:
	return PlaceWithTypeIdent(phylum_cast<casestring>(kc_p1), phylum_cast<casestring>(kc_p2));
    case sel_Place:
	return Place(phylum_cast<casestring>(kc_p1));
    case sel_PlaceTypeMultiset:
	return PlaceTypeMultiset(phylum_cast<type>(kc_p1));
    case sel_PlaceTypeInt:
	return PlaceTypeInt();
    case sel_PlaceTypeStruct:
	return PlaceTypeStruct(phylum_cast<structTypeList>(kc_p1));
    case sel_PlaceTypeIntInterval:
	return PlaceTypeIntInterval(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_PlaceTypeEnum:
	return PlaceTypeEnum(phylum_cast<casestring>(kc_p1), phylum_cast<integer>(kc_p2), phylum_cast<identList>(kc_p3));
    case sel_PlaceTypeBool:
	return PlaceTypeBool();
    case sel_EmptyPlaceType:
	return EmptyPlaceType();
    case sel_PlaceNumber:
	return PlaceNumber(phylum_cast<integer>(kc_p1));
    case sel_EmptyPlaceNumber:
	return EmptyPlaceNumber();
    case sel_Safe:
	return Safe(phylum_cast<optNumber>(kc_p1));
    case sel_EmptySafe:
	return EmptySafe();
    case sel_Places:
	return Places(phylum_cast<optSafe>(kc_p1), phylum_cast<optType>(kc_p2), phylum_cast<place>(kc_p3), phylum_cast<commaPlaces>(kc_p4), phylum_cast<morePlaces>(kc_p5));
    case sel_ExpressionListColon:
	return ExpressionListColon(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expressionListColon>(kc_p3));
    case sel_EmptyExpressionListColon:
	return EmptyExpressionListColon();
    case sel_ExprInBracesColon:
	return ExprInBracesColon(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expressionListColon>(kc_p3));
    case sel_ExprInBraces:
	return ExprInBraces(phylum_cast<expression>(kc_p1));
    case sel_Braces:
	return Braces();
    case sel_ExprAll2:
	return ExprAll2(phylum_cast<type>(kc_p1));
    case sel_ExprOtherIfWithoutInitializer:
	return ExprOtherIfWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3));
    case sel_ExprCommaSeparatedWithoutInitializer:
	return ExprCommaSeparatedWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprIdentExprInParenthesis2:
	return ExprIdentExprInParenthesis2(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprIdentParenthesis2:
	return ExprIdentParenthesis2(phylum_cast<casestring>(kc_p1));
    case sel_ExprAll:
	return ExprAll(phylum_cast<type>(kc_p1));
    case sel_ExprOtherIf:
	return ExprOtherIf(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2), phylum_cast<expression>(kc_p3));
    case sel_ExprCommaSeparated:
	return ExprCommaSeparated(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprIdentExprInParenthesis:
	return ExprIdentExprInParenthesis(phylum_cast<casestring>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprIdentParenthesis:
	return ExprIdentParenthesis(phylum_cast<casestring>(kc_p1));
    case sel_LeftValDot:
	return LeftValDot(phylum_cast<leftvalue>(kc_p1), phylum_cast<casestring>(kc_p2));
    case sel_LeftValBrackets:
	return LeftValBrackets(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_LeftValIdent:
	return LeftValIdent(phylum_cast<casestring>(kc_p1));
    case sel_ExprGreaterOrEqualWithoutInitializer:
	return ExprGreaterOrEqualWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessOrEqualWithoutInitializer:
	return ExprLessOrEqualWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprGreaterThanWithoutInitializer:
	return ExprGreaterThanWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessThanWithoutInitializer:
	return ExprLessThanWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprNotEqualWithoutInitializer:
	return ExprNotEqualWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprEquivalentWithoutInitializer:
	return ExprEquivalentWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprGreaterOrEqual:
	return ExprGreaterOrEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessOrEqual:
	return ExprLessOrEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprGreaterThan:
	return ExprGreaterThan(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprLessThan:
	return ExprLessThan(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprNotEqual:
	return ExprNotEqual(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprEquivalent:
	return ExprEquivalent(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprFalse2:
	return ExprFalse2();
    case sel_ExprTrue2:
	return ExprTrue2();
    case sel_ExprOrWithoutInitializer:
	return ExprOrWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAndWithoutInitializer:
	return ExprAndWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NotExpr2:
	return NotExpr2(phylum_cast<expression>(kc_p1));
    case sel_ExprFalse:
	return ExprFalse();
    case sel_ExprTrue:
	return ExprTrue();
    case sel_ExprOr:
	return ExprOr(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAnd:
	return ExprAnd(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NotExpr:
	return NotExpr(phylum_cast<expression>(kc_p1));
    case sel_ExprNumber2:
	return ExprNumber2(phylum_cast<integer>(kc_p1));
    case sel_ExprModuloWithoutInitializer:
	return ExprModuloWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprDivisionWithoutInitializer:
	return ExprDivisionWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprMultiplicationWithoutInitializer:
	return ExprMultiplicationWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprSubtractionWithoutInitializer:
	return ExprSubtractionWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAdditionWithoutInitializer:
	return ExprAdditionWithoutInitializer(phylum_cast<expressionWithoutInitializer>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NegativeExpr2:
	return NegativeExpr2(phylum_cast<expression>(kc_p1));
    case sel_PositiveExpr2:
	return PositiveExpr2(phylum_cast<expression>(kc_p1));
    case sel_ExprNumber:
	return ExprNumber(phylum_cast<integer>(kc_p1));
    case sel_ExprModulo:
	return ExprModulo(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprDivision:
	return ExprDivision(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprMultiplication:
	return ExprMultiplication(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprSubtraction:
	return ExprSubtraction(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprAddition:
	return ExprAddition(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_NegativeExpr:
	return NegativeExpr(phylum_cast<expression>(kc_p1));
    case sel_PositiveExpr:
	return PositiveExpr(phylum_cast<expression>(kc_p1));
    case sel_ValDecrement:
	return ValDecrement(phylum_cast<leftvalue>(kc_p1));
    case sel_ValIncrement:
	return ValIncrement(phylum_cast<leftvalue>(kc_p1));
    case sel_DecrementVal:
	return DecrementVal(phylum_cast<leftvalue>(kc_p1));
    case sel_IncrementVal:
	return IncrementVal(phylum_cast<leftvalue>(kc_p1));
    case sel_AssignMod:
	return AssignMod(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignDivide:
	return AssignDivide(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignTimes:
	return AssignTimes(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignMinus:
	return AssignMinus(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignPlus:
	return AssignPlus(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_AssignEqual:
	return AssignEqual(phylum_cast<leftvalue>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_ExprInParenthesis2:
	return ExprInParenthesis2(phylum_cast<expression>(kc_p1));
    case sel_ExprOtherWithoutInitializer:
	return ExprOtherWithoutInitializer(phylum_cast<otherWithoutInitializer>(kc_p1));
    case sel_ExprLeftvalue2:
	return ExprLeftvalue2(phylum_cast<leftvalue>(kc_p1));
    case sel_ExprComparisonWithoutInitializer:
	return ExprComparisonWithoutInitializer(phylum_cast<comparisonWithoutInitializer>(kc_p1));
    case sel_ExprLogicalWithoutInitializer:
	return ExprLogicalWithoutInitializer(phylum_cast<logicalWithoutInitializer>(kc_p1));
    case sel_ExprArithmeticWithoutInitializer:
	return ExprArithmeticWithoutInitializer(phylum_cast<arithmeticWithoutInitializer>(kc_p1));
    case sel_ExprIncdecrement2:
	return ExprIncdecrement2(phylum_cast<incdecrement>(kc_p1));
    case sel_ExprAssignment2:
	return ExprAssignment2(phylum_cast<assignment>(kc_p1));
    case sel_ExprInParenthesis:
	return ExprInParenthesis(phylum_cast<expression>(kc_p1));
    case sel_ExprInitializerList:
	return ExprInitializerList(phylum_cast<initializerList>(kc_p1));
    case sel_ExprOther:
	return ExprOther(phylum_cast<other>(kc_p1));
    case sel_ExprLeftvalue:
	return ExprLeftvalue(phylum_cast<leftvalue>(kc_p1));
    case sel_ExprComparison:
	return ExprComparison(phylum_cast<comparison>(kc_p1));
    case sel_ExprLogical:
	return ExprLogical(phylum_cast<logical>(kc_p1));
    case sel_ExprArithmetic:
	return ExprArithmetic(phylum_cast<arithmetic>(kc_p1));
    case sel_ExprIncdecrement:
	return ExprIncdecrement(phylum_cast<incdecrement>(kc_p1));
    case sel_ExprAssignment:
	return ExprAssignment(phylum_cast<assignment>(kc_p1));
    case sel_Constant:
	return Constant(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3), phylum_cast<expression>(kc_p4));
    case sel_FunctionParameters:
	return FunctionParameters(phylum_cast<type>(kc_p1), phylum_cast<varOrArray>(kc_p2));
    case sel_FunctionParametersList:
	return FunctionParametersList(phylum_cast<functionParametersList>(kc_p1), phylum_cast<functionParameters>(kc_p2));
    case sel_EmptyFunctionParametersList:
	return EmptyFunctionParametersList();
    case sel_OptFunctionParameters:
	return OptFunctionParameters(phylum_cast<type>(kc_p1), phylum_cast<varOrArray>(kc_p2), phylum_cast<functionParametersList>(kc_p3));
    case sel_EmptyOptFunctionParameters:
	return EmptyOptFunctionParameters();
    case sel_Function:
	return Function(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3), phylum_cast<optFunctionParameters>(kc_p4), phylum_cast<block>(kc_p5));
    case sel_Array:
	return Array(phylum_cast<expression>(kc_p1));
    case sel_ArrayList:
	return ArrayList(phylum_cast<arrayList>(kc_p1), phylum_cast<array>(kc_p2));
    case sel_EmptyArrayList:
	return EmptyArrayList();
    case sel_VarOrArray:
	return VarOrArray(phylum_cast<casestring>(kc_p1), phylum_cast<arrayList>(kc_p2));
    case sel_StructType:
	return StructType(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3));
    case sel_StructTypeList:
	return StructTypeList(phylum_cast<structTypeList>(kc_p1), phylum_cast<structType>(kc_p2));
    case sel_SingleStructTypeList:
	return SingleStructTypeList(phylum_cast<structType>(kc_p1));
    case sel_Ident:
	return Ident(phylum_cast<casestring>(kc_p1), phylum_cast<integer>(kc_p2));
    case sel_IdentList:
	return IdentList(phylum_cast<identList>(kc_p1), phylum_cast<idents>(kc_p2));
    case sel_EmptyIdentList:
	return EmptyIdentList();
    case sel_TypeMultiset:
	return TypeMultiset(phylum_cast<type>(kc_p1));
    case sel_TypeInt:
	return TypeInt();
    case sel_TypeStruct:
	return TypeStruct(phylum_cast<structTypeList>(kc_p1));
    case sel_TypeIntInterval:
	return TypeIntInterval(phylum_cast<expression>(kc_p1), phylum_cast<expression>(kc_p2));
    case sel_TypeIdent:
	return TypeIdent(phylum_cast<casestring>(kc_p1));
    case sel_TypeEnum:
	return TypeEnum(phylum_cast<identList>(kc_p1));
    case sel_TypeBool:
	return TypeBool();
    case sel_Sort:
	return Sort(phylum_cast<type>(kc_p1), phylum_cast<casestring>(kc_p2), phylum_cast<arrayList>(kc_p3));
    case sel_DefConstant:
	return DefConstant(phylum_cast<constant>(kc_p1));
    case sel_DefFunction:
	return DefFunction(phylum_cast<function>(kc_p1));
    case sel_DefSort:
	return DefSort(phylum_cast<sort>(kc_p1));
    case sel_DefinitionsList:
	return DefinitionsList(phylum_cast<definitionsList>(kc_p1), phylum_cast<definitions>(kc_p2));
    case sel_EmptyDefinitionsList:
	return EmptyDefinitionsList();
    case sel_NetName:
	return NetName(phylum_cast<casestring>(kc_p1));
    case sel_EmptyNetName:
	return EmptyNetName();
    case sel_Net:
	return Net(phylum_cast<netName>(kc_p1), phylum_cast<definitionsList>(kc_p2), phylum_cast<places>(kc_p3), phylum_cast<marking>(kc_p4), phylum_cast<transition>(kc_p5));
    default:
	assertionFailed("Cannot create this kind of phylum - unkown operator id");
    }
    NORETURN
}

abstract_phylum
kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps)
{
    if (kc_ps.size() < 7) {
	assertionFailed("Need vector of size of maximum subphylum count (which is 7)!");
    }
    return kc_create(createOp, kc_ps[0], kc_ps[1], kc_ps[2], kc_ps[3], kc_ps[4], kc_ps[5], kc_ps[6]);
}

abstract_phylum&
attributeOf(abstract_phylum kc_p, int no)
{
    assertionFailed("Cannot select attribute for this kind of phylum - has no attributes");
    NORETURN
}

abstract_phylum
impl_abstract_phylum::subphylum(int) const
{
    return 0;
}

void
impl_abstract_phylum::set_subphylum(int,abstract_phylum)
{
}

void
impl_abstract_phylum::free(bool kc_rec)
{
    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));
    if (!phylum_info[phylum()].uniq_stored) {
	if (kc_rec) {
	    abstract_phylum son;
	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)
	    {
		if (son!=0) son->free(kc_rec);
		son=0;
	    }
	}
	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));
	delete this;
    }
}

bool
impl_abstract_phylum::eq(c_abstract_phylum kc_p2) const
{
    if (this == kc_p2)
	return true;
    if (prod_sel() != kc_p2->prod_sel())
	return false;

    int kc_st = phylum_info[phylum()].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return false;

    c_abstract_phylum son1;
    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {
	if (!son1->eq(kc_p2->subphylum(kc_i)))
	    return false;
    }

    return true;
}

static string kc_indentation = "";
static const char *kc_printformat_not_nullary_open = "%s%s(\n";
static const char *kc_printformat_list_open = "%s%s\n";

static const char *kc_printformat_not_nullary_close = "%s)\n";
static const char *kc_printformat_nullary = "%s%s()\n";

void
impl_abstract_phylum::fprint(FILE*kc_f)
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    abstract_list al = dynamic_cast<abstract_list>(this);
    if (al != 0 && !al->is_nil()) {
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
    } else // not list
	switch(phylum()) {
	case phylum_voidptr:
	    fprintf(kc_f, "%s%p\n", kc_indentation.c_str(), static_cast<voidptr>(this)->pointer);
	    break;
	case phylum_casestring:
	case phylum_nocasestring:
	    fprintf(kc_f, "%s%s\n", kc_indentation.c_str(), static_cast<casestring>(this)->name);
	    break;
	case phylum_integer:
	    fprintf(kc_f, "%s%i\n", kc_indentation.c_str(), static_cast<integer>(this)->value);
	    break;
	case phylum_real:
	    fprintf(kc_f, "%s%f\n", kc_indentation.c_str(), static_cast<real>(this)->value);
	    break;
	default:
	    if (!subphylum(0)) {
		fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
	    } else {
		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());
		kc_indentation+="  ";
		abstract_phylum son;
		for (kc_i=0; (son = subphylum(kc_i)); kc_i++) {
		    son->fprint(kc_f);
		}
		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
		fprintf(kc_f, kc_printformat_not_nullary_close, kc_indentation.c_str());
	    }
    }
}

void 
impl_abstract_phylum::print()
{
    fprint(stdout);
}

void 
impl_abstract_list::fprint_list(FILE*kc_f)
{
    if (!kc_f)
	kc_f = stdout;
    if (this->is_nil()) {
	kc_indentation+="`-";
	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
    } else {
	kc_indentation+="|-";
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
    }
}

int
impl_abstract_list::length() const
{
    int kc_length = 0;
    c_abstract_phylum kc_p = this;
    while((kc_p = kc_p->subphylum(1)))
	kc_length++;
    return kc_length;
}
void impl_abstract_list::freelist()
{
    abstract_phylum kc_p = this, kc_tmp_p;
    do {
	kc_tmp_p=kc_p->subphylum(1);
	kc_p->free(false);
	kc_p=kc_tmp_p;
    } while(kc_p);
}
abstract_phylum
impl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const
{
    abstract_phylum next = subphylum(1);
    if(!next)
	return const_cast<abstract_phylum>(kc_p2);
    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));
}

abstract_phylum
impl_abstract_list::do_reverse(c_abstract_phylum tail, enum_operators mk) const
{
    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;
	iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )
    tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));
    return const_cast<abstract_phylum>(tail);
}

abstract_phylum
impl_abstract_list::last() const
{
    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;
#ifdef _AFX
    ASSERT(next);
    if(!next)
	return NULL;
#else
    if(!next){
	fflush(stdout);
	fprintf(stderr, "Internal Error: list::last was called with argument Nil%s\n", phylum_name());
	exit(1);
    }
#endif
    while ((nextnext = next->subphylum(1))) {
	kc_p = next;
	next = nextnext;
    }
    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */
}

abstract_phylum
impl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_create(mk, kc_fp(el), next->do_map(kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    if ((*kc_fp)(el)) {
	return kc_create(mk, el, next->do_filter(kc_fp, mk));
    } else {
	return next->do_filter(kc_fp, mk);
    }
}

abstract_list
impl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)
{
    abstract_list next = this;
    while (!next->is_nil())
	next = phylum_cast<abstract_list>(next->subphylum(1));
    next->set_subphylum(0, new_last);
    next->set_subphylum(1, eol);
    return next;
}

abstract_phylum
impl_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_phylum el2 = second->subphylum(0);
    if (!el2)
	return el2;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    abstract_list next2 = static_cast<abstract_list>(second->subphylum(1));
    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_reduce(abstract_phylum neutral, abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {
    abstract_phylum el = subphylum(0);
    if (!el)
	return neutral;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_fp(el,next->do_reduce(neutral,kc_fp));
}


extern const char* kc_storageclassnames[];

#ifdef KC_STATISTICS
void do_print_operator_statistics(FILE * kc_f)
{
    unsigned int kc_i;
    assertNonNull( kc_f );
    fprintf(kc_f, "%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\n", 38 , "Operator", 3, "Sz", 8, "#oper", 8, "#new", 8, "#exist", 8, "#frnrec", 8, "#frrec", 8, "#freed", 8, "#rem", 9, "total (bytes)");
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case sensitive strings", 3, "-", 8, operator_statistics[sel__Str].created, 8, operator_statistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case insensitive strings", 3, "-", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_found, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);
    for (kc_i = one_before_first_operator+1; kc_i < last_operator; kc_i++) {
	fprintf(kc_f, "%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].created, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));
    }
}
#endif // KC_STATISTICS


void
ht_static(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_static();
}

void
ht_dynamic(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dynamic();
}

void
ht_inc_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_inc_level();
}

void
ht_dec_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dec_level();
}

void
ht_free_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_free_level();
}

hashtable_t
ht_create_simple()
{
    hashtable_t kc_ht=new hashtable_struct_t;
    kc_ht->set_to_be_freed();
    return kc_ht;
}

hashtable_t
ht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)
{
    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];
    hashtables[kc_a_storageclass_t] = kc_a_hashtable_t;
    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;
    return kc_tmp;
}

hashtable_t
ht_assigned(kc_storageclass_t kc_a_storageclass_t)
{
    return hashtables[kc_a_storageclass_t];
}

void
ht_clear(hashtable_t kc_a_hashtable_t)
{
    kc_a_hashtable_t->ht_clear();
}

void
ht_delete(hashtable_t kc_a_hashtable_t)
{
    if(kc_a_hashtable_t->to_be_freed())
	delete kc_a_hashtable_t;
}
const char*
phylumname_or_error(enum_phyla kc_phy)
{
    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[69]), "Internal Error: unknown phylum number: %d", kc_phy);
	return kc_strof_error;
    } else {
	return phylum_info[kc_phy].name;
    }   }


const char*
kc_operatorname_or_error(enum_operators kc_operator)
{
    if ((kc_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[71]), "Internal Error: unknown operator number: %d", kc_operator);
	return kc_strof_error;
    } else {
	return operator_info[kc_operator].name;
    }   }


#ifndef KC_PRINTDOT_LABELSIZE
# define KC_PRINTDOT_LABELSIZE 1023
#endif

class impl_kc_dotedgenode_t
{
    public:
    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phylum to, int _son_nr):
    ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }
    c_abstract_phylum ptr_from;
    c_abstract_phylum ptr_to;
    int son_nr;
    char *label;
    int lsize;
    kc_dotedgenode_t next;
};

static kc_dotedgenode_t
kc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);
static void kc_do_printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);
static void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const char*, bool, bool);
static void kc_do_printdot_subgraph_epilogue (FILE*);
static void kc_do_printdot_genfields (FILE*, int, bool);
static void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const char*, bool);

static bool
kc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)
{
    if(p2==0)
	return false;
    if(p1==0)
	return true;
    if(p1->ptr_from<p2->ptr_from)
	return true;
    if(p1->ptr_from>p2->ptr_from)
	return false;
    if(p1->ptr_to<p2->ptr_to)
	return true;
    if(p1->ptr_to>p2->ptr_to)
	return false;
    if(p1->son_nr<p2->son_nr)
	return true;
    // OPERATORHASH((unsigned) kc_phy_from);
    // OPERATORHASH((unsigned) kc_phy_to);
    return false;
}

template<typename T>
struct dotedge_less : std::binary_function<T, T, bool> {
    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }
};

struct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less<kc_dotedgenode_t> > {
    ~kc_dotedge_ht() {
	for(iterator i=begin();i!=end();++i)
	delete const_cast<kc_dotedgenode_t>(*i);
	clear();
    }
    kc_dotedgenode_t check_insert(kc_dotedgenode_t t) {
	std::pair<iterator,bool> res=insert(t);
	return *res.first;
    }
};

static kc_dotedge_ht* fprintdot_hashtable;
void impl_nocasestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_casestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_real::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_integer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_voidptr::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_net::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_netName::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_definitionsList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_definitions::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_sort::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_type::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_identList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_idents::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_structTypeList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_structType::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_varOrArray::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_arrayList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_array::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_function::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optFunctionParameters::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_functionParametersList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_functionParameters::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_constant::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expression::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expressionWithoutInitializer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_assignment::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_incdecrement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_arithmetic::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_arithmeticWithoutInitializer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_logical::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_logicalWithoutInitializer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_comparison::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_comparisonWithoutInitializer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_leftvalue::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_other::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_otherWithoutInitializer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_initializerList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_expressionListColon::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_places::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optSafe::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optNumber::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optType::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_place::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_commaPlaces::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_morePlaces::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_marking::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_markingList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_transition::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_fairness::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_variable::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_varOrArrayList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_guard::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optIdentExprList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_identExprList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_block::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declarationOrStatement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_declaration::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_statement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_ifStatement::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_optElse::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_switchCase::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_switchCaseList::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}


kc_dotedgenode_t
kc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)
{
    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t(kc_s_from,kc_s_to,kc_son_nr);
    kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    }
    return kc_x;
}

void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "/*subgraph*/ {\n");
    if (root_label_prefix) {
	fprintf(kc_f, "\"%s\" [shape=ellipse", root_label_prefix);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	if (print_node_labels) {
	    fprintf(kc_f, ", label=\"%s\\n%s\"", root_label_prefix, phylum_info[kc_p->phylum()].name);
	}
	fprintf(kc_f, "];\n");
	fprintf(kc_f, "\"%s\" ->", root_label_prefix);
	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, "[%s]", edge_attributes);
	}
	fprintf(kc_f, ";\n");
    }
}

void kc_do_printdot_subgraph_epilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void fprintdotprologue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "digraph kc_output{\n");
    fprintf(kc_f, "node [shape=record, height=.1, fontname=Helvetica];\n");
}

void fprintdotepilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)
{
    int kc_i = 1;
    KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];
    if (kc_op_info->no_sons <= 0) return;
    if (!kc_f) kc_f = stdout;
    while(kc_i < kc_op_info->no_sons) {
	fprintf(kc_f, "<f%d>", kc_i);
	if (print_node_labels) {
	    fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
	}
	fprintf(kc_f, "|");
	kc_i++;
    }
    fprintf(kc_f, "<f%d>", kc_i);
    if (print_node_labels) {
	fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
    }
}

void impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    // The casts only make unique ids, so reinterpret_cast is alright
    if (!kc_f) kc_f = stdout;
    enum_phyla kc_phy = phylum();
    if (kc_phy == phylum_voidptr) {
	fprintf(kc_f, "kcidp%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {
	fprintf(kc_f, "kcids%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_integer) {
	fprintf(kc_f, "kcidi%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_real) {
	fprintf(kc_f, "kcidf%x", reinterpret_cast<size_t>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%x_%d", reinterpret_cast<size_t>(kc_ctxt), kc_son_nr);
	}
    } else {
	fprintf(kc_f, "kcidx%x", reinterpret_cast<size_t>(this));
    }   }

void kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)
{
    kc_dotedgenode_t kc_hn;
    char kc_buf[30];
    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);
    if (! kc_hn->label) {
	kc_hn->label = new char[(size_t)(KC_PRINTDOT_LABELSIZE+1)];
	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;
	strcpy(kc_hn->label, "");
	kc_hn->next = *kc_edges;
	*kc_edges = kc_hn;
    } else {
	char kc_buf2[30];
	sprintf(kc_buf2, ", ");
	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));
    }
    if (edge_label_prefix) {
	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->label));
    }
    sprintf(kc_buf, "%d", *kc_edge_nr);
    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));
    (*kc_edge_nr)++;
}

void impl_abstract_phylum::printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const
{
    kc_do_printdot_do_add_edge(this, kc_sub_p, kc_son_nr, kc_edge_nr, kc_edges, edge_label_prefix);
}

void kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)
{
    kc_dotedgenode_t kc_p = kc_edges;
    if (!kc_f) kc_f = stdout;
    while(kc_p) {
	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	fprintf(kc_f, ":f%d -> ", kc_p->son_nr);
	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);
	fprintf(kc_f, " [label=\"%s\"", kc_p->label);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	fprintf(kc_f, "];\n");
	kc_p = kc_p->next;
    }   }

void impl_abstract_phylum::do_printdot(FILE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    switch(phylum()) {
	case phylum_voidptr:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%p\", shape=ellipse];\n", dynamic_cast<c_voidptr>(this)->pointer);
	break;
	case phylum_casestring:
	case phylum_nocasestring:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
#ifdef KC_UNICODE
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", kc_to_cstring(static_cast<c_casestring>(this)->name).c_str());
#else
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", static_cast<c_casestring>(this)->name);
#endif
	break;
	case phylum_integer:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%i\", shape=ellipse];\n", ((integer)this)->value);
	break;
	case phylum_real:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%f\", shape=ellipse];\n", ((real)this)->value);
	break;
	default:
	if (!subphylum(0)) {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"<f0>%s\"];\n", op_name());
	} else {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"{<f0>%s|{", op_name());
	    kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);
	    fprintf(kc_f, "}}\"];\n");
	    abstract_phylum child;
	    for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {
		printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );
		child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );
	    }
	}
    }
}
abstract_phylum
impl_abstract_phylum::copy(bool kc_copy_attributes) const
{
    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL
    KC_OPERATOR_INFO *kc_op_info = &operator_info[prod_sel()];
    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return const_cast<abstract_phylum>(this);
    abstract_phylum kc_answer=0;
    if (kc_phy == phylum_casestring) {
	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);
    } else if (kc_phy == phylum_nocasestring) {
	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);
    } else if (kc_phy == phylum_voidptr) {
	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);
    } else if (kc_phy == phylum_integer) {
	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);
    } else if (kc_phy == phylum_real) {
	kc_answer=mkreal((dynamic_cast<c_real>(this))->value);
    } else {
	abstract_phylum kc_subtmp[7], child;
	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {
	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);
	}
	switch(kc_op_info->no_sons) {
	    case 0: kc_answer = kc_create(prod_sel()); break;
	    case 1: kc_answer = kc_create(prod_sel(), kc_subtmp[0]); break;
	    case 2: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1]); break;
	    case 3: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2]); break;
	    case 4: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3]); break;
	    case 5: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4]); break;
	    case 6: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4], kc_subtmp[5]); break;
	    case 7: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2], kc_subtmp[3], kc_subtmp[4], kc_subtmp[5], kc_subtmp[6]); break;
	    default: assertionFailed("unexpected number of sub-phyla");
	}
    }
    if (kc_copy_attributes)
	copy_attributes(kc_phy, this, kc_answer);
    return kc_answer;
}


} // namespace kc
