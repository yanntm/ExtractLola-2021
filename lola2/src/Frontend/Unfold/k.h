/* translation of file(s)
	"abstract.k"
	"unparse.k"
	"rewrite.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.11 (C) 1998-2007 Humboldt-University of Berlin $
 */
#ifndef KC_TYPES_HEADER
#define KC_TYPES_HEADER

#define KIMWITUVERSIONMAJOR 2
#define KIMWITUVERSIONMINOR 3
#define KIMWITUVERSIONMICRO 11

#include <stdio.h>
#include <stddef.h>
#include <string>
#include <vector>

namespace kc {

#ifndef INTEGER
# define INTEGER int
#endif
#ifndef REAL
# define REAL double
#endif

#ifdef KC_UNICODE

#define kc_t(TEXT) L ## TEXT
typedef wchar_t kc_char_t;
typedef std::wstring kc_string_t;

#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strlen wcslen
#define kc_strcmp wcscmp
#define kc_strcasecmp _wcsicmp
#define kc_strcpy wcscpy
#define kc_strncpy wcsncpy
#define kc_tolower towlower
#define kc_print_integer(buf,number) swprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) swprintf(buf,kc_t("%g"),number)

// needed for printdot and csgio only
inline
std::string kc_to_cstring(const std::wstring& s) {
    USES_CONVERSION;
    return W2CA(s.c_str());
}

// needed for csgio only
inline
std::wstring kc_to_wstring(const std::string& s) {
    USES_CONVERSION;
    return A2CW(s.c_str());
}

#else // !defined(_WIN32) || defined(__GNUC__)
// if you want to use UNICODE on other platforms you have to write
// the following functions on your own
int kc_strlen(const kc_char_t*);
int kc_strcmp(const kc_char_t*,const kc_char_t*);
int kc_strcasecmp(const kc_char_t*,const kc_char_t*);
int kc_strcpy(kc_char_t*,const kc_char_t*);
int kc_strncpy(kc_char_t*,const kc_char_t*, int);
kc_char_t kc_tolower(kc_char_t);
int kc_print_integer(kc_char_t* buffer, INTEGER number );
int kc_print_real(kc_char_t* buffer, REAL number);

// needed for printdot and csgio only
std::string kc_to_cstring(const std::wstring& );
// needed for csgio only
std::wstring kc_to_wstring(const std::string& );

#endif

#else // !KC_UNICODE

#define kc_t(TEXT) TEXT  
typedef char kc_char_t;
typedef std::string kc_string_t;

#define kc_strlen strlen
#define kc_strcmp strcmp
#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strcasecmp _stricmp
#else
#define kc_strcasecmp strcasecmp
#endif
#define kc_strcpy strcpy
#define kc_strncpy strncpy
#define kc_tolower tolower  
#define kc_print_integer(buf,number) sprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) sprintf(buf,kc_t("%g"),number)
#endif
class uview_class;
typedef uview_class& uview;
typedef const uview_class& c_uview;

typedef class printer_functor_class& printer_functor;
typedef void (*printer_function)(const kc_char_t*, uview);

class rview_class;
typedef rview_class& rview;
typedef const rview_class& c_rview;

}

// Some compilers know __attribute__. Right now we test for the GNU compiler
// and Intel's icc (for ia32) and ecc (for ia64).
#if !defined __GNUC__ && !defined __ICC && !defined __ECC
# define __attribute__(x)
#endif

// Since all definitions are in namespace kc now, there is no need
// give them a kc_ prefix. Old code may still rely on the prefix, so these
// macros are generated for backwards compatibility
#ifdef KC_DEPRECATED
#define kc_PhylumInfo           phylum_info
#define kc_OperatorInfo         operator_info
#define kc_last_uview           last_uview
#define kc_uviews               uviews
#define kc_rviews               rviews
#define kc_ht_reuse             ht_clear
#define kc_ht_clear             ht_clear
#define kc_ht_assign            ht_assign
#define kc_ht_assigned          ht_assigned
#define kc_phylum_nocasestring phylum_nocasestring
#define kc_tag_nocasestring_NoCaseStr impl_nocasestring_NoCaseStr
#define kc_phylum_casestring phylum_casestring
#define kc_tag_casestring__Str impl_casestring__Str
#define kc_phylum_real phylum_real
#define kc_tag_real__Real impl_real__Real
#define kc_phylum_integer phylum_integer
#define kc_tag_integer__Int impl_integer__Int
#define kc_phylum_voidptr phylum_voidptr
#define kc_tag_voidptr__VoidPtr impl_voidptr__VoidPtr
#define kc_phylum_net phylum_net
#define kc_tag_net_Net impl_net_Net
#define kc_phylum_netName phylum_netName
#define kc_tag_netName_EmptyNetName impl_netName_EmptyNetName
#define kc_tag_netName_NetName impl_netName_NetName
#define kc_phylum_definitionsList phylum_definitionsList
#define kc_tag_definitionsList_EmptyDefinitionsList impl_definitionsList_EmptyDefinitionsList
#define kc_tag_definitionsList_DefinitionsList impl_definitionsList_DefinitionsList
#define kc_phylum_definitions phylum_definitions
#define kc_tag_definitions_DefSort impl_definitions_DefSort
#define kc_tag_definitions_DefFunction impl_definitions_DefFunction
#define kc_tag_definitions_DefConstant impl_definitions_DefConstant
#define kc_phylum_sort phylum_sort
#define kc_tag_sort_Sort impl_sort_Sort
#define kc_phylum_type phylum_type
#define kc_tag_type_TypeBool impl_type_TypeBool
#define kc_tag_type_TypeEnum impl_type_TypeEnum
#define kc_tag_type_TypeIdent impl_type_TypeIdent
#define kc_tag_type_TypeIntInterval impl_type_TypeIntInterval
#define kc_tag_type_TypeStruct impl_type_TypeStruct
#define kc_tag_type_TypeInt impl_type_TypeInt
#define kc_tag_type_TypeMultiset impl_type_TypeMultiset
#define kc_phylum_identList phylum_identList
#define kc_tag_identList_EmptyIdentList impl_identList_EmptyIdentList
#define kc_tag_identList_IdentList impl_identList_IdentList
#define kc_phylum_idents phylum_idents
#define kc_tag_idents_Ident impl_idents_Ident
#define kc_phylum_structTypeList phylum_structTypeList
#define kc_tag_structTypeList_SingleStructTypeList impl_structTypeList_SingleStructTypeList
#define kc_tag_structTypeList_StructTypeList impl_structTypeList_StructTypeList
#define kc_phylum_structType phylum_structType
#define kc_tag_structType_StructType impl_structType_StructType
#define kc_phylum_varOrArray phylum_varOrArray
#define kc_tag_varOrArray_VarOrArray impl_varOrArray_VarOrArray
#define kc_phylum_arrayList phylum_arrayList
#define kc_tag_arrayList_EmptyArrayList impl_arrayList_EmptyArrayList
#define kc_tag_arrayList_ArrayList impl_arrayList_ArrayList
#define kc_phylum_array phylum_array
#define kc_tag_array_Array impl_array_Array
#define kc_phylum_function phylum_function
#define kc_tag_function_Function impl_function_Function
#define kc_phylum_optFunctionParameters phylum_optFunctionParameters
#define kc_tag_optFunctionParameters_EmptyOptFunctionParameters impl_optFunctionParameters_EmptyOptFunctionParameters
#define kc_tag_optFunctionParameters_OptFunctionParameters impl_optFunctionParameters_OptFunctionParameters
#define kc_phylum_functionParametersList phylum_functionParametersList
#define kc_tag_functionParametersList_EmptyFunctionParametersList impl_functionParametersList_EmptyFunctionParametersList
#define kc_tag_functionParametersList_FunctionParametersList impl_functionParametersList_FunctionParametersList
#define kc_phylum_functionParameters phylum_functionParameters
#define kc_tag_functionParameters_FunctionParameters impl_functionParameters_FunctionParameters
#define kc_phylum_constant phylum_constant
#define kc_tag_constant_Constant impl_constant_Constant
#define kc_phylum_expression phylum_expression
#define kc_tag_expression_ExprAssignment impl_expression_ExprAssignment
#define kc_tag_expression_ExprIncdecrement impl_expression_ExprIncdecrement
#define kc_tag_expression_ExprArithmetic impl_expression_ExprArithmetic
#define kc_tag_expression_ExprLogical impl_expression_ExprLogical
#define kc_tag_expression_ExprComparison impl_expression_ExprComparison
#define kc_tag_expression_ExprLeftvalue impl_expression_ExprLeftvalue
#define kc_tag_expression_ExprOther impl_expression_ExprOther
#define kc_tag_expression_ExprInitializerList impl_expression_ExprInitializerList
#define kc_tag_expression_ExprInParenthesis impl_expression_ExprInParenthesis
#define kc_phylum_expressionWithoutInitializer phylum_expressionWithoutInitializer
#define kc_tag_expressionWithoutInitializer_ExprAssignment2 impl_expressionWithoutInitializer_ExprAssignment2
#define kc_tag_expressionWithoutInitializer_ExprIncdecrement2 impl_expressionWithoutInitializer_ExprIncdecrement2
#define kc_tag_expressionWithoutInitializer_ExprArithmeticWithoutInitializer impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer
#define kc_tag_expressionWithoutInitializer_ExprLogicalWithoutInitializer impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer
#define kc_tag_expressionWithoutInitializer_ExprComparisonWithoutInitializer impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer
#define kc_tag_expressionWithoutInitializer_ExprLeftvalue2 impl_expressionWithoutInitializer_ExprLeftvalue2
#define kc_tag_expressionWithoutInitializer_ExprOtherWithoutInitializer impl_expressionWithoutInitializer_ExprOtherWithoutInitializer
#define kc_tag_expressionWithoutInitializer_ExprInParenthesis2 impl_expressionWithoutInitializer_ExprInParenthesis2
#define kc_phylum_assignment phylum_assignment
#define kc_tag_assignment_AssignEqual impl_assignment_AssignEqual
#define kc_tag_assignment_AssignPlus impl_assignment_AssignPlus
#define kc_tag_assignment_AssignMinus impl_assignment_AssignMinus
#define kc_tag_assignment_AssignTimes impl_assignment_AssignTimes
#define kc_tag_assignment_AssignDivide impl_assignment_AssignDivide
#define kc_tag_assignment_AssignMod impl_assignment_AssignMod
#define kc_phylum_incdecrement phylum_incdecrement
#define kc_tag_incdecrement_IncrementVal impl_incdecrement_IncrementVal
#define kc_tag_incdecrement_DecrementVal impl_incdecrement_DecrementVal
#define kc_tag_incdecrement_ValIncrement impl_incdecrement_ValIncrement
#define kc_tag_incdecrement_ValDecrement impl_incdecrement_ValDecrement
#define kc_phylum_arithmetic phylum_arithmetic
#define kc_tag_arithmetic_PositiveExpr impl_arithmetic_PositiveExpr
#define kc_tag_arithmetic_NegativeExpr impl_arithmetic_NegativeExpr
#define kc_tag_arithmetic_ExprAddition impl_arithmetic_ExprAddition
#define kc_tag_arithmetic_ExprSubtraction impl_arithmetic_ExprSubtraction
#define kc_tag_arithmetic_ExprMultiplication impl_arithmetic_ExprMultiplication
#define kc_tag_arithmetic_ExprDivision impl_arithmetic_ExprDivision
#define kc_tag_arithmetic_ExprModulo impl_arithmetic_ExprModulo
#define kc_tag_arithmetic_ExprNumber impl_arithmetic_ExprNumber
#define kc_phylum_arithmeticWithoutInitializer phylum_arithmeticWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_PositiveExpr2 impl_arithmeticWithoutInitializer_PositiveExpr2
#define kc_tag_arithmeticWithoutInitializer_NegativeExpr2 impl_arithmeticWithoutInitializer_NegativeExpr2
#define kc_tag_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_ExprModuloWithoutInitializer impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer
#define kc_tag_arithmeticWithoutInitializer_ExprNumber2 impl_arithmeticWithoutInitializer_ExprNumber2
#define kc_phylum_logical phylum_logical
#define kc_tag_logical_NotExpr impl_logical_NotExpr
#define kc_tag_logical_ExprAnd impl_logical_ExprAnd
#define kc_tag_logical_ExprOr impl_logical_ExprOr
#define kc_tag_logical_ExprTrue impl_logical_ExprTrue
#define kc_tag_logical_ExprFalse impl_logical_ExprFalse
#define kc_phylum_logicalWithoutInitializer phylum_logicalWithoutInitializer
#define kc_tag_logicalWithoutInitializer_NotExpr2 impl_logicalWithoutInitializer_NotExpr2
#define kc_tag_logicalWithoutInitializer_ExprAndWithoutInitializer impl_logicalWithoutInitializer_ExprAndWithoutInitializer
#define kc_tag_logicalWithoutInitializer_ExprOrWithoutInitializer impl_logicalWithoutInitializer_ExprOrWithoutInitializer
#define kc_tag_logicalWithoutInitializer_ExprTrue2 impl_logicalWithoutInitializer_ExprTrue2
#define kc_tag_logicalWithoutInitializer_ExprFalse2 impl_logicalWithoutInitializer_ExprFalse2
#define kc_phylum_comparison phylum_comparison
#define kc_tag_comparison_ExprEquivalent impl_comparison_ExprEquivalent
#define kc_tag_comparison_ExprNotEqual impl_comparison_ExprNotEqual
#define kc_tag_comparison_ExprLessThan impl_comparison_ExprLessThan
#define kc_tag_comparison_ExprGreaterThan impl_comparison_ExprGreaterThan
#define kc_tag_comparison_ExprLessOrEqual impl_comparison_ExprLessOrEqual
#define kc_tag_comparison_ExprGreaterOrEqual impl_comparison_ExprGreaterOrEqual
#define kc_phylum_comparisonWithoutInitializer phylum_comparisonWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprLessThanWithoutInitializer impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer
#define kc_tag_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer
#define kc_phylum_leftvalue phylum_leftvalue
#define kc_tag_leftvalue_LeftValIdent impl_leftvalue_LeftValIdent
#define kc_tag_leftvalue_LeftValBrackets impl_leftvalue_LeftValBrackets
#define kc_tag_leftvalue_LeftValDot impl_leftvalue_LeftValDot
#define kc_phylum_other phylum_other
#define kc_tag_other_ExprIdentParenthesis impl_other_ExprIdentParenthesis
#define kc_tag_other_ExprIdentExprInParenthesis impl_other_ExprIdentExprInParenthesis
#define kc_tag_other_ExprCommaSeparated impl_other_ExprCommaSeparated
#define kc_tag_other_ExprOtherIf impl_other_ExprOtherIf
#define kc_tag_other_ExprAll impl_other_ExprAll
#define kc_phylum_otherWithoutInitializer phylum_otherWithoutInitializer
#define kc_tag_otherWithoutInitializer_ExprIdentParenthesis2 impl_otherWithoutInitializer_ExprIdentParenthesis2
#define kc_tag_otherWithoutInitializer_ExprIdentExprInParenthesis2 impl_otherWithoutInitializer_ExprIdentExprInParenthesis2
#define kc_tag_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer
#define kc_tag_otherWithoutInitializer_ExprOtherIfWithoutInitializer impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer
#define kc_tag_otherWithoutInitializer_ExprAll2 impl_otherWithoutInitializer_ExprAll2
#define kc_phylum_initializerList phylum_initializerList
#define kc_tag_initializerList_Braces impl_initializerList_Braces
#define kc_tag_initializerList_ExprInBraces impl_initializerList_ExprInBraces
#define kc_tag_initializerList_ExprInBracesColon impl_initializerList_ExprInBracesColon
#define kc_phylum_expressionListColon phylum_expressionListColon
#define kc_tag_expressionListColon_EmptyExpressionListColon impl_expressionListColon_EmptyExpressionListColon
#define kc_tag_expressionListColon_ExpressionListColon impl_expressionListColon_ExpressionListColon
#define kc_phylum_places phylum_places
#define kc_tag_places_Places impl_places_Places
#define kc_phylum_optSafe phylum_optSafe
#define kc_tag_optSafe_EmptySafe impl_optSafe_EmptySafe
#define kc_tag_optSafe_Safe impl_optSafe_Safe
#define kc_phylum_optNumber phylum_optNumber
#define kc_tag_optNumber_EmptyPlaceNumber impl_optNumber_EmptyPlaceNumber
#define kc_tag_optNumber_PlaceNumber impl_optNumber_PlaceNumber
#define kc_phylum_optType phylum_optType
#define kc_tag_optType_EmptyPlaceType impl_optType_EmptyPlaceType
#define kc_tag_optType_PlaceTypeBool impl_optType_PlaceTypeBool
#define kc_tag_optType_PlaceTypeEnum impl_optType_PlaceTypeEnum
#define kc_tag_optType_PlaceTypeIntInterval impl_optType_PlaceTypeIntInterval
#define kc_tag_optType_PlaceTypeStruct impl_optType_PlaceTypeStruct
#define kc_tag_optType_PlaceTypeInt impl_optType_PlaceTypeInt
#define kc_tag_optType_PlaceTypeMultiset impl_optType_PlaceTypeMultiset
#define kc_phylum_place phylum_place
#define kc_tag_place_Place impl_place_Place
#define kc_tag_place_PlaceWithTypeIdent impl_place_PlaceWithTypeIdent
#define kc_phylum_commaPlaces phylum_commaPlaces
#define kc_tag_commaPlaces_EmptyCommaPlaces impl_commaPlaces_EmptyCommaPlaces
#define kc_tag_commaPlaces_CommaPlaces impl_commaPlaces_CommaPlaces
#define kc_phylum_morePlaces phylum_morePlaces
#define kc_tag_morePlaces_EmptyMorePlaces impl_morePlaces_EmptyMorePlaces
#define kc_tag_morePlaces_MorePlaces impl_morePlaces_MorePlaces
#define kc_phylum_marking phylum_marking
#define kc_tag_marking_EmptyMarking impl_marking_EmptyMarking
#define kc_tag_marking_Marking impl_marking_Marking
#define kc_phylum_markingList phylum_markingList
#define kc_tag_markingList_EmptyMarkingList impl_markingList_EmptyMarkingList
#define kc_tag_markingList_MarkingList impl_markingList_MarkingList
#define kc_phylum_transition phylum_transition
#define kc_tag_transition_EmptyTransition impl_transition_EmptyTransition
#define kc_tag_transition_Transition impl_transition_Transition
#define kc_phylum_fairness phylum_fairness
#define kc_tag_fairness_EmptyFairness impl_fairness_EmptyFairness
#define kc_tag_fairness_WeakFair impl_fairness_WeakFair
#define kc_tag_fairness_StrongFair impl_fairness_StrongFair
#define kc_phylum_variable phylum_variable
#define kc_tag_variable_EmptyVariable impl_variable_EmptyVariable
#define kc_tag_variable_Variable impl_variable_Variable
#define kc_phylum_varOrArrayList phylum_varOrArrayList
#define kc_tag_varOrArrayList_EmptyVarOrArrayList impl_varOrArrayList_EmptyVarOrArrayList
#define kc_tag_varOrArrayList_VarOrArrayList impl_varOrArrayList_VarOrArrayList
#define kc_phylum_guard phylum_guard
#define kc_tag_guard_EmptyGuard impl_guard_EmptyGuard
#define kc_tag_guard_Guard impl_guard_Guard
#define kc_phylum_optIdentExprList phylum_optIdentExprList
#define kc_tag_optIdentExprList_EmptyOptIdentExprList impl_optIdentExprList_EmptyOptIdentExprList
#define kc_tag_optIdentExprList_OptIdentExprList impl_optIdentExprList_OptIdentExprList
#define kc_phylum_identExprList phylum_identExprList
#define kc_tag_identExprList_EmptyIdentExprList impl_identExprList_EmptyIdentExprList
#define kc_tag_identExprList_IdentExprList impl_identExprList_IdentExprList
#define kc_phylum_block phylum_block
#define kc_tag_block_Block impl_block_Block
#define kc_phylum_declarationOrStatement phylum_declarationOrStatement
#define kc_tag_declarationOrStatement_EmptyDeclarationOrStatement impl_declarationOrStatement_EmptyDeclarationOrStatement
#define kc_tag_declarationOrStatement_DeclOrStatemDeclaration impl_declarationOrStatement_DeclOrStatemDeclaration
#define kc_tag_declarationOrStatement_DeclOrStatemStatement impl_declarationOrStatement_DeclOrStatemStatement
#define kc_phylum_declaration phylum_declaration
#define kc_tag_declaration_Declaration impl_declaration_Declaration
#define kc_phylum_statement phylum_statement
#define kc_tag_statement_StatementSemiolon impl_statement_StatementSemiolon
#define kc_tag_statement_StatementBlock impl_statement_StatementBlock
#define kc_tag_statement_StatementExprSemicolon impl_statement_StatementExprSemicolon
#define kc_tag_statement_StatementIf impl_statement_StatementIf
#define kc_tag_statement_StatementWhile impl_statement_StatementWhile
#define kc_tag_statement_StatementDoWhile impl_statement_StatementDoWhile
#define kc_tag_statement_StatementForExpr impl_statement_StatementForExpr
#define kc_tag_statement_StatementForTypeExpr impl_statement_StatementForTypeExpr
#define kc_tag_statement_StatementForIdentColon impl_statement_StatementForIdentColon
#define kc_tag_statement_StatementForAll impl_statement_StatementForAll
#define kc_tag_statement_StatementSwitch impl_statement_StatementSwitch
#define kc_tag_statement_StatementBreak impl_statement_StatementBreak
#define kc_tag_statement_StatementContinue impl_statement_StatementContinue
#define kc_tag_statement_StatementReturn impl_statement_StatementReturn
#define kc_phylum_ifStatement phylum_ifStatement
#define kc_tag_ifStatement_IfStatement impl_ifStatement_IfStatement
#define kc_phylum_optElse phylum_optElse
#define kc_tag_optElse_OptElseEmpty impl_optElse_OptElseEmpty
#define kc_tag_optElse_OptElse impl_optElse_OptElse
#define kc_phylum_switchCase phylum_switchCase
#define kc_tag_switchCase_SwitchCase impl_switchCase_SwitchCase
#define kc_tag_switchCase_SwitchDefault impl_switchCase_SwitchDefault
#define kc_phylum_switchCaseList phylum_switchCaseList
#define kc_tag_switchCaseList_EmptySwitchCaseList impl_switchCaseList_EmptySwitchCaseList
#define kc_tag_switchCaseList_SwitchCaseList impl_switchCaseList_SwitchCaseList
#define kc_tag_switchCaseList_SwitchDefaultList impl_switchCaseList_SwitchDefaultList

#endif // KC_DEPRECATED

// Some compilers are too stupid to detect that a function will always return
// a proper value when it returns one in all branches of an if- or switch-
// statement (with final else or default, of course).
#if !defined __GNUC__
# define NORETURN throw 0;
#else
# define NORETURN
#endif

namespace kc {


typedef enum { one_before_first_phylum = 0 ,
    phylum_nocasestring = 1,
    phylum_casestring = 2,
    phylum_real = 3,
    phylum_integer = 4,
    phylum_voidptr = 5,
    phylum_net = 6,
    phylum_netName = 7,
    phylum_definitionsList = 8,
    phylum_definitions = 9,
    phylum_sort = 10,
    phylum_type = 11,
    phylum_identList = 12,
    phylum_idents = 13,
    phylum_structTypeList = 14,
    phylum_structType = 15,
    phylum_varOrArray = 16,
    phylum_arrayList = 17,
    phylum_array = 18,
    phylum_function = 19,
    phylum_optFunctionParameters = 20,
    phylum_functionParametersList = 21,
    phylum_functionParameters = 22,
    phylum_constant = 23,
    phylum_expression = 24,
    phylum_expressionWithoutInitializer = 25,
    phylum_assignment = 26,
    phylum_incdecrement = 27,
    phylum_arithmetic = 28,
    phylum_arithmeticWithoutInitializer = 29,
    phylum_logical = 30,
    phylum_logicalWithoutInitializer = 31,
    phylum_comparison = 32,
    phylum_comparisonWithoutInitializer = 33,
    phylum_leftvalue = 34,
    phylum_other = 35,
    phylum_otherWithoutInitializer = 36,
    phylum_initializerList = 37,
    phylum_expressionListColon = 38,
    phylum_places = 39,
    phylum_optSafe = 40,
    phylum_optNumber = 41,
    phylum_optType = 42,
    phylum_place = 43,
    phylum_commaPlaces = 44,
    phylum_morePlaces = 45,
    phylum_marking = 46,
    phylum_markingList = 47,
    phylum_transition = 48,
    phylum_fairness = 49,
    phylum_variable = 50,
    phylum_varOrArrayList = 51,
    phylum_guard = 52,
    phylum_optIdentExprList = 53,
    phylum_identExprList = 54,
    phylum_block = 55,
    phylum_declarationOrStatement = 56,
    phylum_declaration = 57,
    phylum_statement = 58,
    phylum_ifStatement = 59,
    phylum_optElse = 60,
    phylum_switchCase = 61,
    phylum_switchCaseList = 62,
    last_phylum = 63
} enum_phyla;

typedef enum { one_before_first_operator = 0 ,
    sel_NoCaseStr = 1,
    sel__Str = 2,
    sel__Real = 3,
    sel__Int = 4,
    sel__VoidPtr = 5,
    sel_Net = 6,
    sel_EmptyNetName = 7,
    sel_NetName = 8,
    sel_EmptyDefinitionsList = 9,
    sel_DefinitionsList = 10,
    sel_DefSort = 11,
    sel_DefFunction = 12,
    sel_DefConstant = 13,
    sel_Sort = 14,
    sel_TypeBool = 15,
    sel_TypeEnum = 16,
    sel_TypeIdent = 17,
    sel_TypeIntInterval = 18,
    sel_TypeStruct = 19,
    sel_TypeInt = 20,
    sel_TypeMultiset = 21,
    sel_EmptyIdentList = 22,
    sel_IdentList = 23,
    sel_Ident = 24,
    sel_SingleStructTypeList = 25,
    sel_StructTypeList = 26,
    sel_StructType = 27,
    sel_VarOrArray = 28,
    sel_EmptyArrayList = 29,
    sel_ArrayList = 30,
    sel_Array = 31,
    sel_Function = 32,
    sel_EmptyOptFunctionParameters = 33,
    sel_OptFunctionParameters = 34,
    sel_EmptyFunctionParametersList = 35,
    sel_FunctionParametersList = 36,
    sel_FunctionParameters = 37,
    sel_Constant = 38,
    sel_ExprAssignment = 39,
    sel_ExprIncdecrement = 40,
    sel_ExprArithmetic = 41,
    sel_ExprLogical = 42,
    sel_ExprComparison = 43,
    sel_ExprLeftvalue = 44,
    sel_ExprOther = 45,
    sel_ExprInitializerList = 46,
    sel_ExprInParenthesis = 47,
    sel_ExprAssignment2 = 48,
    sel_ExprIncdecrement2 = 49,
    sel_ExprArithmeticWithoutInitializer = 50,
    sel_ExprLogicalWithoutInitializer = 51,
    sel_ExprComparisonWithoutInitializer = 52,
    sel_ExprLeftvalue2 = 53,
    sel_ExprOtherWithoutInitializer = 54,
    sel_ExprInParenthesis2 = 55,
    sel_AssignEqual = 56,
    sel_AssignPlus = 57,
    sel_AssignMinus = 58,
    sel_AssignTimes = 59,
    sel_AssignDivide = 60,
    sel_AssignMod = 61,
    sel_IncrementVal = 62,
    sel_DecrementVal = 63,
    sel_ValIncrement = 64,
    sel_ValDecrement = 65,
    sel_PositiveExpr = 66,
    sel_NegativeExpr = 67,
    sel_ExprAddition = 68,
    sel_ExprSubtraction = 69,
    sel_ExprMultiplication = 70,
    sel_ExprDivision = 71,
    sel_ExprModulo = 72,
    sel_ExprNumber = 73,
    sel_PositiveExpr2 = 74,
    sel_NegativeExpr2 = 75,
    sel_ExprAdditionWithoutInitializer = 76,
    sel_ExprSubtractionWithoutInitializer = 77,
    sel_ExprMultiplicationWithoutInitializer = 78,
    sel_ExprDivisionWithoutInitializer = 79,
    sel_ExprModuloWithoutInitializer = 80,
    sel_ExprNumber2 = 81,
    sel_NotExpr = 82,
    sel_ExprAnd = 83,
    sel_ExprOr = 84,
    sel_ExprTrue = 85,
    sel_ExprFalse = 86,
    sel_NotExpr2 = 87,
    sel_ExprAndWithoutInitializer = 88,
    sel_ExprOrWithoutInitializer = 89,
    sel_ExprTrue2 = 90,
    sel_ExprFalse2 = 91,
    sel_ExprEquivalent = 92,
    sel_ExprNotEqual = 93,
    sel_ExprLessThan = 94,
    sel_ExprGreaterThan = 95,
    sel_ExprLessOrEqual = 96,
    sel_ExprGreaterOrEqual = 97,
    sel_ExprEquivalentWithoutInitializer = 98,
    sel_ExprNotEqualWithoutInitializer = 99,
    sel_ExprLessThanWithoutInitializer = 100,
    sel_ExprGreaterThanWithoutInitializer = 101,
    sel_ExprLessOrEqualWithoutInitializer = 102,
    sel_ExprGreaterOrEqualWithoutInitializer = 103,
    sel_LeftValIdent = 104,
    sel_LeftValBrackets = 105,
    sel_LeftValDot = 106,
    sel_ExprIdentParenthesis = 107,
    sel_ExprIdentExprInParenthesis = 108,
    sel_ExprCommaSeparated = 109,
    sel_ExprOtherIf = 110,
    sel_ExprAll = 111,
    sel_ExprIdentParenthesis2 = 112,
    sel_ExprIdentExprInParenthesis2 = 113,
    sel_ExprCommaSeparatedWithoutInitializer = 114,
    sel_ExprOtherIfWithoutInitializer = 115,
    sel_ExprAll2 = 116,
    sel_Braces = 117,
    sel_ExprInBraces = 118,
    sel_ExprInBracesColon = 119,
    sel_EmptyExpressionListColon = 120,
    sel_ExpressionListColon = 121,
    sel_Places = 122,
    sel_EmptySafe = 123,
    sel_Safe = 124,
    sel_EmptyPlaceNumber = 125,
    sel_PlaceNumber = 126,
    sel_EmptyPlaceType = 127,
    sel_PlaceTypeBool = 128,
    sel_PlaceTypeEnum = 129,
    sel_PlaceTypeIntInterval = 130,
    sel_PlaceTypeStruct = 131,
    sel_PlaceTypeInt = 132,
    sel_PlaceTypeMultiset = 133,
    sel_Place = 134,
    sel_PlaceWithTypeIdent = 135,
    sel_EmptyCommaPlaces = 136,
    sel_CommaPlaces = 137,
    sel_EmptyMorePlaces = 138,
    sel_MorePlaces = 139,
    sel_EmptyMarking = 140,
    sel_Marking = 141,
    sel_EmptyMarkingList = 142,
    sel_MarkingList = 143,
    sel_EmptyTransition = 144,
    sel_Transition = 145,
    sel_EmptyFairness = 146,
    sel_WeakFair = 147,
    sel_StrongFair = 148,
    sel_EmptyVariable = 149,
    sel_Variable = 150,
    sel_EmptyVarOrArrayList = 151,
    sel_VarOrArrayList = 152,
    sel_EmptyGuard = 153,
    sel_Guard = 154,
    sel_EmptyOptIdentExprList = 155,
    sel_OptIdentExprList = 156,
    sel_EmptyIdentExprList = 157,
    sel_IdentExprList = 158,
    sel_Block = 159,
    sel_EmptyDeclarationOrStatement = 160,
    sel_DeclOrStatemDeclaration = 161,
    sel_DeclOrStatemStatement = 162,
    sel_Declaration = 163,
    sel_StatementSemiolon = 164,
    sel_StatementBlock = 165,
    sel_StatementExprSemicolon = 166,
    sel_StatementIf = 167,
    sel_StatementWhile = 168,
    sel_StatementDoWhile = 169,
    sel_StatementForExpr = 170,
    sel_StatementForTypeExpr = 171,
    sel_StatementForIdentColon = 172,
    sel_StatementForAll = 173,
    sel_StatementSwitch = 174,
    sel_StatementBreak = 175,
    sel_StatementContinue = 176,
    sel_StatementReturn = 177,
    sel_IfStatement = 178,
    sel_OptElseEmpty = 179,
    sel_OptElse = 180,
    sel_SwitchCase = 181,
    sel_SwitchDefault = 182,
    sel_EmptySwitchCaseList = 183,
    sel_SwitchCaseList = 184,
    sel_SwitchDefaultList = 185,
    last_operator = 186
} enum_operators;

class impl_abstract_phylum;
typedef impl_abstract_phylum * abstract_phylum;
typedef const impl_abstract_phylum * c_abstract_phylum;
class impl_abstract_list;
typedef impl_abstract_list * abstract_list;
typedef const impl_abstract_list * c_abstract_list;

template <typename P, typename T>
P phylum_cast(T* t) {
    return static_cast<P>(t);
}
template <typename P, typename T>
const P phylum_cast(const T* t) {
    return static_cast<const P>(t);
}
class impl_nocasestring_NoCaseStr;
class impl_casestring__Str;
class impl_real__Real;
class impl_integer__Int;
class impl_voidptr__VoidPtr;
class impl_net;
class impl_netName;
class impl_definitionsList;
class impl_definitions;
class impl_sort;
class impl_type;
class impl_identList;
class impl_idents;
class impl_structTypeList;
class impl_structType;
class impl_varOrArray;
class impl_arrayList;
class impl_array;
class impl_function;
class impl_optFunctionParameters;
class impl_functionParametersList;
class impl_functionParameters;
class impl_constant;
class impl_expression;
class impl_expressionWithoutInitializer;
class impl_assignment;
class impl_incdecrement;
class impl_arithmetic;
class impl_arithmeticWithoutInitializer;
class impl_logical;
class impl_logicalWithoutInitializer;
class impl_comparison;
class impl_comparisonWithoutInitializer;
class impl_leftvalue;
class impl_other;
class impl_otherWithoutInitializer;
class impl_initializerList;
class impl_expressionListColon;
class impl_places;
class impl_optSafe;
class impl_optNumber;
class impl_optType;
class impl_place;
class impl_commaPlaces;
class impl_morePlaces;
class impl_marking;
class impl_markingList;
class impl_transition;
class impl_fairness;
class impl_variable;
class impl_varOrArrayList;
class impl_guard;
class impl_optIdentExprList;
class impl_identExprList;
class impl_block;
class impl_declarationOrStatement;
class impl_declaration;
class impl_statement;
class impl_ifStatement;
class impl_optElse;
class impl_switchCase;
class impl_switchCaseList;


void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,
    const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));

typedef enum_phyla *enum_phyla_list;

/*
 * make sure that the first 'real' storage class _always_ gets a value > 0
 * and kc_not_uniq gets a value == 0
 * (because then we can use it as a C boolean)
 */
enum kc_storageclass_t {
    kc_not_uniq,
    uniq,
    last_storageclass
};

typedef struct {
    const char *name;			// name of the phylum
    enum_operators first_operator;	// index in operator_info[]
    enum_operators last_operator;	// index in operator_info[]
    kc_storageclass_t uniq_stored;	// storage class
} KC_PHYLUM_INFO;

typedef struct {
    const char *name;			// name of the operator
    size_t no_sons;			// number of sons
    bool atomicity;			// atomic type or not
    enum_phyla phylum;			// index in phylum_info[]
    enum_phyla_list subphylum;		// indexes in phylum_info[]
    int no_attrs;			// number of attributes
    enum_phyla_list attribute;		// indexes in phylum_info[]
    size_t size;			// size of operator (for statistics)
} KC_OPERATOR_INFO;

typedef enum_phyla_list KC_UNIQ_INFO;

extern KC_OPERATOR_INFO operator_info[];
extern KC_PHYLUM_INFO phylum_info[];
extern KC_UNIQ_INFO kc_UniqInfo[];

#define KC_OP_NAME(op) (operator_info[op].name)
#define KC_NO_SONS(prod) (operator_info[prod].no_sons)
#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)

typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;

typedef impl_nocasestring_NoCaseStr *nocasestring;
typedef const impl_nocasestring_NoCaseStr *c_nocasestring;
typedef impl_casestring__Str *casestring;
typedef const impl_casestring__Str *c_casestring;
typedef impl_real__Real *real;
typedef const impl_real__Real *c_real;
typedef impl_integer__Int *integer;
typedef const impl_integer__Int *c_integer;
typedef impl_voidptr__VoidPtr *voidptr;
typedef const impl_voidptr__VoidPtr *c_voidptr;
typedef impl_net *net;
typedef const impl_net *c_net;
typedef impl_netName *netName;
typedef const impl_netName *c_netName;
typedef impl_definitionsList *definitionsList;
typedef const impl_definitionsList *c_definitionsList;
typedef impl_definitions *definitions;
typedef const impl_definitions *c_definitions;
typedef impl_sort *sort;
typedef const impl_sort *c_sort;
typedef impl_type *type;
typedef const impl_type *c_type;
typedef impl_identList *identList;
typedef const impl_identList *c_identList;
typedef impl_idents *idents;
typedef const impl_idents *c_idents;
typedef impl_structTypeList *structTypeList;
typedef const impl_structTypeList *c_structTypeList;
typedef impl_structType *structType;
typedef const impl_structType *c_structType;
typedef impl_varOrArray *varOrArray;
typedef const impl_varOrArray *c_varOrArray;
typedef impl_arrayList *arrayList;
typedef const impl_arrayList *c_arrayList;
typedef impl_array *array;
typedef const impl_array *c_array;
typedef impl_function *function;
typedef const impl_function *c_function;
typedef impl_optFunctionParameters *optFunctionParameters;
typedef const impl_optFunctionParameters *c_optFunctionParameters;
typedef impl_functionParametersList *functionParametersList;
typedef const impl_functionParametersList *c_functionParametersList;
typedef impl_functionParameters *functionParameters;
typedef const impl_functionParameters *c_functionParameters;
typedef impl_constant *constant;
typedef const impl_constant *c_constant;
typedef impl_expression *expression;
typedef const impl_expression *c_expression;
typedef impl_expressionWithoutInitializer *expressionWithoutInitializer;
typedef const impl_expressionWithoutInitializer *c_expressionWithoutInitializer;
typedef impl_assignment *assignment;
typedef const impl_assignment *c_assignment;
typedef impl_incdecrement *incdecrement;
typedef const impl_incdecrement *c_incdecrement;
typedef impl_arithmetic *arithmetic;
typedef const impl_arithmetic *c_arithmetic;
typedef impl_arithmeticWithoutInitializer *arithmeticWithoutInitializer;
typedef const impl_arithmeticWithoutInitializer *c_arithmeticWithoutInitializer;
typedef impl_logical *logical;
typedef const impl_logical *c_logical;
typedef impl_logicalWithoutInitializer *logicalWithoutInitializer;
typedef const impl_logicalWithoutInitializer *c_logicalWithoutInitializer;
typedef impl_comparison *comparison;
typedef const impl_comparison *c_comparison;
typedef impl_comparisonWithoutInitializer *comparisonWithoutInitializer;
typedef const impl_comparisonWithoutInitializer *c_comparisonWithoutInitializer;
typedef impl_leftvalue *leftvalue;
typedef const impl_leftvalue *c_leftvalue;
typedef impl_other *other;
typedef const impl_other *c_other;
typedef impl_otherWithoutInitializer *otherWithoutInitializer;
typedef const impl_otherWithoutInitializer *c_otherWithoutInitializer;
typedef impl_initializerList *initializerList;
typedef const impl_initializerList *c_initializerList;
typedef impl_expressionListColon *expressionListColon;
typedef const impl_expressionListColon *c_expressionListColon;
typedef impl_places *places;
typedef const impl_places *c_places;
typedef impl_optSafe *optSafe;
typedef const impl_optSafe *c_optSafe;
typedef impl_optNumber *optNumber;
typedef const impl_optNumber *c_optNumber;
typedef impl_optType *optType;
typedef const impl_optType *c_optType;
typedef impl_place *place;
typedef const impl_place *c_place;
typedef impl_commaPlaces *commaPlaces;
typedef const impl_commaPlaces *c_commaPlaces;
typedef impl_morePlaces *morePlaces;
typedef const impl_morePlaces *c_morePlaces;
typedef impl_marking *marking;
typedef const impl_marking *c_marking;
typedef impl_markingList *markingList;
typedef const impl_markingList *c_markingList;
typedef impl_transition *transition;
typedef const impl_transition *c_transition;
typedef impl_fairness *fairness;
typedef const impl_fairness *c_fairness;
typedef impl_variable *variable;
typedef const impl_variable *c_variable;
typedef impl_varOrArrayList *varOrArrayList;
typedef const impl_varOrArrayList *c_varOrArrayList;
typedef impl_guard *guard;
typedef const impl_guard *c_guard;
typedef impl_optIdentExprList *optIdentExprList;
typedef const impl_optIdentExprList *c_optIdentExprList;
typedef impl_identExprList *identExprList;
typedef const impl_identExprList *c_identExprList;
typedef impl_block *block;
typedef const impl_block *c_block;
typedef impl_declarationOrStatement *declarationOrStatement;
typedef const impl_declarationOrStatement *c_declarationOrStatement;
typedef impl_declaration *declaration;
typedef const impl_declaration *c_declaration;
typedef impl_statement *statement;
typedef const impl_statement *c_statement;
typedef impl_ifStatement *ifStatement;
typedef const impl_ifStatement *c_ifStatement;
typedef impl_optElse *optElse;
typedef const impl_optElse *c_optElse;
typedef impl_switchCase *switchCase;
typedef const impl_switchCase *c_switchCase;
typedef impl_switchCaseList *switchCaseList;
typedef const impl_switchCaseList *c_switchCaseList;

#define KC_NO_OF_OPERATORS 186


} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 2 "abstract.k"
typedef enum{UNDEF,BOOL,NUMB}checkName;

#line  908 "k.h"
/* end included stuff */


namespace kc {

#ifndef KC_NO_DEFAULT_IN_WITH
# define KC_NO_DEFAULT_IN_WITH "Internal Error: no default action defined in function %s at %s:%d\n"
#endif
void kc_no_default_in_with (const char*, int, const char*);
void kc_returnless_function (const char *, int, const char*);

#ifndef NDEBUG
# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)
# define assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)
# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false)
# define assertPhylum(ptr,phy) do { \
    assertNonNull(ptr); \
    if (ptr->phylum()!=phy) \
	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,"->prod_sel()","phy",__FILE__,__LINE__); \
} while(false)
#else
# define assertCond(t)
# define assertReason(t,s)
# define assertNonNull(ptr)
# define assertPhylum(op,phy)
#endif
#define assertionFailed(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)

void kc_assertionFailed (const char*, int) __attribute__ ((noreturn));
void kc_assertionReasonFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const char*, const char*, int) __attribute__ ((noreturn));

casestring mkcasestring( const kc_char_t *, int length = -1);
nocasestring mknocasestring( const kc_char_t *, int length = -1);
integer mkinteger( const INTEGER );
real mkreal( const REAL );
inline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }
inline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }
inline integer _Int( const INTEGER cc) { return mkinteger(cc); }
inline real _Real( const REAL cc) { return mkreal(cc); }
class impl_net_Net* Net (netName, definitionsList, places, marking, transition);
class impl_netName_EmptyNetName* EmptyNetName ();
class impl_netName_NetName* NetName (casestring);
class impl_definitionsList_EmptyDefinitionsList* EmptyDefinitionsList ();
class impl_definitionsList_DefinitionsList* DefinitionsList (definitionsList, definitions);
class impl_definitions_DefSort* DefSort (sort);
class impl_definitions_DefFunction* DefFunction (function);
class impl_definitions_DefConstant* DefConstant (constant);
class impl_sort_Sort* Sort (type, casestring, arrayList);
class impl_type_TypeBool* TypeBool ();
class impl_type_TypeEnum* TypeEnum (identList);
class impl_type_TypeIdent* TypeIdent (casestring);
class impl_type_TypeIntInterval* TypeIntInterval (expression, expression);
class impl_type_TypeStruct* TypeStruct (structTypeList);
class impl_type_TypeInt* TypeInt ();
class impl_type_TypeMultiset* TypeMultiset (type);
class impl_identList_EmptyIdentList* EmptyIdentList ();
class impl_identList_IdentList* IdentList (identList, idents);
class impl_idents_Ident* Ident (casestring, integer);
class impl_structTypeList_SingleStructTypeList* SingleStructTypeList (structType);
class impl_structTypeList_StructTypeList* StructTypeList (structTypeList, structType);
class impl_structType_StructType* StructType (type, casestring, arrayList);
class impl_varOrArray_VarOrArray* VarOrArray (casestring, arrayList);
class impl_arrayList_EmptyArrayList* EmptyArrayList ();
class impl_arrayList_ArrayList* ArrayList (arrayList, array);
class impl_array_Array* Array (expression);
class impl_function_Function* Function (type, casestring, arrayList, optFunctionParameters, block);
class impl_optFunctionParameters_EmptyOptFunctionParameters* EmptyOptFunctionParameters ();
class impl_optFunctionParameters_OptFunctionParameters* OptFunctionParameters (type, varOrArray, functionParametersList);
class impl_functionParametersList_EmptyFunctionParametersList* EmptyFunctionParametersList ();
class impl_functionParametersList_FunctionParametersList* FunctionParametersList (functionParametersList, functionParameters);
class impl_functionParameters_FunctionParameters* FunctionParameters (type, varOrArray);
class impl_constant_Constant* Constant (type, casestring, arrayList, expression);
class impl_expression_ExprAssignment* ExprAssignment (assignment);
class impl_expression_ExprIncdecrement* ExprIncdecrement (incdecrement);
class impl_expression_ExprArithmetic* ExprArithmetic (arithmetic);
class impl_expression_ExprLogical* ExprLogical (logical);
class impl_expression_ExprComparison* ExprComparison (comparison);
class impl_expression_ExprLeftvalue* ExprLeftvalue (leftvalue);
class impl_expression_ExprOther* ExprOther (other);
class impl_expression_ExprInitializerList* ExprInitializerList (initializerList);
class impl_expression_ExprInParenthesis* ExprInParenthesis (expression);
class impl_expressionWithoutInitializer_ExprAssignment2* ExprAssignment2 (assignment);
class impl_expressionWithoutInitializer_ExprIncdecrement2* ExprIncdecrement2 (incdecrement);
class impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer* ExprArithmeticWithoutInitializer (arithmeticWithoutInitializer);
class impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer* ExprLogicalWithoutInitializer (logicalWithoutInitializer);
class impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer* ExprComparisonWithoutInitializer (comparisonWithoutInitializer);
class impl_expressionWithoutInitializer_ExprLeftvalue2* ExprLeftvalue2 (leftvalue);
class impl_expressionWithoutInitializer_ExprOtherWithoutInitializer* ExprOtherWithoutInitializer (otherWithoutInitializer);
class impl_expressionWithoutInitializer_ExprInParenthesis2* ExprInParenthesis2 (expression);
class impl_assignment_AssignEqual* AssignEqual (leftvalue, expression);
class impl_assignment_AssignPlus* AssignPlus (leftvalue, expression);
class impl_assignment_AssignMinus* AssignMinus (leftvalue, expression);
class impl_assignment_AssignTimes* AssignTimes (leftvalue, expression);
class impl_assignment_AssignDivide* AssignDivide (leftvalue, expression);
class impl_assignment_AssignMod* AssignMod (leftvalue, expression);
class impl_incdecrement_IncrementVal* IncrementVal (leftvalue);
class impl_incdecrement_DecrementVal* DecrementVal (leftvalue);
class impl_incdecrement_ValIncrement* ValIncrement (leftvalue);
class impl_incdecrement_ValDecrement* ValDecrement (leftvalue);
class impl_arithmetic_PositiveExpr* PositiveExpr (expression);
class impl_arithmetic_NegativeExpr* NegativeExpr (expression);
class impl_arithmetic_ExprAddition* ExprAddition (expression, expression);
class impl_arithmetic_ExprSubtraction* ExprSubtraction (expression, expression);
class impl_arithmetic_ExprMultiplication* ExprMultiplication (expression, expression);
class impl_arithmetic_ExprDivision* ExprDivision (expression, expression);
class impl_arithmetic_ExprModulo* ExprModulo (expression, expression);
class impl_arithmetic_ExprNumber* ExprNumber (integer);
class impl_arithmeticWithoutInitializer_PositiveExpr2* PositiveExpr2 (expression);
class impl_arithmeticWithoutInitializer_NegativeExpr2* NegativeExpr2 (expression);
class impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer* ExprAdditionWithoutInitializer (expressionWithoutInitializer, expression);
class impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer* ExprSubtractionWithoutInitializer (expressionWithoutInitializer, expression);
class impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer* ExprMultiplicationWithoutInitializer (expressionWithoutInitializer, expression);
class impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer* ExprDivisionWithoutInitializer (expressionWithoutInitializer, expression);
class impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer* ExprModuloWithoutInitializer (expressionWithoutInitializer, expression);
class impl_arithmeticWithoutInitializer_ExprNumber2* ExprNumber2 (integer);
class impl_logical_NotExpr* NotExpr (expression);
class impl_logical_ExprAnd* ExprAnd (expression, expression);
class impl_logical_ExprOr* ExprOr (expression, expression);
class impl_logical_ExprTrue* ExprTrue ();
class impl_logical_ExprFalse* ExprFalse ();
class impl_logicalWithoutInitializer_NotExpr2* NotExpr2 (expression);
class impl_logicalWithoutInitializer_ExprAndWithoutInitializer* ExprAndWithoutInitializer (expressionWithoutInitializer, expression);
class impl_logicalWithoutInitializer_ExprOrWithoutInitializer* ExprOrWithoutInitializer (expressionWithoutInitializer, expression);
class impl_logicalWithoutInitializer_ExprTrue2* ExprTrue2 ();
class impl_logicalWithoutInitializer_ExprFalse2* ExprFalse2 ();
class impl_comparison_ExprEquivalent* ExprEquivalent (expression, expression);
class impl_comparison_ExprNotEqual* ExprNotEqual (expression, expression);
class impl_comparison_ExprLessThan* ExprLessThan (expression, expression);
class impl_comparison_ExprGreaterThan* ExprGreaterThan (expression, expression);
class impl_comparison_ExprLessOrEqual* ExprLessOrEqual (expression, expression);
class impl_comparison_ExprGreaterOrEqual* ExprGreaterOrEqual (expression, expression);
class impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer* ExprEquivalentWithoutInitializer (expressionWithoutInitializer, expression);
class impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer* ExprNotEqualWithoutInitializer (expressionWithoutInitializer, expression);
class impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer* ExprLessThanWithoutInitializer (expressionWithoutInitializer, expression);
class impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer* ExprGreaterThanWithoutInitializer (expressionWithoutInitializer, expression);
class impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer* ExprLessOrEqualWithoutInitializer (expressionWithoutInitializer, expression);
class impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer* ExprGreaterOrEqualWithoutInitializer (expressionWithoutInitializer, expression);
class impl_leftvalue_LeftValIdent* LeftValIdent (casestring);
class impl_leftvalue_LeftValBrackets* LeftValBrackets (leftvalue, expression);
class impl_leftvalue_LeftValDot* LeftValDot (leftvalue, casestring);
class impl_other_ExprIdentParenthesis* ExprIdentParenthesis (casestring);
class impl_other_ExprIdentExprInParenthesis* ExprIdentExprInParenthesis (casestring, expression);
class impl_other_ExprCommaSeparated* ExprCommaSeparated (expression, expression);
class impl_other_ExprOtherIf* ExprOtherIf (expression, expression, expression);
class impl_other_ExprAll* ExprAll (type);
class impl_otherWithoutInitializer_ExprIdentParenthesis2* ExprIdentParenthesis2 (casestring);
class impl_otherWithoutInitializer_ExprIdentExprInParenthesis2* ExprIdentExprInParenthesis2 (casestring, expression);
class impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer* ExprCommaSeparatedWithoutInitializer (expressionWithoutInitializer, expression);
class impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer* ExprOtherIfWithoutInitializer (expressionWithoutInitializer, expression, expression);
class impl_otherWithoutInitializer_ExprAll2* ExprAll2 (type);
class impl_initializerList_Braces* Braces ();
class impl_initializerList_ExprInBraces* ExprInBraces (expression);
class impl_initializerList_ExprInBracesColon* ExprInBracesColon (expression, expression, expressionListColon);
class impl_expressionListColon_EmptyExpressionListColon* EmptyExpressionListColon ();
class impl_expressionListColon_ExpressionListColon* ExpressionListColon (expression, expression, expressionListColon);
class impl_places_Places* Places (optSafe, optType, place, commaPlaces, morePlaces);
class impl_optSafe_EmptySafe* EmptySafe ();
class impl_optSafe_Safe* Safe (optNumber);
class impl_optNumber_EmptyPlaceNumber* EmptyPlaceNumber ();
class impl_optNumber_PlaceNumber* PlaceNumber (integer);
class impl_optType_EmptyPlaceType* EmptyPlaceType ();
class impl_optType_PlaceTypeBool* PlaceTypeBool ();
class impl_optType_PlaceTypeEnum* PlaceTypeEnum (casestring, integer, identList);
class impl_optType_PlaceTypeIntInterval* PlaceTypeIntInterval (expression, expression);
class impl_optType_PlaceTypeStruct* PlaceTypeStruct (structTypeList);
class impl_optType_PlaceTypeInt* PlaceTypeInt ();
class impl_optType_PlaceTypeMultiset* PlaceTypeMultiset (type);
class impl_place_Place* Place (casestring);
class impl_place_PlaceWithTypeIdent* PlaceWithTypeIdent (casestring, casestring);
class impl_commaPlaces_EmptyCommaPlaces* EmptyCommaPlaces ();
class impl_commaPlaces_CommaPlaces* CommaPlaces (optType, place, commaPlaces);
class impl_morePlaces_EmptyMorePlaces* EmptyMorePlaces ();
class impl_morePlaces_MorePlaces* MorePlaces (optSafe, optType, place, commaPlaces, morePlaces);
class impl_marking_EmptyMarking* EmptyMarking ();
class impl_marking_Marking* Marking (casestring, expression, markingList);
class impl_markingList_EmptyMarkingList* EmptyMarkingList ();
class impl_markingList_MarkingList* MarkingList (casestring, expression, markingList);
class impl_transition_EmptyTransition* EmptyTransition ();
class impl_transition_Transition* Transition (casestring, fairness, variable, guard, optIdentExprList, optIdentExprList, transition);
class impl_fairness_EmptyFairness* EmptyFairness ();
class impl_fairness_WeakFair* WeakFair ();
class impl_fairness_StrongFair* StrongFair ();
class impl_variable_EmptyVariable* EmptyVariable ();
class impl_variable_Variable* Variable (type, varOrArray, varOrArrayList, variable);
class impl_varOrArrayList_EmptyVarOrArrayList* EmptyVarOrArrayList ();
class impl_varOrArrayList_VarOrArrayList* VarOrArrayList (varOrArray, varOrArrayList);
class impl_guard_EmptyGuard* EmptyGuard ();
class impl_guard_Guard* Guard (expression);
class impl_optIdentExprList_EmptyOptIdentExprList* EmptyOptIdentExprList ();
class impl_optIdentExprList_OptIdentExprList* OptIdentExprList (casestring, expression, identExprList);
class impl_identExprList_EmptyIdentExprList* EmptyIdentExprList ();
class impl_identExprList_IdentExprList* IdentExprList (casestring, expression, identExprList);
class impl_block_Block* Block (declarationOrStatement);
class impl_declarationOrStatement_EmptyDeclarationOrStatement* EmptyDeclarationOrStatement ();
class impl_declarationOrStatement_DeclOrStatemDeclaration* DeclOrStatemDeclaration (declaration, declarationOrStatement);
class impl_declarationOrStatement_DeclOrStatemStatement* DeclOrStatemStatement (statement, declarationOrStatement);
class impl_declaration_Declaration* Declaration (type, varOrArray, varOrArrayList);
class impl_statement_StatementSemiolon* StatementSemiolon ();
class impl_statement_StatementBlock* StatementBlock (block);
class impl_statement_StatementExprSemicolon* StatementExprSemicolon (expressionWithoutInitializer);
class impl_statement_StatementIf* StatementIf (ifStatement);
class impl_statement_StatementWhile* StatementWhile (expression, statement);
class impl_statement_StatementDoWhile* StatementDoWhile (statement, expression);
class impl_statement_StatementForExpr* StatementForExpr (expression, expression, expression, statement);
class impl_statement_StatementForTypeExpr* StatementForTypeExpr (type, casestring, expression, expression, expression, statement);
class impl_statement_StatementForIdentColon* StatementForIdentColon (casestring, expression, statement);
class impl_statement_StatementForAll* StatementForAll (type, casestring, type);
class impl_statement_StatementSwitch* StatementSwitch (expression, switchCase);
class impl_statement_StatementBreak* StatementBreak ();
class impl_statement_StatementContinue* StatementContinue ();
class impl_statement_StatementReturn* StatementReturn (expression);
class impl_ifStatement_IfStatement* IfStatement (expression, statement, optElse);
class impl_optElse_OptElseEmpty* OptElseEmpty ();
class impl_optElse_OptElse* OptElse (statement);
class impl_switchCase_SwitchCase* SwitchCase (expression, statement, switchCaseList);
class impl_switchCase_SwitchDefault* SwitchDefault (statement, switchCaseList);
class impl_switchCaseList_EmptySwitchCaseList* EmptySwitchCaseList ();
class impl_switchCaseList_SwitchCaseList* SwitchCaseList (expression, statement, switchCaseList);
class impl_switchCaseList_SwitchDefaultList* SwitchDefaultList (statement, switchCaseList);

//namespace Phylum {

class impl_abstract_phylum {
public:
    virtual enum_operators prod_sel() const =0;
    static const enum_phyla phylum_sel_;
    enum_phyla phylum() const;
    const char* phylum_name() const;
    const char* op_name() const;
    virtual abstract_phylum subphylum(int) const;
    virtual void set_subphylum(int, abstract_phylum);
    void free(bool recursive=true);
    bool eq(c_abstract_phylum) const;
    void print();
    void fprint(FILE *);
    abstract_phylum copy(bool kc_copy_attributes) const;
    void unparse(printer_functor pf, uview uv)
	{ do_unparse(pf, uv); }
    void unparse(printer_function opf, uview uv);

    void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;
    void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;
    void do_printdot (FILE*, bool, int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;

    virtual void fprintdot(FILE *,
	const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes,
	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;
    virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }
    virtual abstract_phylum do_rewrite(rview) { return this;}
    // called if a subphylum of an op is rewritten and a new op is created by default rule
    virtual void rewrite_members(abstract_phylum from) {} 
    virtual void post_create(){}
    virtual ~impl_abstract_phylum() { }
private:
    virtual void do_unparse(printer_functor, uview) =0;
protected:
    virtual void default_unparse(printer_functor, uview);
};


class impl_abstract_list: public impl_abstract_phylum{
private:
    void fprint_list(FILE *);
    friend class impl_abstract_phylum;
protected:
    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;
    abstract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;
    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);
    abstract_phylum do_filter(bool (*kc_fp)(abstract_phylum), enum_operators);
    abstract_list   do_append(abstract_phylum, abstract_list);
    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum), enum_operators);
    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));
public:
    virtual bool is_nil() const =0;
    virtual abstract_list reverse() const =0;
    int length() const;
    abstract_phylum last() const;
    // Non-virtual, non-existing... Type must be known exactly anyway because
    // of the function given as a parameter
    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;
    //virtual abstract_list filter(bool (*)(abstract_phylum)) =0;
    void freelist();
};

abstract_phylum kc_create(enum_operators createOp, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0);
abstract_phylum kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps);
abstract_phylum& attributeOf(abstract_phylum kc_p, int no);

class impl_nocasestring_NoCaseStr;
typedef impl_nocasestring_NoCaseStr impl_nocasestring;
class impl_nocasestring_NoCaseStr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel_NoCaseStr; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_nocasestring_NoCaseStr(const kc_char_t*);
    void make_own(int length);
    friend nocasestring mknocasestring(const kc_char_t*, int);
public:
    ~impl_nocasestring_NoCaseStr() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    nocasestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_casestring__Str;
typedef impl_casestring__Str impl_casestring;
class impl_casestring__Str:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Str; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_casestring__Str(const kc_char_t*);
    void make_own(int length);
    friend casestring mkcasestring(const kc_char_t*, int);
public:
    ~impl_casestring__Str() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    casestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_real__Real;
typedef impl_real__Real impl_real;
class impl_real__Real:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Real; }
    static const enum_phyla phylum_sel_;
    explicit impl_real__Real(REAL _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    real rewrite( rview )
	{ return this; }
    REAL value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_integer__Int;
typedef impl_integer__Int impl_integer;
class impl_integer__Int:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Int; }
    static const enum_phyla phylum_sel_;
    explicit impl_integer__Int(INTEGER _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    integer rewrite( rview )
	{ return this; }
    INTEGER value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_voidptr__VoidPtr;
typedef impl_voidptr__VoidPtr impl_voidptr;
class impl_voidptr__VoidPtr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__VoidPtr; }
    static const enum_phyla phylum_sel_;
    explicit impl_voidptr__VoidPtr(void* _pointer);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    voidptr rewrite( rview )
	{ return this; }
    void* pointer;
private:
    void do_unparse(printer_functor, uview);
};
class impl_net: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    net rewrite(rview) =0;
};
class impl_net_Net:public impl_net{
public:
    enum_operators prod_sel() const
	{ return sel_Net; }
    explicit impl_net_Net(netName, definitionsList, places, marking, transition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    net rewrite( rview );
    impl_netName* netName_1;
    impl_definitionsList* definitionsList_1;
    impl_places* places_1;
    impl_marking* marking_1;
    impl_transition* transition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_netName: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    netName rewrite(rview) =0;
};
class impl_netName_NetName:public impl_netName{
public:
    enum_operators prod_sel() const
	{ return sel_NetName; }
    explicit impl_netName_NetName(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    netName rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_netName_EmptyNetName:public impl_netName{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyNetName; }
    explicit impl_netName_EmptyNetName();

    netName rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitionsList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    definitionsList rewrite(rview) =0;
};
class impl_definitionsList_DefinitionsList:public impl_definitionsList{
public:
    enum_operators prod_sel() const
	{ return sel_DefinitionsList; }
    explicit impl_definitionsList_DefinitionsList(definitionsList, definitions);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitionsList rewrite( rview );
    impl_definitionsList* definitionsList_1;
    impl_definitions* definitions_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitionsList_EmptyDefinitionsList:public impl_definitionsList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyDefinitionsList; }
    explicit impl_definitionsList_EmptyDefinitionsList();

    definitionsList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    definitions rewrite(rview) =0;
};
class impl_definitions_DefConstant:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_DefConstant; }
    explicit impl_definitions_DefConstant(constant);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_constant* constant_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions_DefFunction:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_DefFunction; }
    explicit impl_definitions_DefFunction(function);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_function* function_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_definitions_DefSort:public impl_definitions{
public:
    enum_operators prod_sel() const
	{ return sel_DefSort; }
    explicit impl_definitions_DefSort(sort);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    definitions rewrite( rview );
    impl_sort* sort_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_sort: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    sort rewrite(rview) =0;
};
class impl_sort_Sort:public impl_sort{
public:
    enum_operators prod_sel() const
	{ return sel_Sort; }
    explicit impl_sort_Sort(type, casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    sort rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    type rewrite(rview) =0;
};
class impl_type_TypeMultiset:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeMultiset; }
    explicit impl_type_TypeMultiset(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeInt:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeInt; }
    explicit impl_type_TypeInt();

    type rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeStruct:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeStruct; }
    explicit impl_type_TypeStruct(structTypeList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_structTypeList* structTypeList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeIntInterval:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeIntInterval; }
    explicit impl_type_TypeIntInterval(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeIdent:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeIdent; }
    explicit impl_type_TypeIdent(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeEnum:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeEnum; }
    explicit impl_type_TypeEnum(identList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    type rewrite( rview );
    impl_identList* identList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_type_TypeBool:public impl_type{
public:
    enum_operators prod_sel() const
	{ return sel_TypeBool; }
    explicit impl_type_TypeBool();

    type rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_identList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    identList rewrite(rview) =0;
};
class impl_identList_IdentList:public impl_identList{
public:
    enum_operators prod_sel() const
	{ return sel_IdentList; }
    explicit impl_identList_IdentList(identList, idents);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    identList rewrite( rview );
    impl_identList* identList_1;
    impl_idents* idents_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_identList_EmptyIdentList:public impl_identList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyIdentList; }
    explicit impl_identList_EmptyIdentList();

    identList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_idents: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    idents rewrite(rview) =0;
};
class impl_idents_Ident:public impl_idents{
public:
    enum_operators prod_sel() const
	{ return sel_Ident; }
    explicit impl_idents_Ident(casestring, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    idents rewrite( rview );
    impl_casestring* casestring_1;
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_structTypeList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    structTypeList rewrite(rview) =0;
};
class impl_structTypeList_StructTypeList:public impl_structTypeList{
public:
    enum_operators prod_sel() const
	{ return sel_StructTypeList; }
    explicit impl_structTypeList_StructTypeList(structTypeList, structType);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    structTypeList rewrite( rview );
    impl_structTypeList* structTypeList_1;
    impl_structType* structType_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_structTypeList_SingleStructTypeList:public impl_structTypeList{
public:
    enum_operators prod_sel() const
	{ return sel_SingleStructTypeList; }
    explicit impl_structTypeList_SingleStructTypeList(structType);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    structTypeList rewrite( rview );
    impl_structType* structType_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_structType: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    structType rewrite(rview) =0;
};
class impl_structType_StructType:public impl_structType{
public:
    enum_operators prod_sel() const
	{ return sel_StructType; }
    explicit impl_structType_StructType(type, casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    structType rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArray: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    varOrArray rewrite(rview) =0;
};
class impl_varOrArray_VarOrArray:public impl_varOrArray{
public:
    enum_operators prod_sel() const
	{ return sel_VarOrArray; }
    explicit impl_varOrArray_VarOrArray(casestring, arrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    varOrArray rewrite( rview );
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arrayList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    arrayList rewrite(rview) =0;
};
class impl_arrayList_ArrayList:public impl_arrayList{
public:
    enum_operators prod_sel() const
	{ return sel_ArrayList; }
    explicit impl_arrayList_ArrayList(arrayList, array);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arrayList rewrite( rview );
    impl_arrayList* arrayList_1;
    impl_array* array_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arrayList_EmptyArrayList:public impl_arrayList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyArrayList; }
    explicit impl_arrayList_EmptyArrayList();

    arrayList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_array: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    array rewrite(rview) =0;
};
class impl_array_Array:public impl_array{
public:
    enum_operators prod_sel() const
	{ return sel_Array; }
    explicit impl_array_Array(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    array rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_function: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    function rewrite(rview) =0;
};
class impl_function_Function:public impl_function{
public:
    enum_operators prod_sel() const
	{ return sel_Function; }
    explicit impl_function_Function(type, casestring, arrayList, optFunctionParameters, block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    function rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
    impl_optFunctionParameters* optFunctionParameters_1;
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optFunctionParameters: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optFunctionParameters rewrite(rview) =0;
};
class impl_optFunctionParameters_OptFunctionParameters:public impl_optFunctionParameters{
public:
    enum_operators prod_sel() const
	{ return sel_OptFunctionParameters; }
    explicit impl_optFunctionParameters_OptFunctionParameters(type, varOrArray, functionParametersList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optFunctionParameters rewrite( rview );
    impl_type* type_1;
    impl_varOrArray* varOrArray_1;
    impl_functionParametersList* functionParametersList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optFunctionParameters_EmptyOptFunctionParameters:public impl_optFunctionParameters{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyOptFunctionParameters; }
    explicit impl_optFunctionParameters_EmptyOptFunctionParameters();

    optFunctionParameters rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParametersList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    functionParametersList rewrite(rview) =0;
};
class impl_functionParametersList_FunctionParametersList:public impl_functionParametersList{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionParametersList; }
    explicit impl_functionParametersList_FunctionParametersList(functionParametersList, functionParameters);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    functionParametersList rewrite( rview );
    impl_functionParametersList* functionParametersList_1;
    impl_functionParameters* functionParameters_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParametersList_EmptyFunctionParametersList:public impl_functionParametersList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyFunctionParametersList; }
    explicit impl_functionParametersList_EmptyFunctionParametersList();

    functionParametersList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_functionParameters: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    functionParameters rewrite(rview) =0;
};
class impl_functionParameters_FunctionParameters:public impl_functionParameters{
public:
    enum_operators prod_sel() const
	{ return sel_FunctionParameters; }
    explicit impl_functionParameters_FunctionParameters(type, varOrArray);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    functionParameters rewrite( rview );
    impl_type* type_1;
    impl_varOrArray* varOrArray_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_constant: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    constant rewrite(rview) =0;
};
class impl_constant_Constant:public impl_constant{
public:
    enum_operators prod_sel() const
	{ return sel_Constant; }
    explicit impl_constant_Constant(type, casestring, arrayList, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    constant rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_arrayList* arrayList_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    bool isConst;
    int constValue;
    expression rewrite(rview) =0;
};
class impl_expression_ExprInParenthesis:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInParenthesis; }
    explicit impl_expression_ExprInParenthesis(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprInitializerList:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInitializerList; }
    explicit impl_expression_ExprInitializerList(initializerList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_initializerList* initializerList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprOther:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOther; }
    explicit impl_expression_ExprOther(other);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_other* other_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprLeftvalue:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLeftvalue; }
    explicit impl_expression_ExprLeftvalue(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprComparison:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprComparison; }
    explicit impl_expression_ExprComparison(comparison);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_comparison* comparison_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprLogical:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLogical; }
    explicit impl_expression_ExprLogical(logical);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_logical* logical_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprArithmetic:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprArithmetic; }
    explicit impl_expression_ExprArithmetic(arithmetic);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_arithmetic* arithmetic_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprIncdecrement:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIncdecrement; }
    explicit impl_expression_ExprIncdecrement(incdecrement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_incdecrement* incdecrement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expression_ExprAssignment:public impl_expression{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAssignment; }
    explicit impl_expression_ExprAssignment(assignment);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expression rewrite( rview );
    impl_assignment* assignment_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    expressionWithoutInitializer rewrite(rview) =0;
};
class impl_expressionWithoutInitializer_ExprInParenthesis2:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInParenthesis2; }
    explicit impl_expressionWithoutInitializer_ExprInParenthesis2(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprOtherWithoutInitializer:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOtherWithoutInitializer; }
    explicit impl_expressionWithoutInitializer_ExprOtherWithoutInitializer(otherWithoutInitializer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_otherWithoutInitializer* otherWithoutInitializer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprLeftvalue2:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLeftvalue2; }
    explicit impl_expressionWithoutInitializer_ExprLeftvalue2(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprComparisonWithoutInitializer; }
    explicit impl_expressionWithoutInitializer_ExprComparisonWithoutInitializer(comparisonWithoutInitializer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_comparisonWithoutInitializer* comparisonWithoutInitializer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLogicalWithoutInitializer; }
    explicit impl_expressionWithoutInitializer_ExprLogicalWithoutInitializer(logicalWithoutInitializer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_logicalWithoutInitializer* logicalWithoutInitializer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprArithmeticWithoutInitializer; }
    explicit impl_expressionWithoutInitializer_ExprArithmeticWithoutInitializer(arithmeticWithoutInitializer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_arithmeticWithoutInitializer* arithmeticWithoutInitializer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprIncdecrement2:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIncdecrement2; }
    explicit impl_expressionWithoutInitializer_ExprIncdecrement2(incdecrement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_incdecrement* incdecrement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionWithoutInitializer_ExprAssignment2:public impl_expressionWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAssignment2; }
    explicit impl_expressionWithoutInitializer_ExprAssignment2(assignment);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionWithoutInitializer rewrite( rview );
    impl_assignment* assignment_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    assignment rewrite(rview) =0;
};
class impl_assignment_AssignMod:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignMod; }
    explicit impl_assignment_AssignMod(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_AssignDivide:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignDivide; }
    explicit impl_assignment_AssignDivide(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_AssignTimes:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignTimes; }
    explicit impl_assignment_AssignTimes(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_AssignMinus:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignMinus; }
    explicit impl_assignment_AssignMinus(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_AssignPlus:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignPlus; }
    explicit impl_assignment_AssignPlus(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_assignment_AssignEqual:public impl_assignment{
public:
    enum_operators prod_sel() const
	{ return sel_AssignEqual; }
    explicit impl_assignment_AssignEqual(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    assignment rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_incdecrement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    incdecrement rewrite(rview) =0;
};
class impl_incdecrement_ValDecrement:public impl_incdecrement{
public:
    enum_operators prod_sel() const
	{ return sel_ValDecrement; }
    explicit impl_incdecrement_ValDecrement(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    incdecrement rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_incdecrement_ValIncrement:public impl_incdecrement{
public:
    enum_operators prod_sel() const
	{ return sel_ValIncrement; }
    explicit impl_incdecrement_ValIncrement(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    incdecrement rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_incdecrement_DecrementVal:public impl_incdecrement{
public:
    enum_operators prod_sel() const
	{ return sel_DecrementVal; }
    explicit impl_incdecrement_DecrementVal(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    incdecrement rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_incdecrement_IncrementVal:public impl_incdecrement{
public:
    enum_operators prod_sel() const
	{ return sel_IncrementVal; }
    explicit impl_incdecrement_IncrementVal(leftvalue);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    incdecrement rewrite( rview );
    impl_leftvalue* leftvalue_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    arithmetic rewrite(rview) =0;
};
class impl_arithmetic_ExprNumber:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNumber; }
    explicit impl_arithmetic_ExprNumber(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_ExprModulo:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprModulo; }
    explicit impl_arithmetic_ExprModulo(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_ExprDivision:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprDivision; }
    explicit impl_arithmetic_ExprDivision(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_ExprMultiplication:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprMultiplication; }
    explicit impl_arithmetic_ExprMultiplication(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_ExprSubtraction:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprSubtraction; }
    explicit impl_arithmetic_ExprSubtraction(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_ExprAddition:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAddition; }
    explicit impl_arithmetic_ExprAddition(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_NegativeExpr:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_NegativeExpr; }
    explicit impl_arithmetic_NegativeExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmetic_PositiveExpr:public impl_arithmetic{
public:
    enum_operators prod_sel() const
	{ return sel_PositiveExpr; }
    explicit impl_arithmetic_PositiveExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmetic rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    arithmeticWithoutInitializer rewrite(rview) =0;
};
class impl_arithmeticWithoutInitializer_ExprNumber2:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNumber2; }
    explicit impl_arithmeticWithoutInitializer_ExprNumber2(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprModuloWithoutInitializer; }
    explicit impl_arithmeticWithoutInitializer_ExprModuloWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprDivisionWithoutInitializer; }
    explicit impl_arithmeticWithoutInitializer_ExprDivisionWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprMultiplicationWithoutInitializer; }
    explicit impl_arithmeticWithoutInitializer_ExprMultiplicationWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprSubtractionWithoutInitializer; }
    explicit impl_arithmeticWithoutInitializer_ExprSubtractionWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAdditionWithoutInitializer; }
    explicit impl_arithmeticWithoutInitializer_ExprAdditionWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_NegativeExpr2:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_NegativeExpr2; }
    explicit impl_arithmeticWithoutInitializer_NegativeExpr2(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_arithmeticWithoutInitializer_PositiveExpr2:public impl_arithmeticWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_PositiveExpr2; }
    explicit impl_arithmeticWithoutInitializer_PositiveExpr2(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    arithmeticWithoutInitializer rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logical: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    logical rewrite(rview) =0;
};
class impl_logical_ExprFalse:public impl_logical{
public:
    enum_operators prod_sel() const
	{ return sel_ExprFalse; }
    explicit impl_logical_ExprFalse();

    logical rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_logical_ExprTrue:public impl_logical{
public:
    enum_operators prod_sel() const
	{ return sel_ExprTrue; }
    explicit impl_logical_ExprTrue();

    logical rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_logical_ExprOr:public impl_logical{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOr; }
    explicit impl_logical_ExprOr(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logical rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logical_ExprAnd:public impl_logical{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAnd; }
    explicit impl_logical_ExprAnd(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logical rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logical_NotExpr:public impl_logical{
public:
    enum_operators prod_sel() const
	{ return sel_NotExpr; }
    explicit impl_logical_NotExpr(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logical rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logicalWithoutInitializer: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    logicalWithoutInitializer rewrite(rview) =0;
};
class impl_logicalWithoutInitializer_ExprFalse2:public impl_logicalWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprFalse2; }
    explicit impl_logicalWithoutInitializer_ExprFalse2();

    logicalWithoutInitializer rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_logicalWithoutInitializer_ExprTrue2:public impl_logicalWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprTrue2; }
    explicit impl_logicalWithoutInitializer_ExprTrue2();

    logicalWithoutInitializer rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_logicalWithoutInitializer_ExprOrWithoutInitializer:public impl_logicalWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOrWithoutInitializer; }
    explicit impl_logicalWithoutInitializer_ExprOrWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logicalWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logicalWithoutInitializer_ExprAndWithoutInitializer:public impl_logicalWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAndWithoutInitializer; }
    explicit impl_logicalWithoutInitializer_ExprAndWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logicalWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_logicalWithoutInitializer_NotExpr2:public impl_logicalWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_NotExpr2; }
    explicit impl_logicalWithoutInitializer_NotExpr2(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    logicalWithoutInitializer rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    comparison rewrite(rview) =0;
};
class impl_comparison_ExprGreaterOrEqual:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterOrEqual; }
    explicit impl_comparison_ExprGreaterOrEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison_ExprLessOrEqual:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessOrEqual; }
    explicit impl_comparison_ExprLessOrEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison_ExprGreaterThan:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterThan; }
    explicit impl_comparison_ExprGreaterThan(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison_ExprLessThan:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessThan; }
    explicit impl_comparison_ExprLessThan(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison_ExprNotEqual:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNotEqual; }
    explicit impl_comparison_ExprNotEqual(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparison_ExprEquivalent:public impl_comparison{
public:
    enum_operators prod_sel() const
	{ return sel_ExprEquivalent; }
    explicit impl_comparison_ExprEquivalent(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparison rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    comparisonWithoutInitializer rewrite(rview) =0;
};
class impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterOrEqualWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprGreaterOrEqualWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessOrEqualWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprLessOrEqualWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprGreaterThanWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprGreaterThanWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprLessThanWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprLessThanWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprNotEqualWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprNotEqualWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer:public impl_comparisonWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprEquivalentWithoutInitializer; }
    explicit impl_comparisonWithoutInitializer_ExprEquivalentWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    comparisonWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    leftvalue rewrite(rview) =0;
};
class impl_leftvalue_LeftValDot:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValDot; }
    explicit impl_leftvalue_LeftValDot(leftvalue, casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue_LeftValBrackets:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValBrackets; }
    explicit impl_leftvalue_LeftValBrackets(leftvalue, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_leftvalue* leftvalue_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_leftvalue_LeftValIdent:public impl_leftvalue{
public:
    enum_operators prod_sel() const
	{ return sel_LeftValIdent; }
    explicit impl_leftvalue_LeftValIdent(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    leftvalue rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_other: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    other rewrite(rview) =0;
};
class impl_other_ExprAll:public impl_other{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAll; }
    explicit impl_other_ExprAll(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    other rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_other_ExprOtherIf:public impl_other{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOtherIf; }
    explicit impl_other_ExprOtherIf(expression, expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    other rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
private:
    void do_unparse(printer_functor, uview);
};
class impl_other_ExprCommaSeparated:public impl_other{
public:
    enum_operators prod_sel() const
	{ return sel_ExprCommaSeparated; }
    explicit impl_other_ExprCommaSeparated(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    other rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_other_ExprIdentExprInParenthesis:public impl_other{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIdentExprInParenthesis; }
    explicit impl_other_ExprIdentExprInParenthesis(casestring, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    other rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_other_ExprIdentParenthesis:public impl_other{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIdentParenthesis; }
    explicit impl_other_ExprIdentParenthesis(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    other rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_otherWithoutInitializer: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    checkName check;
    otherWithoutInitializer rewrite(rview) =0;
};
class impl_otherWithoutInitializer_ExprAll2:public impl_otherWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprAll2; }
    explicit impl_otherWithoutInitializer_ExprAll2(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    otherWithoutInitializer rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer:public impl_otherWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprOtherIfWithoutInitializer; }
    explicit impl_otherWithoutInitializer_ExprOtherIfWithoutInitializer(expressionWithoutInitializer, expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    otherWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer:public impl_otherWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprCommaSeparatedWithoutInitializer; }
    explicit impl_otherWithoutInitializer_ExprCommaSeparatedWithoutInitializer(expressionWithoutInitializer, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    otherWithoutInitializer rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_otherWithoutInitializer_ExprIdentExprInParenthesis2:public impl_otherWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIdentExprInParenthesis2; }
    explicit impl_otherWithoutInitializer_ExprIdentExprInParenthesis2(casestring, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    otherWithoutInitializer rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_otherWithoutInitializer_ExprIdentParenthesis2:public impl_otherWithoutInitializer{
public:
    enum_operators prod_sel() const
	{ return sel_ExprIdentParenthesis2; }
    explicit impl_otherWithoutInitializer_ExprIdentParenthesis2(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    otherWithoutInitializer rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_initializerList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    initializerList rewrite(rview) =0;
};
class impl_initializerList_ExprInBracesColon:public impl_initializerList{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInBracesColon; }
    explicit impl_initializerList_ExprInBracesColon(expression, expression, expressionListColon);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    initializerList rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expressionListColon* expressionListColon_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_initializerList_ExprInBraces:public impl_initializerList{
public:
    enum_operators prod_sel() const
	{ return sel_ExprInBraces; }
    explicit impl_initializerList_ExprInBraces(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    initializerList rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_initializerList_Braces:public impl_initializerList{
public:
    enum_operators prod_sel() const
	{ return sel_Braces; }
    explicit impl_initializerList_Braces();

    initializerList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionListColon: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    expressionListColon rewrite(rview) =0;
};
class impl_expressionListColon_ExpressionListColon:public impl_expressionListColon{
public:
    enum_operators prod_sel() const
	{ return sel_ExpressionListColon; }
    explicit impl_expressionListColon_ExpressionListColon(expression, expression, expressionListColon);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    expressionListColon rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expressionListColon* expressionListColon_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_expressionListColon_EmptyExpressionListColon:public impl_expressionListColon{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyExpressionListColon; }
    explicit impl_expressionListColon_EmptyExpressionListColon();

    expressionListColon rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_places: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    places rewrite(rview) =0;
};
class impl_places_Places:public impl_places{
public:
    enum_operators prod_sel() const
	{ return sel_Places; }
    explicit impl_places_Places(optSafe, optType, place, commaPlaces, morePlaces);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    places rewrite( rview );
    impl_optSafe* optSafe_1;
    impl_optType* optType_1;
    impl_place* place_1;
    impl_commaPlaces* commaPlaces_1;
    impl_morePlaces* morePlaces_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optSafe: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optSafe rewrite(rview) =0;
};
class impl_optSafe_Safe:public impl_optSafe{
public:
    enum_operators prod_sel() const
	{ return sel_Safe; }
    explicit impl_optSafe_Safe(optNumber);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optSafe rewrite( rview );
    impl_optNumber* optNumber_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optSafe_EmptySafe:public impl_optSafe{
public:
    enum_operators prod_sel() const
	{ return sel_EmptySafe; }
    explicit impl_optSafe_EmptySafe();

    optSafe rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optNumber: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optNumber rewrite(rview) =0;
};
class impl_optNumber_PlaceNumber:public impl_optNumber{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceNumber; }
    explicit impl_optNumber_PlaceNumber(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optNumber rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optNumber_EmptyPlaceNumber:public impl_optNumber{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyPlaceNumber; }
    explicit impl_optNumber_EmptyPlaceNumber();

    optNumber rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optType rewrite(rview) =0;
};
class impl_optType_PlaceTypeMultiset:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeMultiset; }
    explicit impl_optType_PlaceTypeMultiset(type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optType rewrite( rview );
    impl_type* type_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_PlaceTypeInt:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeInt; }
    explicit impl_optType_PlaceTypeInt();

    optType rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_PlaceTypeStruct:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeStruct; }
    explicit impl_optType_PlaceTypeStruct(structTypeList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optType rewrite( rview );
    impl_structTypeList* structTypeList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_PlaceTypeIntInterval:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeIntInterval; }
    explicit impl_optType_PlaceTypeIntInterval(expression, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optType rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_PlaceTypeEnum:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeEnum; }
    explicit impl_optType_PlaceTypeEnum(casestring, integer, identList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optType rewrite( rview );
    impl_casestring* casestring_1;
    impl_integer* integer_1;
    impl_identList* identList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_PlaceTypeBool:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceTypeBool; }
    explicit impl_optType_PlaceTypeBool();

    optType rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optType_EmptyPlaceType:public impl_optType{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyPlaceType; }
    explicit impl_optType_EmptyPlaceType();

    optType rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_place: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    place rewrite(rview) =0;
};
class impl_place_PlaceWithTypeIdent:public impl_place{
public:
    enum_operators prod_sel() const
	{ return sel_PlaceWithTypeIdent; }
    explicit impl_place_PlaceWithTypeIdent(casestring, casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    place rewrite( rview );
    impl_casestring* casestring_1;
    impl_casestring* casestring_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_place_Place:public impl_place{
public:
    enum_operators prod_sel() const
	{ return sel_Place; }
    explicit impl_place_Place(casestring);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    place rewrite( rview );
    impl_casestring* casestring_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_commaPlaces: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    commaPlaces rewrite(rview) =0;
};
class impl_commaPlaces_CommaPlaces:public impl_commaPlaces{
public:
    enum_operators prod_sel() const
	{ return sel_CommaPlaces; }
    explicit impl_commaPlaces_CommaPlaces(optType, place, commaPlaces);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    commaPlaces rewrite( rview );
    impl_optType* optType_1;
    impl_place* place_1;
    impl_commaPlaces* commaPlaces_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_commaPlaces_EmptyCommaPlaces:public impl_commaPlaces{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyCommaPlaces; }
    explicit impl_commaPlaces_EmptyCommaPlaces();

    commaPlaces rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_morePlaces: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    morePlaces rewrite(rview) =0;
};
class impl_morePlaces_MorePlaces:public impl_morePlaces{
public:
    enum_operators prod_sel() const
	{ return sel_MorePlaces; }
    explicit impl_morePlaces_MorePlaces(optSafe, optType, place, commaPlaces, morePlaces);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    morePlaces rewrite( rview );
    impl_optSafe* optSafe_1;
    impl_optType* optType_1;
    impl_place* place_1;
    impl_commaPlaces* commaPlaces_1;
    impl_morePlaces* morePlaces_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_morePlaces_EmptyMorePlaces:public impl_morePlaces{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyMorePlaces; }
    explicit impl_morePlaces_EmptyMorePlaces();

    morePlaces rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_marking: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    marking rewrite(rview) =0;
};
class impl_marking_Marking:public impl_marking{
public:
    enum_operators prod_sel() const
	{ return sel_Marking; }
    explicit impl_marking_Marking(casestring, expression, markingList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    marking rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_markingList* markingList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_marking_EmptyMarking:public impl_marking{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyMarking; }
    explicit impl_marking_EmptyMarking();

    marking rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_markingList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    markingList rewrite(rview) =0;
};
class impl_markingList_MarkingList:public impl_markingList{
public:
    enum_operators prod_sel() const
	{ return sel_MarkingList; }
    explicit impl_markingList_MarkingList(casestring, expression, markingList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    markingList rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_markingList* markingList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_markingList_EmptyMarkingList:public impl_markingList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyMarkingList; }
    explicit impl_markingList_EmptyMarkingList();

    markingList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_transition: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    transition rewrite(rview) =0;
};
class impl_transition_Transition:public impl_transition{
public:
    enum_operators prod_sel() const
	{ return sel_Transition; }
    explicit impl_transition_Transition(casestring, fairness, variable, guard, optIdentExprList, optIdentExprList, transition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    transition rewrite( rview );
    impl_casestring* casestring_1;
    impl_fairness* fairness_1;
    impl_variable* variable_1;
    impl_guard* guard_1;
    impl_optIdentExprList* optIdentExprList_1;
    impl_optIdentExprList* optIdentExprList_2;
    impl_transition* transition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_transition_EmptyTransition:public impl_transition{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyTransition; }
    explicit impl_transition_EmptyTransition();

    transition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    fairness rewrite(rview) =0;
};
class impl_fairness_StrongFair:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_StrongFair; }
    explicit impl_fairness_StrongFair();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness_WeakFair:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_WeakFair; }
    explicit impl_fairness_WeakFair();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_fairness_EmptyFairness:public impl_fairness{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyFairness; }
    explicit impl_fairness_EmptyFairness();

    fairness rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    variable rewrite(rview) =0;
};
class impl_variable_Variable:public impl_variable{
public:
    enum_operators prod_sel() const
	{ return sel_Variable; }
    explicit impl_variable_Variable(type, varOrArray, varOrArrayList, variable);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    variable rewrite( rview );
    impl_type* type_1;
    impl_varOrArray* varOrArray_1;
    impl_varOrArrayList* varOrArrayList_1;
    impl_variable* variable_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_variable_EmptyVariable:public impl_variable{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyVariable; }
    explicit impl_variable_EmptyVariable();

    variable rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArrayList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    varOrArrayList rewrite(rview) =0;
};
class impl_varOrArrayList_VarOrArrayList:public impl_varOrArrayList{
public:
    enum_operators prod_sel() const
	{ return sel_VarOrArrayList; }
    explicit impl_varOrArrayList_VarOrArrayList(varOrArray, varOrArrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    varOrArrayList rewrite( rview );
    impl_varOrArray* varOrArray_1;
    impl_varOrArrayList* varOrArrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_varOrArrayList_EmptyVarOrArrayList:public impl_varOrArrayList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyVarOrArrayList; }
    explicit impl_varOrArrayList_EmptyVarOrArrayList();

    varOrArrayList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_guard: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    guard rewrite(rview) =0;
};
class impl_guard_Guard:public impl_guard{
public:
    enum_operators prod_sel() const
	{ return sel_Guard; }
    explicit impl_guard_Guard(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    guard rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_guard_EmptyGuard:public impl_guard{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyGuard; }
    explicit impl_guard_EmptyGuard();

    guard rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_optIdentExprList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optIdentExprList rewrite(rview) =0;
};
class impl_optIdentExprList_OptIdentExprList:public impl_optIdentExprList{
public:
    enum_operators prod_sel() const
	{ return sel_OptIdentExprList; }
    explicit impl_optIdentExprList_OptIdentExprList(casestring, expression, identExprList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optIdentExprList rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_identExprList* identExprList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optIdentExprList_EmptyOptIdentExprList:public impl_optIdentExprList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyOptIdentExprList; }
    explicit impl_optIdentExprList_EmptyOptIdentExprList();

    optIdentExprList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_identExprList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    identExprList rewrite(rview) =0;
};
class impl_identExprList_IdentExprList:public impl_identExprList{
public:
    enum_operators prod_sel() const
	{ return sel_IdentExprList; }
    explicit impl_identExprList_IdentExprList(casestring, expression, identExprList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    identExprList rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_identExprList* identExprList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_identExprList_EmptyIdentExprList:public impl_identExprList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyIdentExprList; }
    explicit impl_identExprList_EmptyIdentExprList();

    identExprList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_block: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    block rewrite(rview) =0;
};
class impl_block_Block:public impl_block{
public:
    enum_operators prod_sel() const
	{ return sel_Block; }
    explicit impl_block_Block(declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    block rewrite( rview );
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    declarationOrStatement rewrite(rview) =0;
};
class impl_declarationOrStatement_DeclOrStatemStatement:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_DeclOrStatemStatement; }
    explicit impl_declarationOrStatement_DeclOrStatemStatement(statement, declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declarationOrStatement rewrite( rview );
    impl_statement* statement_1;
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement_DeclOrStatemDeclaration:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_DeclOrStatemDeclaration; }
    explicit impl_declarationOrStatement_DeclOrStatemDeclaration(declaration, declarationOrStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declarationOrStatement rewrite( rview );
    impl_declaration* declaration_1;
    impl_declarationOrStatement* declarationOrStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_declarationOrStatement_EmptyDeclarationOrStatement:public impl_declarationOrStatement{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyDeclarationOrStatement; }
    explicit impl_declarationOrStatement_EmptyDeclarationOrStatement();

    declarationOrStatement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_declaration: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    declaration rewrite(rview) =0;
};
class impl_declaration_Declaration:public impl_declaration{
public:
    enum_operators prod_sel() const
	{ return sel_Declaration; }
    explicit impl_declaration_Declaration(type, varOrArray, varOrArrayList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    declaration rewrite( rview );
    impl_type* type_1;
    impl_varOrArray* varOrArray_1;
    impl_varOrArrayList* varOrArrayList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    statement rewrite(rview) =0;
};
class impl_statement_StatementReturn:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementReturn; }
    explicit impl_statement_StatementReturn(expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementContinue:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementContinue; }
    explicit impl_statement_StatementContinue();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementBreak:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementBreak; }
    explicit impl_statement_StatementBreak();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementSwitch:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementSwitch; }
    explicit impl_statement_StatementSwitch(expression, switchCase);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_switchCase* switchCase_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForAll:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForAll; }
    explicit impl_statement_StatementForAll(type, casestring, type);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_type* type_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForIdentColon:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForIdentColon; }
    explicit impl_statement_StatementForIdentColon(casestring, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForTypeExpr:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForTypeExpr; }
    explicit impl_statement_StatementForTypeExpr(type, casestring, expression, expression, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_type* type_1;
    impl_casestring* casestring_1;
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementForExpr:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementForExpr; }
    explicit impl_statement_StatementForExpr(expression, expression, expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_expression* expression_2;
    impl_expression* expression_3;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementDoWhile:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementDoWhile; }
    explicit impl_statement_StatementDoWhile(statement, expression);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_statement* statement_1;
    impl_expression* expression_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementWhile:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementWhile; }
    explicit impl_statement_StatementWhile(expression, statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementIf:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementIf; }
    explicit impl_statement_StatementIf(ifStatement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_ifStatement* ifStatement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementExprSemicolon:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementExprSemicolon; }
    explicit impl_statement_StatementExprSemicolon(expressionWithoutInitializer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_expressionWithoutInitializer* expressionWithoutInitializer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementBlock:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementBlock; }
    explicit impl_statement_StatementBlock(block);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    statement rewrite( rview );
    impl_block* block_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_statement_StatementSemiolon:public impl_statement{
public:
    enum_operators prod_sel() const
	{ return sel_StatementSemiolon; }
    explicit impl_statement_StatementSemiolon();

    statement rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_ifStatement: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    ifStatement rewrite(rview) =0;
};
class impl_ifStatement_IfStatement:public impl_ifStatement{
public:
    enum_operators prod_sel() const
	{ return sel_IfStatement; }
    explicit impl_ifStatement_IfStatement(expression, statement, optElse);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    ifStatement rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
    impl_optElse* optElse_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optElse: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    optElse rewrite(rview) =0;
};
class impl_optElse_OptElse:public impl_optElse{
public:
    enum_operators prod_sel() const
	{ return sel_OptElse; }
    explicit impl_optElse_OptElse(statement);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    optElse rewrite( rview );
    impl_statement* statement_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_optElse_OptElseEmpty:public impl_optElse{
public:
    enum_operators prod_sel() const
	{ return sel_OptElseEmpty; }
    explicit impl_optElse_OptElseEmpty();

    optElse rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCase: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    switchCase rewrite(rview) =0;
};
class impl_switchCase_SwitchDefault:public impl_switchCase{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchDefault; }
    explicit impl_switchCase_SwitchDefault(statement, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCase rewrite( rview );
    impl_statement* statement_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCase_SwitchCase:public impl_switchCase{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchCase; }
    explicit impl_switchCase_SwitchCase(expression, statement, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCase rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCaseList: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    switchCaseList rewrite(rview) =0;
};
class impl_switchCaseList_SwitchDefaultList:public impl_switchCaseList{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchDefaultList; }
    explicit impl_switchCaseList_SwitchDefaultList(statement, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCaseList rewrite( rview );
    impl_statement* statement_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCaseList_SwitchCaseList:public impl_switchCaseList{
public:
    enum_operators prod_sel() const
	{ return sel_SwitchCaseList; }
    explicit impl_switchCaseList_SwitchCaseList(expression, statement, switchCaseList);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    switchCaseList rewrite( rview );
    impl_expression* expression_1;
    impl_statement* statement_1;
    impl_switchCaseList* switchCaseList_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_switchCaseList_EmptySwitchCaseList:public impl_switchCaseList{
public:
    enum_operators prod_sel() const
	{ return sel_EmptySwitchCaseList; }
    explicit impl_switchCaseList_EmptySwitchCaseList();

    switchCaseList rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};

//} // namespace Phylum


extern bool kc_storageclass_still_uniq[];

typedef struct {
    int created;
    int existing_not_found;
    int free_called[2];
    int freed[2];
} KC_OPERATOR_STATISTICS;

#ifdef KC_STATISTICS
# define print_operator_statistics(kc_f) do_print_operator_statistics(kc_f)
void	do_print_operator_statistics(FILE*);
#else
# define print_operator_statistics(kc_f)
#endif

typedef class hashtable_struct_t* hashtable_t;
void	ht_static (kc_storageclass_t);
void	ht_dynamic (kc_storageclass_t);
void	ht_inc_level (kc_storageclass_t);
void	ht_dec_level (kc_storageclass_t);
void	ht_free_level (kc_storageclass_t);
hashtable_t	ht_create_simple ();
hashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);
hashtable_t	ht_assigned (kc_storageclass_t);
void	ht_clear (hashtable_t);
void	ht_delete (hashtable_t);
const char *phylumname_or_error ( enum_phyla );
const char *kc_operatorname_or_error ( enum_operators );


void fprintdotprologue ( FILE* );
void fprintdotepilogue ( FILE* );

} // namespace kc
#endif // KC_TYPES_HEADER
