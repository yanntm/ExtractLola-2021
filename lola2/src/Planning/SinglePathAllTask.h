/****************************************************************************
  This file is part of LoLA.

  LoLA is free software: you can redistribute it and/or modify it under the
  terms of the GNU Affero General Public License as published by the Free
  Software Foundation, either version 3 of the License, or (at your option)
  any later version.

  LoLA is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
  more details.

  You should have received a copy of the GNU Affero General Public License
  along with LoLA. If not, see <http://www.gnu.org/licenses/>.
****************************************************************************/

#pragma once

#include <Core/Dimensions.h>
#include <Witness/Path.h>
#include <Planning/Task.h>
#include <Planning/Task.h>
#include <Planning/LTLTask.h>
#include <Frontend/Parser/ast-system-k.h>
#include <Frontend/Parser/ast-system-yystype.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <Frontend/Parser/ast-system-unpk.h>
#include <Portfolio/portfoliomanager.h>

/*!
\brief the verification task

This class delegates the SINGLEPATHALL problem to the LTL problem.
It adjusts the formula under investigation and the result interpretation.
SINGLEPATHEX is an only existentially quantified CTL formula with single witness path. SINGLEPATHALL is
a iuniversally quantified CTL formule with single counterexample. The latter is equivalent to
the LTL formula that is generated by removing all path quantifiers and thus exempted from
general CTL model checking

*/

class SinglePathAllTask : public Task
{
public:
    ~SinglePathAllTask(){}
   SinglePathAllTask(Petrinet * n, int par, tFormula  f, int fid)
   {
	preprocessingfinished = false;
	net = n;
	parent = par;
	formula = f;
	formula_id = fid;
	result = TERNARY_UNKNOWN;
	taskname = deconst("universal single path formula");
	portfolio_id = portfoliomanager::addTask(n,this,par,fid,FORMULA_SINGLEPATHALL,WRAP_TASK);
   }

    /// run the actual verification algorithm
    ternary_t getResult() {return TERNARY_UNKNOWN;}

    /// interprete and display the result
    char * interpreteResult(ternary_t result) {
    switch (result)
    {
    case TERNARY_TRUE: return deconst("The universal single path CTL formula holds.");
    case TERNARY_FALSE: return deconst( "The universal single path CTL formula does not hold.");
    case TERNARY_UNKNOWN: return deconst( "The universal single path CTL formula may or may not hold.");
   default: assert(false);
    }
return NULL;
   }

    Path getWitnessPath() { return * new Path(net);}
    capacity_t *getMarking() { return NULL;}
    statusrecord * getStatus(){ return NULL;}
    statusrecord *  getStatistics(){return NULL; }

    static void buildTask(Petrinet * n, int par,tFormula  f, int fid) {
	SinglePathAllTask * N = new SinglePathAllTask(n,par,f,fid);
	f -> id = NULL;
	int myid = portfoliomanager::addFormula(f);
	f = f->rewrite(kc::removepathquantifiers);
	LTLTask::buildTask(n,N->portfolio_id,f,myid);
	N -> preprocessingfinished = true;
    }
    void derail(){}
    Task * copy(){return NULL;}
};
